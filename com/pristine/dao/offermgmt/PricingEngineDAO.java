package com.pristine.dao.offermgmt;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.text.DecimalFormat;
//import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
//import java.util.Collections;
//import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.pristine.dao.DBManager;
import com.pristine.dao.IDAO;
import com.pristine.dao.RetailCalendarDAO;
import com.pristine.dao.RetailPriceDAO;
import com.pristine.dto.CompetitiveDataDTO;
import com.pristine.dto.MovementWeeklyDTO;
import com.pristine.dto.ProductDTO;
import com.pristine.dto.ProductMetricsDataDTO;
import com.pristine.dto.RetailCalendarDTO;
import com.pristine.dto.RetailCostDTO;
import com.pristine.dto.RetailPriceDTO;
import com.pristine.dto.offermgmt.DashboardDTO;
import com.pristine.dto.offermgmt.ExecutionTimeLog;
import com.pristine.dto.offermgmt.LocationKey;
import com.pristine.dto.offermgmt.MultiplePrice;
import com.pristine.dto.offermgmt.PRExplainLog;
import com.pristine.dto.offermgmt.PRItemAdInfoDTO;
//import com.pristine.dto.offermgmt.PRGuidelinePI;
//import com.pristine.dto.offermgmt.PRGuidelinesDTO;
import com.pristine.dto.offermgmt.PRItemDTO;
import com.pristine.dto.offermgmt.PRItemDisplayInfoDTO;
import com.pristine.dto.offermgmt.PRItemSaleInfoDTO;
import com.pristine.dto.offermgmt.PROrderCode;
import com.pristine.dto.offermgmt.PRPriceGroupDTO;
import com.pristine.dto.offermgmt.PRProductGroupProperty;
import com.pristine.dto.offermgmt.PRRecommendationRunHeader;
import com.pristine.dto.offermgmt.PRRoundingTableDTO;
import com.pristine.dto.offermgmt.PRSellCode;
import com.pristine.dto.offermgmt.PRStorePrice;
import com.pristine.dto.offermgmt.PRStrategyDTO;
import com.pristine.dto.offermgmt.PriceCheckListDTO;
import com.pristine.dto.offermgmt.ProductKey;
import com.pristine.dto.offermgmt.RecommendationRuleMapDTO;
import com.pristine.dto.offermgmt.RetailPriceCostKey;
import com.pristine.dto.offermgmt.SecondaryZoneRecDTO;
import com.pristine.dto.offermgmt.mwr.MWRItemDTO;
import com.pristine.dto.offermgmt.mwr.RecommendationInputDTO;
import com.pristine.dto.offermgmt.prediction.PredictionInputDTO;
import com.pristine.exception.GeneralException;
import com.pristine.exception.OfferManagementException;
import com.pristine.service.ProductService;
//import com.pristine.service.ProductService;
import com.pristine.service.RetailCostServiceOptimized;
import com.pristine.service.RetailPriceServiceOptimized;
import com.pristine.service.offermgmt.DisplayTypeLookup;
//import com.pristine.service.offermgmt.GuidelineTypeLookup;
import com.pristine.service.offermgmt.ItemKey;
import com.pristine.service.offermgmt.ItemService;
import com.pristine.service.offermgmt.MostOccurrenceData;
import com.pristine.service.offermgmt.PricingEngineService;
import com.pristine.service.offermgmt.RecommendationErrorCode;
import com.pristine.service.offermgmt.prediction.PredictionEngineKey;
//import com.pristine.service.offermgmt.prediction.PredictionEngineOutput;
import com.pristine.service.offermgmt.prediction.PredictionEngineValue;
import com.pristine.service.offermgmt.prediction.PredictionStatus;
import com.pristine.util.Constants;
import com.pristine.util.DateUtil;
import com.pristine.util.PristineDBUtil;
import com.pristine.util.PropertyManager;
import com.pristine.util.offermgmt.PRCommonUtil;
import com.pristine.util.offermgmt.PRConstants;
import com.pristine.util.offermgmt.PRFormatHelper;

@SuppressWarnings({ "unused", "static-access" })

public class PricingEngineDAO implements IDAO {
	private static Logger logger = Logger.getLogger("PricingEngineDAO");

	private static final int commitCount = Constants.LIMIT_COUNT;
	DateTimeFormatter formatter = DateTimeFormatter.ofPattern(Constants.APP_DATE_FORMAT);

	// private static final String GET_STRATEGY_DETAILS = "SELECT STRATEGY_ID,
	// PRODUCT_LEVEL_ID, PRODUCT_ID, LOCATION_LEVEL_ID, LOCATION_ID,
	// START_CALENDAR_ID, END_CALENDAR_ID, APPLY_TO FROM PR_STRATEGY WHERE
	// STRATEGY_ID = ?";
	private static final String GET_STRATEGY_DETAILS = "SELECT STRATEGY_ID, PRODUCT_LEVEL_ID, PRODUCT_ID, LOCATION_LEVEL_ID, LOCATION_ID, START_CALENDAR_ID, END_CALENDAR_ID, APPLY_TO, TO_CHAR(RCS.START_DATE, 'MM/DD/YYYY') AS START_DATE, "
			+ " (CASE WHEN RCE.START_DATE IS NULL AND RCE.END_DATE IS NULL AND RCS.END_DATE IS NULL THEN TO_CHAR(RCS.START_DATE, 'MM/DD/YYYY')  "
			+ " WHEN RCE.START_DATE IS NULL AND RCE.END_DATE IS NULL THEN TO_CHAR(RCS.END_DATE, 'MM/DD/YYYY') "
			+ " WHEN RCE.END_DATE IS NULL THEN TO_CHAR(RCE.START_DATE, 'MM/DD/YYYY') "
			+ " ELSE TO_CHAR(RCE.END_DATE, 'MM/DD/YYYY') END) END_DATE, " + " STATE_ID,DSD_RECOMMENDATION_FLAG "
			+ " FROM PR_STRATEGY S " + " LEFT JOIN RETAIL_CALENDAR RCS on S.START_CALENDAR_ID = RCS.CALENDAR_ID "
			+ " LEFT JOIN RETAIL_CALENDAR RCE on S.END_CALENDAR_ID = RCE.CALENDAR_ID " + " WHERE S.STRATEGY_ID = ? ";

	private static final String GET_STORE_COMPETITORS = "SELECT PRIMARY_COMP_STR_ID, SECONDARY_COMP_STR_ID_1 FROM STORE_SUMMARY WHERE STORE_ID = ?";

	private static final String GET_ZONE_COMPETITORS = "SELECT PRIMARY_COMP_STR_ID, SECONDARY_COMP_STR_ID_1 FROM RETAIL_PRICE_ZONE WHERE PRICE_ZONE_ID = ?";

	private static final String GET_RECOMMENDATION_RUN_ID = "SELECT PR_RECOMMENDATION_RUN_ID_SEQ.NEXTVAL AS RUN_ID FROM DUAL";
	
	//Changes done by Bhargavi on 01/05/2021
	//update the MarkUp and MarkDown values for Rite Aid
	private static final String GET_INVENTORY_DETAILS = "SELECT ITEM_CODE, SUM(QTY_IN_HAND) AS QTY_IN_HAND "
			+ "FROM STORE_INVENTORY WHERE  "
			+ "CALENDAR_ID = (SELECT MAX(CALENDAR_ID) FROM STORE_INVENTORY)"
//			+ "CALENDAR_ID = (SELECT CALENDAR_ID FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W' AND "
//			+ " RC.START_DATE = TO_DATE(?,'MM/DD/YYYY') )"
			+ " AND ITEM_CODE IN " + " ( " + " SELECT CHILD_PRODUCT_ID AS ITEM_CODE FROM " + " ( "
			+ " SELECT CHILD_PRODUCT_ID,   " + "   CHILD_PRODUCT_LEVEL_ID  " + " FROM PRODUCT_GROUP_RELATION_REC PGR  "
			+ "   START WITH PRODUCT_LEVEL_ID       = ?  " + " AND PRODUCT_ID                      = ?  "
			+ "   CONNECT BY PRIOR CHILD_PRODUCT_ID = PRODUCT_ID  "
			+ " AND PRIOR CHILD_PRODUCT_LEVEL_ID    = PRODUCT_LEVEL_ID " + " ) " + " WHERE CHILD_PRODUCT_LEVEL_ID = 1 "
			+ " ) AND STORE_ID IN  " + "(SELECT COMP_STR_ID FROM COMPETITOR_STORE WHERE PRICE_ZONE_ID = ? OR PRICE_ZONE_ID_3 = ?)"
			+ "GROUP BY ITEM_CODE ORDER BY ITEM_CODE";  
	//Changes-ended

	private static final String INSERT_RECOMMENDATION_HEADER = "INSERT INTO PR_RECOMMENDATION_RUN_HEADER (RUN_ID, CALENDAR_ID, LOCATION_LEVEL_ID, LOCATION_ID, "
			+ "PRODUCT_LEVEL_ID, PRODUCT_ID, RUN_TYPE, START_RUN_TIME, PREDICTED_BY, PREDICTED) VALUES "
			+ "(?, ?, ?, ?, ?, ?, ?, SYSDATE, ?, SYSDATE)";
		
	private static final String INSERT_RECOMMENDATION_ITEM = "INSERT INTO PR_RECOMMENDATION (PR_RECOMMENDATION_ID, RUN_ID, ITEM_CODE, STRATEGY_ID, PRICE_CHECK_LIST_ID, PREDICTED_MOVEMENT, "
			+ "CUR_REG_MULTIPLE, CUR_REG_PRICE, CUR_LIST_COST, CUR_LIST_COST_EFF_DATE, CUR_VIP_COST, "
			+ "CUR_COMP_REG_MULTIPLE, CUR_COMP_REG_PRICE, "
			+ "COMP_LOCATION_TYPES_ID, COMP_STR_ID, RECOMMENDED_REG_MULTIPLE, RECOMMENDED_REG_PRICE, AVG_MOVEMENT, AVG_REVENUE, "
			+ "COST_CHG_IND, COMP_PRICE_CHG_IND, LOG, IS_PRE_PRICED, IS_LOCKED_PRICE, IS_MARKED_FOR_REVIEW, IS_PRICE_RECOMMENDED, "
			+ "COMP_PRICE_CHECK_DATE, IS_CONFLICT, CHILD_LOCATION_LEVEL_ID, CHILD_LOCATION_ID, PRE_REG_PRICE, PRE_LIST_COST, "
			+ "PRE_COMP_REG_PRICE, DIST_FLAG, IS_OPPORTUNITY, OPPORTUNITY_PRICE, OPPORTUNITY_QUANTITY, OPPORTUNITY_MOVEMENT, PREDICTION_STATUS, "
			+ "CUR_REG_PRICE_PREDICTED_MOV, PRE_VIP_COST, VIP_COST_CHG_IND, ITEM_SIZE, UOM_ID, IS_STORE_PRICE_SAME,"
			+ "VENDOR_ID, PRICE_CHECK_LIST_TYPE_ID, LIR_IND, LIR_ID_OR_ITEM_CODE, IS_REC_ERROR, REC_ERROR_CODE,"
			+ "IS_CUR_RET_SAME_IN_ALL_STORES, ACTUAL_ZONE_ID, IS_SUBSTITUTE, PRED_MOV_WO_SUBS_EFFECT, CUR_REG_PRED_MOV_WO_SUBS_EFT,"
			+ "CUR_SALES_D,CUR_MARGIN_D,REC_SALES_D,REC_MARGIN_D,IS_INCLUDE_FOR_SUM_CAL,CUR_REG_PRICE_EFF_DATE," +
			// ",CUR_SALE_MULTIPLE, CUR_SALE_PRICE, PROMOTION_TYPE_ID,
			// CUR_SALE_EFF_START_DATE, CUR_SALE_EFF_END_DATE, " +
			// "WEEKLY_AD_DATE, AD_PAGE_NO, AD_BLOCK_NO, DISPLAY_TYPE_ID, " +
//					"CUR_SALE_MULTIPLE, CUR_SALE_PRICE,CUR_SALE_PROMO_TYPE_ID, " +
//					"CUR_SALE_PRED_MOV, CUR_SALE_PRED_STATUS,  CUR_SALE_COST," +
			"CUR_COMP_SALE_MULTIPLE, CUR_COMP_SALE_PRICE, "
			+ "REC_WEEK_SALE_MULTIPLE, REC_WEEK_SALE_PRICE, REC_WEEK_PROMO_TYPE_ID, REC_WEEK_SALE_START_DATE,  "
			+ "REC_WEEK_SALE_END_DATE, REC_WEEK_SALE_PRED_AT_CUR_REG, REC_WEEK_SALE_PRED_STATUS_CUR, "
			+ "REC_WEEK_SALE_PRED_AT_REC_REG,REC_WEEK_SALE_PRED_STATUS_REC," + "REC_WEEK_SALE_COST,  "
			+ "FUT_WEEK_SALE_MULTIPLE, FUT_WEEK_SALE_PRICE, FUT_WEEK_PROMO_TYPE_ID, FUT_WEEK_SALE_START_DATE, FUT_WEEK_SALE_END_DATE,  "
			+ "REC_WEEK_AD_PAGE_NO, REC_WEEK_AD_BLOCK_NO, "
			+ "FUT_WEEK_AD_START_DATE, FUT_WEEK_AD_PAGE_NO, FUT_WEEK_AD_BLOCK_NO,  "
			+ "REC_WEEK_DISPLAY_TYPE_ID, FUT_WEEK_DISPLAY_START_DATE, FUT_WEEK_DISPLAY_TYPE_ID,  "
			+ "IS_TPR, IS_SALE, IS_AD," + "REG_EFF_DATE, " + "REC_FUT_REG_MULTIPLE, REC_FUT_REG_PRICE "
			+ ",LIG_REP_ITEM_CODE , REC_REG_PRED_REASONS, REC_SALE_PRED_REASONS " + ") "
			+ "VALUES(PR_RECOMMENDATION_ID_SEQ.NEXTVAL, ?, ?, ?, ?, ?, ?, ?, ?, TO_DATE(?, 'MM/dd/yyyy'), ?, ?, ?, ?, ?, ?, ?, "
			+ "?, ?, ?, ?, ?, ?, ?, ?, ?, TO_DATE(?, 'MM/dd/yyyy'), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, "
			+ "?, ?, ?, ?, ?, ?, ?, ?, ?" + ",?,?,?,?,?,TO_DATE(?, 'MM/dd/yyyy')," +
			// ",?,?,?,TO_DATE(?, 'MM/dd/yyyy'),TO_DATE(?, 'MM/dd/yyyy'),TO_DATE(?,
			// 'MM/dd/yyyy'),?,?,?," +
//					"?, ?, ?, " +
//					"?, ?, ?," +
			"?, ?, " + "?, ?, ?, TO_DATE(?, 'MM/dd/yyyy'),  " + "TO_DATE(?, 'MM/dd/yyyy'), ?, ?, " + "?, ?,  " + "?, "
			+ "?, ?, ?, TO_DATE(?, 'MM/dd/yyyy'), TO_DATE(?, 'MM/dd/yyyy'),  " + "?, ?, "
			+ "TO_DATE(?, 'MM/dd/yyyy'), ?, ?,  " + "?, TO_DATE(?, 'MM/dd/yyyy'), ?,  " + "?, ?, ?, "
			+ "TO_DATE(?, 'MM/dd/yyyy'), " + "?,?, " + "?, ?, ?" + ")";

	private static final String INSERT_RECOMMENDATION_ITEM_STORE = "INSERT INTO PR_RECOMMENDATION_STORE (PR_RECOMMENDATION_STORE_ID, PR_RECOMMENDATION_ID, STORE_ID, STRATEGY_ID, "
			+ "PREDICTED_MOVEMENT, CUR_REG_MULTIPLE, CUR_REG_PRICE, CUR_LIST_COST, CUR_LIST_COST_EFF_DATE, CUR_VIP_COST, "
			+ "CUR_COMP_REG_MULTIPLE, CUR_COMP_REG_PRICE, COMP_LOCATION_TYPES_ID, COMP_STR_ID, RECOMMENDED_REG_MULTIPLE, "
			+ "RECOMMENDED_REG_PRICE, "
			+ "AVG_MOVEMENT, AVG_REVENUE, COST_CHG_IND, COMP_PRICE_CHG_IND, LOG, IS_PRE_PRICED, IS_LOCKED_PRICE, "
			+ "IS_MARKED_FOR_REVIEW, IS_PRICE_RECOMMENDED, IS_CONFLICT, PRE_LIST_COST, PRE_COMP_REG_PRICE, DIST_FLAG, "
			+ "PRE_REG_PRICE, COMP_PRICE_CHECK_DATE, IS_OPPORTUNITY, OPPORTUNITY_PRICE, OPPORTUNITY_QUANTITY, "
			+ "PREDICTION_STATUS, CUR_REG_PRICE_PREDICTED_MOV, PRE_VIP_COST, VIP_COST_CHG_IND, ITEM_SIZE, UOM_ID,"
			+ "VENDOR_ID, IS_REC_ERROR, REC_ERROR_CODE "
			+ ",CUR_SALES_D,CUR_MARGIN_D,REC_SALES_D,REC_MARGIN_D,IS_INCLUDE_FOR_SUM_CAL,CUR_REG_PRICE_EFF_DATE" + " ) "
			+ "VALUES(PR_RECOMMENDATION_STORE_ID_SEQ.NEXTVAL, ?, ?, ?, ?, ?, ?, ?, TO_DATE(?, 'MM/dd/yyyy'), ?, ?, ?, ?, ?, "
			+ "?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, TO_DATE(?, 'MM/dd/yyyy'), ?, ?, ?, ?, ?, ?, ?, ?, ?, "
			+ "?, ?, ?" + ",?,?,?,?,?,TO_DATE(?, 'MM/dd/yyyy')" + ")";

	private static final String UPDATE_RECOMMENDATION_HEADER = "UPDATE PR_RECOMMENDATION_RUN_HEADER SET END_RUN_TIME = SYSDATE, RUN_STATUS = ?, STATUS = ? WHERE RUN_ID = ?";

	private static final String UPDATE_RECOMMENDATION_HEADER_STATUS = "UPDATE PR_RECOMMENDATION_RUN_HEADER SET RUN_STATUS = ?, STATUS = ? WHERE RUN_ID = ?";

	private static final String UPDATE_CUR_RETAIL_CAL_ID_RUN_HEADER = "UPDATE PR_RECOMMENDATION_RUN_HEADER SET CUR_RETAIL_CALENDAR_ID = ? WHERE RUN_ID = ?";

	private static final String UPDATE_RECOMMENDATION_STATUS = "UPDATE PR_RECOMMENDATION_RUN_HEADER SET MESSAGE = ?, PERCENT_COMPLETION = ? WHERE RUN_ID = ?";

	private static final String GET_PR_RECOMMENDATION_ID = "SELECT PR_RECOMMENDATION_ID FROM PR_RECOMMENDATION WHERE RUN_ID = ? AND LIR_ID_OR_ITEM_CODE = ?"
			+ " AND LIR_IND = ? ";

	private static final String UPDATE_PR_RECOMMENDATION_STORE = "UPDATE PR_RECOMMENDATION SET RECOMMENDATION_STORE = 'Y' WHERE PR_RECOMMENDATION_ID = ?";

	private static final String GET_DEFAULT_ROUNDING_TABLE = "SELECT ROUNDING_TABLE_ID FROM PR_ROUNDING_TABLE WHERE IS_DEFAULT = 'Y'";

	private static final String GET_ROUNDING_TABLE_CONTENT = "SELECT START_PRICE, END_PRICE, ALLOWED_END_DIGITS, ALLOWED_PRICES, EXCLUDED_PRICES FROM PR_ROUNDING_TABLE_DETAIL WHERE ROUNDING_TABLE_ID = ?";

	private static final String GET_RECOMMENDATION = "SELECT I.RETAILER_ITEM_CODE, I.UPC, P.STRATEGY_ID, P.RECOMMENDED_REG_MULTIPLE, P.RECOMMENDED_REG_PRICE, P.CUR_REG_PRICE, P.CUR_REG_MULTIPLE FROM PR_RECOMMENDATION P, ITEM_LOOKUP I WHERE P.RUN_ID = ? AND P.ITEM_CODE = I.ITEM_CODE AND I.ITEM_CODE < 920000";

	// private static final String IS_PRICE_EXISTS = "SELECT COUNT(*) AS COUNT FROM
	// SYNONYM_RETAIL_PRICE_INFO WHERE CALENDAR_ID = ? AND ROWNUM <= ?";

	private static final String IS_PRICE_EXISTS = "SELECT COUNT(*) AS COUNT FROM SYN_RETAIL_PRICE_INFO WHERE CALENDAR_ID = ? AND ROWNUM <= ?";

	private static final String GET_ZONES_UNDER_ZONE_LIST = "SELECT CHILD_LOCATION_ID FROM LOCATION_GROUP_RELATION WHERE LOCATION_LEVEL_ID = 21 AND LOCATION_ID = ?";

	private static final String GET_PRODUCTS_UNDER_PRODUCT_LIST = "SELECT CHILD_PRODUCT_LEVEL_ID, CHILD_PRODUCT_ID FROM PRODUCT_GROUP_RELATION WHERE PRODUCT_LEVEL_ID = 21 AND PRODUCT_ID = ?";

	private static final String GET_PRODUCT_LIST_ID = "SELECT PRODUCT_ID FROM  " + " ( "
			+ " SELECT CHILD_PRODUCT_ID, CHILD_PRODUCT_LEVEL_ID, PRODUCT_LEVEL_ID, PRODUCT_ID "
			+ " FROM PRODUCT_GROUP_RELATION PGR WHERE PRODUCT_LEVEL_ID  = 21 "
			+ " ) WHERE CHILD_PRODUCT_LEVEL_ID = ? AND CHILD_PRODUCT_ID = ?";

	private static final String GET_LOCATION_LIST_ID = "SELECT LOCATION_ID FROM  " + " ( "
			+ " SELECT CHILD_LOCATION_ID, CHILD_LOCATION_LEVEL_ID, LOCATION_LEVEL_ID, LOCATION_ID "
			+ " FROM LOCATION_GROUP_RELATION PGR WHERE LOCATION_LEVEL_ID  = 21 "
			+ " ) WHERE CHILD_LOCATION_LEVEL_ID = ? AND CHILD_LOCATION_ID = ? ";

		
	private static final String GET_STORE_LOCATION_LIST_ID = "SELECT LOCATION_ID FROM  " + " ( "
			+ " SELECT CHILD_LOCATION_ID, CHILD_LOCATION_LEVEL_ID, LOCATION_LEVEL_ID, LOCATION_ID "
			+ " FROM LOCATION_GROUP_RELATION PGR WHERE LOCATION_LEVEL_ID  = 7 "
			+ " ) WHERE CHILD_LOCATION_LEVEL_ID = ? AND CHILD_LOCATION_ID = ? ";

	private static final String GET_RECOMMENDATION_ITEMS = "SELECT PR.ITEM_CODE, PR.LIR_IND, CASE PR.LIR_IND WHEN 'N' THEN IL.RET_LIR_ID ELSE 0 END AS RET_LIR_ID, "
			+ " RECOMMENDED_REG_MULTIPLE, RECOMMENDED_REG_PRICE, AVG_MOVEMENT, PREDICTED_MOVEMENT, CUR_COMP_REG_MULTIPLE, CUR_COMP_REG_PRICE, IS_PRICE_RECOMMENDED, "
			+ " IS_CONFLICT, CUR_REG_MULTIPLE, CUR_REG_PRICE, IS_REC_ERROR, "
			+ " OVERRIDE_REG_MULTIPLE, OVERRIDE_REG_PRICE, IS_MARKED_FOR_REVIEW, PRICE_CHECK_LIST_ID, COMP_STR_ID, REC_REG_PRED_REASONS, REC_SALE_PRED_REASONS  "
			+ " FROM PR_RECOMMENDATION PR LEFT JOIN ITEM_LOOKUP IL "
			+ " ON PR.ITEM_CODE =  IL.ITEM_CODE WHERE RUN_ID = ? ";

	private static final String GET_PRICE_CHECK_LIST_INFO = " SELECT PCL.*, IL.RET_LIR_ID, IL.LIR_IND, PCLTL.PRECEDENCE ,PCLTL.CODE AS CHECKLIST_NAME FROM ("
			// + "MIN_PRICE, MAX_PRICE, LOCKED_RETAIL, END_DATE "
			+ " SELECT ITEM.PRICE_CHECK_LIST_ID, ITEM.ITEM_CODE, ITEM.MIN_PRICE, ITEM.MAX_PRICE, ITEM.LOCKED_RETAIL, ITEM.END_DATE, "
			+ " PRICE_CHECK_LIST_TYPE_ID, LOCATION_LEVEL_ID, LOCATION_ID, TO_CHAR(PRICE_CHECK_LIST.CREATE_DATETIME, '"
			+ Constants.DB_DATE_FORMAT + "') AS CREATE_DATETIME ,TO_CHAR(PRICE_CHECK_LIST.UPDATE_DATETIME, '"
			+ Constants.DB_DATE_FORMAT + "') AS UPDATE_DATETIME FROM( "
			+ " SELECT PRICE_CHECK_LIST_ID, ITEM_CODE, MIN_PRICE, MAX_PRICE, " + " LOCKED_RETAIL, TO_CHAR(END_DATE, '"
			+ Constants.DB_DATE_FORMAT + "') AS END_DATE FROM PRICE_CHECK_LIST_ITEMS   "
			+ " WHERE (PRICE_CHECK_LIST_ID IN   " + " (SELECT ID FROM PRICE_CHECK_LIST WHERE "
			+ " (IS_SYSTEM_LIST IS NULL OR IS_SYSTEM_LIST <> 'Y')" + " AND PRICE_CHECK_LIST_TYPE_ID <> "
			+ PRConstants.STORE_LOCK_LIST
			+ " AND PRICE_CHECK_LIST_TYPE_ID <> (SELECT PRICE_CHECK_LIST_TYPE_ID FROM price_check_list_type_lookup WHERE display_name='PRICE TEST')"
			+ " AND (PRICE_CHECK_LIST_TYPE_ID IS NOT NULL AND PRICE_CHECK_LIST_TYPE_ID > 0) AND ACTIVE_STATUS = 'Y'"
			+ ")) AND (END_DATE > TO_DATE(?, 'MM/DD/YYYY') OR END_DATE IS NULL)  " + " AND ITEM_CODE IN " + " ( "
			+ " SELECT CHILD_PRODUCT_ID AS ITEM_CODE FROM " + " ( " + " SELECT CHILD_PRODUCT_ID,   "
			+ "   CHILD_PRODUCT_LEVEL_ID  " + " FROM PRODUCT_GROUP_RELATION_REC PGR  "
			+ "   START WITH PRODUCT_LEVEL_ID       = ?  " + " AND PRODUCT_ID                      = ?  "
			+ "   CONNECT BY PRIOR CHILD_PRODUCT_ID = PRODUCT_ID  "
			+ " AND PRIOR CHILD_PRODUCT_LEVEL_ID    = PRODUCT_LEVEL_ID " + " ) " + " WHERE CHILD_PRODUCT_LEVEL_ID = 1 "
			+ " )" + " " + 
			")ITEM LEFT JOIN PRICE_CHECK_LIST ON ITEM.PRICE_CHECK_LIST_ID = PRICE_CHECK_LIST.ID)"
			+ " PCL LEFT JOIN ITEM_LOOKUP IL ON PCL.ITEM_CODE = IL.ITEM_CODE "
			+ " LEFT JOIN PRICE_CHECK_LIST_TYPE_LOOKUP PCLTL ON PCL.PRICE_CHECK_LIST_TYPE_ID = PCLTL.PRICE_CHECK_LIST_TYPE_ID";

	private static final String GET_STORES_UNDER_STORE_LIST_FOR_ZONE = "SELECT LOCATION_ID, CHILD_LOCATION_ID FROM LOCATION_GROUP_RELATION WHERE LOCATION_LEVEL_ID = 7 AND CHILD_LOCATION_ID IN (SELECT COMP_STR_ID FROM COMPETITOR_STORE WHERE PRICE_ZONE_ID = ?)";

	private static final String GET_ZONE_ID_FOR_STORE = "SELECT PRICE_ZONE_ID FROM COMPETITOR_STORE WHERE COMP_STR_ID = ?";

	private static final String GET_MOVE_DATA_FOR_STORE_FROM_IMS = "SELECT LOCATION_ID AS COMP_STR_ID, PRODUCT_ID AS ITEM_CODE, TO_CHAR(RC.START_DATE,'MM/DD/YYYY') AS START_DATE,"
			+
			// "LIST_COST,TOT_REVENUE AS TOTAL_REVENUE,TOT_MOVEMENT AS TOTAL_QUANTITY FROM
			// ITEM_METRIC_SUMMARY_WEEKLY IMS " +
			// "LIST_COST,TOT_REVENUE AS TOTAL_REVENUE,TOT_MOVEMENT AS TOTAL_QUANTITY FROM
			// SYNONYM_IMS_WEEKLY IMS " +
			"LIST_COST,TOT_REVENUE AS TOTAL_REVENUE,TOT_MOVEMENT AS TOTAL_QUANTITY FROM SYN_ITEM_METRIC_SUMMARY_WEEKLY IMS "
			+ "LEFT JOIN RETAIL_CALENDAR RC ON   RC.CALENDAR_ID = IMS.CALENDAR_ID "
			+ "WHERE LOCATION_ID = ? AND LOCATION_LEVEL_ID = ? AND PRODUCT_LEVEL_ID = ? "
			+ "AND RC.START_DATE <= TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE >= TO_DATE(?,'MM/DD/YYYY') - ? "
			+ "AND PRODUCT_ID IN " + "(%s)";
	// "(SELECT CHILD_PRODUCT_ID FROM (SELECT * FROM PRODUCT_GROUP_RELATION PGR " +
	// " %QUERY_CONDITION%) WHERE CHILD_PRODUCT_LEVEL_ID = 1)";

	/*
	 * private static final String GET_MOVE_DATA_FOR_ZONE_FROM_IMS =
	 * "SELECT PRODUCT_ID AS ITEM_CODE, TO_CHAR(RC.START_DATE,'MM/DD/YYYY') AS START_DATE, "
	 * +
	 * "SUM(TOT_REVENUE) AS TOTAL_REVENUE,SUM(TOT_MOVEMENT) AS TOTAL_QUANTITY FROM SYNONYM_IMS_WEEKLY IMS "
	 * + "LEFT JOIN RETAIL_CALENDAR RC ON   RC.CALENDAR_ID = IMS.CALENDAR_ID " +
	 * "WHERE LOCATION_ID IN (%PRICE_ZONE_STORES%) AND LOCATION_LEVEL_ID = ? AND PRODUCT_LEVEL_ID = ? "
	 * +
	 * "AND RC.START_DATE <= TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE >= TO_DATE(?,'MM/DD/YYYY') - ? "
	 * + "AND PRODUCT_ID IN " + "(%s) GROUP BY START_DATE, PRODUCT_ID" ;
	 */
	// NU::2nd Aug 2016, previously 13 weeks was considered from week from which
	// recommendation runs
	// Actually week from which recommendation runs may not have received actual
	// movement
	// So changed to consider from previous week from which recommendation runs
	// Max of sale price is taken as this is used to find if an item is on sale even
	// for a
	// store in a week
	/*
	 * private static final String GET_MOVE_DATA_FOR_ZONE_FROM_IMS =
	 * "SELECT CALENDAR_ID, PRODUCT_ID AS ITEM_CODE, MIN(FINAL_PRICE) AS MIN_UNIT_PRICE,"
	 * +
	 * "MAX(SALE_PRICE) AS SALE_PRICE, MAX(SALE_M_PRICE) AS SALE_M_PRICE, SUM(TOT_REVENUE) AS TOTAL_REVENUE, "
	 * + "SUM(TOT_MOVEMENT) AS TOTAL_QUANTITY FROM SYNONYM_IMS_WEEKLY IMS " +
	 * "WHERE CALENDAR_ID IN (SELECT CALENDAR_ID FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W' AND "
	 * //+
	 * "RC.START_DATE <= TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE >= TO_DATE(?,'MM/DD/YYYY') - ?) "
	 * +
	 * "RC.START_DATE < TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE > TO_DATE(?,'MM/DD/YYYY') - (?+1)*7) "
	 * + " AND LOCATION_ID IN (%PRICE_ZONE_STORES%) AND PRODUCT_ID IN " +
	 * "(%s) GROUP BY CALENDAR_ID, PRODUCT_ID";
	 */
	// 26th Aug 2016, changed to find min price on the fly as data in the table in
	// incorrect

	private static final String GET_MOVE_DATA_FOR_ZONE_FROM_IMS_STORE_TABLE = "SELECT CALENDAR_ID,ITEM_CODE, SALE_FLAG,REG_M_PACK, REG_PRICE,"
			+ " SALE_M_PACK,SALE_PRICE, "
			+ " CASE WHEN SALE_PRICE > 0 THEN CASE WHEN SALE_M_PACK>0  THEN SALE_PRICE/SALE_M_PACK ELSE SALE_PRICE END "
			+ " ELSE CASE WHEN REG_M_PACK > 0  THEN  REG_PRICE / REG_M_PACK ELSE REG_PRICE END "
			+ " END AS FINAL_UNIT_PRICE,TOTAL_QUANTITY, TOTAL_REVENUE FROM( "
			+ " SELECT CALENDAR_ID, PRODUCT_ID AS ITEM_CODE, SALE_FLAG, "
			+ " TO_NUMBER(SUBSTR(REG_PRICE, 1, INSTR(REG_PRICE, '/', -1, 1) -1)) AS REG_M_PACK,"
			+ " TO_NUMBER(SUBSTR(REG_PRICE, INSTR(REG_PRICE, '/', -1, 1) +1)) AS REG_PRICE,"
			+ " TO_NUMBER(SUBSTR(SALE_PRICE, 1, INSTR(SALE_PRICE, '/', -1, 1) -1)) AS SALE_M_PACK,"
			+ " TO_NUMBER(SUBSTR(SALE_PRICE, INSTR(SALE_PRICE, '/', -1, 1) +1)) AS SALE_PRICE,"
			+ " TOTAL_QUANTITY, TOTAL_REVENUE" + " FROM ("
			+ " SELECT CALENDAR_ID AS CALENDAR_ID, PRODUCT_ID, STATS_MODE(SALE_FLAG) AS SALE_FLAG, " + " STATS_MODE("
			+ " CASE" + " WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE > 0) THEN  ('1' ||  '/' || NVL(REG_PRICE,0))"
			+ " WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE = 0) THEN  (REG_M_PACK ||  '/' || NVL(REG_PRICE,0))"
			+ " ELSE (REG_M_PACK || '/' || NVL(REG_M_PRICE,0))" + " END) AS REG_PRICE ," + " STATS_MODE(" + " CASE"
			+ " WHEN (NVL(SALE_M_PACK,0) <= 1 AND SALE_PRICE > 0) THEN  ('1' ||  '/' || NVL(SALE_PRICE,0))"
			+ " WHEN (NVL(SALE_M_PACK,0) <= 1 AND SALE_PRICE = 0) THEN  (SALE_M_PACK ||  '/' || NVL(SALE_PRICE,0))"
			+ " ELSE (SALE_M_PACK || '/' || NVL(SALE_M_PRICE,0))" + " END) AS SALE_PRICE,"
			+ " SUM(TOT_MOVEMENT) AS TOTAL_QUANTITY, SUM(TOT_REVENUE) AS TOTAL_REVENUE" + " FROM (" + " SELECT"
			+ " CALENDAR_ID,PRODUCT_ID,SALE_FLAG, REG_PRICE,REG_M_PACK,"
			// + " REG_M_PRICE,SALE_PRICE,SALE_M_PACK,SALE_M_PRICE,TOT_MOVEMENT,
			// TOT_REVENUE" + " FROM SYNONYM_IMS_WEEKLY IMS "
			+ " REG_M_PRICE,SALE_PRICE,SALE_M_PACK,SALE_M_PRICE,TOT_MOVEMENT, TOT_REVENUE"
			+ " FROM SYN_ITEM_METRIC_SUMMARY_WEEKLY IMS  " + " WHERE PRODUCT_ID IN  (%s) "
			+ " AND CALENDAR_ID IN (SELECT CALENDAR_ID FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W' AND "
			+ " RC.START_DATE < TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE > TO_DATE(?,'MM/DD/YYYY') - (?+1)*7)"
			+ " AND LOCATION_ID IN (%PRICE_ZONE_STORES%)" + " ) GROUP BY CALENDAR_ID , PRODUCT_ID))";

	private static final String GET_MOVE_DATA_FOR_ZONE_FROM_IMS_ZONE_TABLE = " SELECT CALENDAR_ID, ITEM_CODE, "
			+ " TO_NUMBER(SUBSTR(REG_PRICE, 1, INSTR(REG_PRICE, '/', -1, 1) -1)) AS REG_M_PACK,"
			+ " TO_NUMBER(SUBSTR(REG_PRICE, INSTR(REG_PRICE, '/', -1, 1) +1)) AS REG_PRICE,"
			+ " TO_NUMBER(SUBSTR(SALE_PRICE, 1, INSTR(SALE_PRICE, '/', -1, 1) -1)) AS SALE_M_PACK,"
			+ " TO_NUMBER(SUBSTR(SALE_PRICE, INSTR(SALE_PRICE, '/', -1, 1) +1)) AS SALE_PRICE,"
			+ " TOTAL_QUANTITY, TOTAL_REVENUE, FINAL_UNIT_PRICE FROM" + "(SELECT CALENDAR_ID, PRODUCT_ID AS ITEM_CODE, "
			+ " CASE" + " WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE > 0) THEN  ('1' ||  '/' || NVL(REG_PRICE,0))"
			+ " WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE = 0) THEN  (REG_M_PACK ||  '/' || NVL(REG_PRICE,0))"
			+ " ELSE (REG_M_PACK || '/' || NVL(REG_M_PRICE,0))" + " END AS REG_PRICE ," + " CASE"
			+ " WHEN (NVL(SALE_M_PACK,0) <= 1 AND SALE_PRICE > 0) THEN  ('1' ||  '/' || NVL(SALE_PRICE,0))"
			+ " WHEN (NVL(SALE_M_PACK,0) <= 1 AND SALE_PRICE = 0) THEN  (SALE_M_PACK ||  '/' || NVL(SALE_PRICE,0))"
			+ " ELSE (SALE_M_PACK || '/' || NVL(SALE_M_PRICE,0))" + " END AS SALE_PRICE,"
			+ " TOT_MOVEMENT AS TOTAL_QUANTITY, TOT_REVENUE AS TOTAL_REVENUE, FINAL_PRICE AS FINAL_UNIT_PRICE"
			+ " FROM IMS_WEEKLY_ZONE IMS  " + " WHERE PRODUCT_ID IN  (%s) "
			+ " AND CALENDAR_ID IN (SELECT CALENDAR_ID FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W' AND "
			+ " RC.START_DATE < TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE > TO_DATE(?,'MM/DD/YYYY') - (?+1)*7)"
			+ " AND LOCATION_ID IN (%PRICE_ZONE_ID%))";

	private static final String GET_COMP_DATA = "SELECT * FROM(SELECT * FROM (SELECT CHILD_PRODUCT_ID FROM "
			+ "(SELECT CHILD_PRODUCT_ID, CHILD_PRODUCT_LEVEL_ID FROM PRODUCT_GROUP_RELATION_REC PGR "
			+ "%QUERY_CONDITION%) WHERE CHILD_PRODUCT_LEVEL_ID = 1)ITEMS LEFT JOIN "
			+ "(SELECT S.COMP_STR_ID, CD.ITEM_CODE, UNITPRICE(CD.REG_PRICE, CD.REG_M_PRICE, CD.REG_M_PACK) AS REG_UNIT_PRICE, "
			+ "TO_CHAR(S.START_DATE, 'MM/DD/YYYY') AS START_DATE, TO_CHAR(S.END_DATE, 'MM/DD/YYYY') AS END_DATE, CD.REG_M_PACK, "
			+ "CD.REG_M_PRICE, TO_CHAR(CD.EFF_REG_START_DATE, 'MM/DD/YYYY') AS EFF_REG_START_DATE, "
			+ "TO_CHAR(CD.CHECK_DATETIME, 'MM/DD/YYYY') AS CHECK_DATETIME, IL.RET_LIR_ID, IL.RETAILER_ITEM_CODE " +
			// "FROM SYNONYM_COMPETITIVE_DATA CD LEFT JOIN SCHEDULE S ON CD.SCHEDULE_ID =
			// S.SCHEDULE_ID " +
			"FROM SYN_COMPETITIVE_DATA CD LEFT JOIN SCHEDULE S ON CD.SCHEDULE_ID = S.SCHEDULE_ID "
			+ "LEFT JOIN ITEM_LOOKUP IL ON CD.ITEM_CODE = IL.ITEM_CODE "
			+ "WHERE START_DATE <= TO_DATE(?,'MM/DD/YYYY') AND START_DATE >= TO_DATE(?,'MM/DD/YYYY') - ? "
			+ "AND COMP_STR_ID IN (%s))COMP_DATA " + "ON ITEMS.CHILD_PRODUCT_ID = COMP_DATA.ITEM_CODE "
			+ " ORDER BY COMP_STR_ID ASC, ITEM_CODE ASC, END_DATE DESC) WHERE COMP_STR_ID IS NOT NULL ";

	private static final String GET_PRD_GRP_PROPERTY = "SELECT PRODUCT_LEVEL_ID, PRODUCT_ID, IS_PERISHABLE, " +
	// " IS_ORDER_SELL_CODE, " +
			"USE_PREDICTION FROM PR_PRODUCT_GROUP_PROPERTY WHERE (%PRODUCTS%)";

	private static final String INSERT_ORDER_CODE_RECOMMENDATION = "INSERT INTO PR_RECOMMENDATION_ORDER (PR_REC_ORDER_CODE_ID, RUN_ID, CHILD_LOCATION_LEVEL_ID, CHILD_LOCATION_ID, "
			+ "ORDER_ITEM_CODE, FRESH_RELATION_HEADER_ID, RECOMMENDED_REG_MULTIPLE, RECOMMENDED_REG_PRICE) "
			+ "VALUES(PR_REC_ORDER_CODE_ID_SEQ.NEXTVAL, ?, ?, ?, ?, ?, ?, ?)";

	private static final String INSERT_EXECUTION_TIME_LOG = "INSERT INTO PR_EXECUTION_TIME_LOG (EXECUTION_TIME_LOG_ID, RUN_ID, CALENDAR_ID, LOCATION_LEVEL_ID, LOCATION_ID, "
			+ "PRODUCT_LEVEL_ID, PRODUCT_ID, EXECUTION_ORDER, FUNCTIONALITY_NAME, PRICE_POINT, START_TIME, END_TIME, "
			+ "TOTAL_TIME, TOTAL_TIME_SECONDS) "
			+ "VALUES(PR_EXECUTION_TIME_LOG_ID_SEQ.NEXTVAL, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

	private static final String GET_ORDER_SELL_CODE_OLD = "SELECT SC.ORDER_CODE, SC.SELL_CODE, SC.YIELD, IL.ITEM_CODE FROM PR_ORDER_SELL_CODE_MAPPING SC "
			+ " LEFT JOIN ITEM_LOOKUP IL ON SC.SELL_CODE = IL.SELL_CODE " + " WHERE IL.SELL_CODE IS NOT NULL "
			+ " AND ITEM_CODE IN (SELECT CHILD_PRODUCT_ID FROM (SELECT * FROM PRODUCT_GROUP_RELATION PGR "
			+ " %QUERY_CONDITION%) WHERE CHILD_PRODUCT_LEVEL_ID = 1)";

	private static final String GET_ORDER_SELL_CODE = "SELECT SC.ORDER_CODE, SC.SELL_CODE, SC.YIELD, IL.ITEM_CODE FROM PR_ORDER_SELL_CODE_MAPPING SC "
			+ " LEFT JOIN ITEM_LOOKUP IL ON SC.SELL_CODE = IL.SELL_CODE " + " WHERE IL.SELL_CODE IS NOT NULL "
			+ " AND ITEM_CODE IN (SELECT CHILD_PRODUCT_ID FROM (SELECT * FROM PRODUCT_GROUP_RELATION PGR "
			+ " %QUERY_CONDITION%) WHERE CHILD_PRODUCT_LEVEL_ID = 1) " + " AND SC.ORDER_CODE IN " + " ( "
			+ " SELECT ORDER_CODE FROM " + " ( "
			+ " SELECT ORDER_CODE, SELL_CODE, RANK() OVER (PARTITION BY ORDER_CODE ORDER BY SAFE_TO_NUMBER(SELL_CODE)) RANK FROM "
			+ " PR_ORDER_SELL_CODE_MAPPING " + " WHERE ORDER_CODE IN " + " ( "
			+ " SELECT DISTINCT ORDER_CODE FROM PR_ORDER_SELL_CODE_MAPPING SC "
			+ " LEFT JOIN ITEM_LOOKUP IL ON SC.SELL_CODE = IL.SELL_CODE " + " WHERE  IL.SELL_CODE IS NOT NULL   "
			+ " AND ITEM_CODE IN (SELECT CHILD_PRODUCT_ID FROM (SELECT * FROM PRODUCT_GROUP_RELATION PGR "
			+ " %QUERY_CONDITION%) WHERE CHILD_PRODUCT_LEVEL_ID = 1)) "
			+ " ) ORDER_CODES JOIN ITEM_LOOKUP IL ON ORDER_CODES.SELL_CODE = IL.SELL_CODE " + " WHERE RANK  = 1 "
			+ " AND IL.ITEM_CODE IN (SELECT CHILD_PRODUCT_ID FROM (SELECT * FROM PRODUCT_GROUP_RELATION PGR "
			+ " %QUERY_CONDITION%) WHERE CHILD_PRODUCT_LEVEL_ID = 1) " + ")";

	private static final String GET_RECOMMENDATION_RUN_HEADER = "SELECT RUN_ID, LOCATION_LEVEL_ID, LOCATION_ID, PRODUCT_LEVEL_ID, "
			+ "PRODUCT_ID, PRH.CALENDAR_ID, CUR_RETAIL_CALENDAR_ID, TO_CHAR(START_RUN_TIME, 'MM/DD/YYYY') AS START_RUN_TIME, "
			+ "TO_CHAR(RC.START_DATE, 'MM/DD/YYYY') AS START_DATE, TO_CHAR(RC.END_DATE, 'MM/DD/YYYY') AS END_DATE FROM PR_RECOMMENDATION_RUN_HEADER PRH, RETAIL_CALENDAR RC "
			+ "WHERE RC.CALENDAR_ID = PRH.CALENDAR_ID AND RUN_ID = ?";

	private static final String GET_ALL_RECOMMENDATION_DATA = "SELECT RUN_ID, CHILD_LOCATION_LEVEL_ID, CHILD_LOCATION_ID, ITEM_CODE, "
			+ " AVG_MOVEMENT FROM PR_RECOMMENDATION WHERE LIR_IND = 'N' AND RUN_ID IN ( " + " %QUERY_CONDITION% )";

	private static final String GET_STATE_OF_STORES = " SELECT CS.COMP_STR_ID, SL.ID AS STATE_ID FROM COMPETITOR_STORE CS "
			+ " LEFT JOIN STATE_LOOKUP SL ON CS.STATE = SL.STATE_ID " + " WHERE PRICE_ZONE_ID = ? ";

	private static final String GET_COMP_PRICE_DATA = "SELECT ITEM_PRICES.ITEM_CODE, IL.RETAILER_ITEM_CODE, "
			+ "   RET_LIR_ID, " + "   TO_CHAR(START_DATE,'MM/DD/YYYY') AS START_DATE, "
			+ "   REG_PRICE, REG_M_PRICE, REG_M_PACK," + "   SALE_M_PACK, SALE_PRICE, SALE_M_PRICE, "
			+ "   TO_CHAR(EFF_REG_START_DATE,'MM/DD/YYYY') AS EFF_REG_START_DATE, "
			+ "   TO_CHAR(CHECK_DATETIME, 'MM/DD/YYYY')    AS CHECK_DATETIME " + " FROM " +
			// " (SELECT CD.ITEM_CODE, UNITPRICE(CD.REG_PRICE, CD.REG_M_PRICE,
			// CD.REG_M_PACK) AS REG_UNIT_PRICE, " +
			"   (SELECT CD.ITEM_CODE, " + "   S.START_DATE, " + "   S.END_DATE, " +
			// " UNITPRICE( CD.REG_PRICE,CD.REG_M_PRICE, CD.REG_M_PACK ) REG_PRICE,
			// CD.EFF_REG_START_DATE, CD.CHECK_DATETIME, " +
			"   CD.REG_PRICE,CD.REG_M_PRICE, CD.REG_M_PACK, CD.EFF_REG_START_DATE, CD.CHECK_DATETIME, "
			+ "   CD.SALE_M_PACK, CD.SALE_PRICE, CD.SALE_M_PRICE, " +
			// " ROW_NUMBER() OVER (PARTITION BY ITEM_CODE ORDER BY CHECK_DATETIME DESC)
			// ROW_NUMBER" +
			"   RANK() OVER (PARTITION BY ITEM_CODE ORDER BY CHECK_DATETIME DESC) RANK" +
			// " FROM SYNONYM_COMPETITIVE_DATA CD " +
			"   FROM SYN_COMPETITIVE_DATA CD " + "   LEFT JOIN SCHEDULE S " + "   ON CD.SCHEDULE_ID   = S.SCHEDULE_ID "
			+ "   WHERE " + "%COMP_CONDITION%" +
			// " S.COMP_STR_ID = ? " +
			"   AND START_DATE     <= TO_DATE(?,'MM/DD/YYYY') "
			+ "   AND START_DATE     >= TO_DATE(?,'MM/DD/YYYY') - ? " + "   AND CD.ITEM_CODE IN ( "
			+ "   SELECT CHILD_PRODUCT_ID " + "   FROM " + "     (SELECT CHILD_PRODUCT_ID, CHILD_PRODUCT_LEVEL_ID "
			+ "     FROM product_group_relation_rec pgr " + "      %QUERY_CONDITION% " + "     ) "
			+ "   WHERE child_product_level_id = 1 " + "   ) " + "   )ITEM_PRICES " + " LEFT JOIN ITEM_LOOKUP IL "
			+ " ON ITEM_PRICES.ITEM_CODE = IL.ITEM_CODE " +
			// " WHERE ROW_NUMBER = 1";
			" WHERE RANK = ?";

	private static final String GET_STORE_REC_COUNT = " SELECT PR.RUN_ID, COUNT(PRS.PR_RECOMMENDATION_ID) AS STORE_REC_CNT "
			+ " FROM PR_RECOMMENDATION_STORE PRS LEFT JOIN PR_RECOMMENDATION PR ON PRS.PR_RECOMMENDATION_ID = PR.PR_RECOMMENDATION_ID "
			+ " WHERE RUN_ID IN (%RUN_IDS%) GROUP BY PR.RUN_ID ";

//	private static final String GET_PI_STRATEGY = " SELECT  PR.RUN_ID, PRD.STRATEGY_ID, PRPI.MIN_VALUE AS PI_MIN_VALUE, " 
//			+ " PRPI.MAX_VALUE AS PI_MAX_VALUE, "
//			+ " PRPI.IS_ITEM_LEVEL AS PI_IS_ITEM_LEVEL "
//			+ " FROM PR_RECOMMENDATION_RUN_HEADER PR LEFT JOIN PR_DASHBOARD PRD ON PR.LOCATION_LEVEL_ID = PRD.LOCATION_LEVEL_ID AND "
//			+ " PR.LOCATION_ID = PRD.LOCATION_ID AND PR.PRODUCT_LEVEL_ID = PRD.PRODUCT_LEVEL_ID AND "
//			+ " PR.PRODUCT_ID = PRD.PRODUCT_ID "
//			+ " LEFT JOIN PR_STRATEGY PRS ON PRS.STRATEGY_ID = PRD.STRATEGY_ID "
//			+ " LEFT JOIN PR_GUIDELINE PRG ON PRS.STRATEGY_ID = PRG.STRATEGY_ID AND PRG.GUIDELINE_TYPE_ID= ? "
//			+ " LEFT JOIN PR_GUIDELINE_PI PRPI ON PRG.GUIDELINE_ID = PRPI.GUIDELINE_ID "
//			+ " WHERE PR.RUN_ID IN (%RUN_IDS%)";

	private static final String GET_CATEGORY_LEVEL_STRATEGY = " SELECT  PR.RUN_ID, PRD.STRATEGY_ID "
			+ " FROM PR_RECOMMENDATION_RUN_HEADER PR LEFT JOIN PR_DASHBOARD PRD ON PR.LOCATION_LEVEL_ID = PRD.LOCATION_LEVEL_ID AND "
			+ " PR.LOCATION_ID = PRD.LOCATION_ID AND PR.PRODUCT_LEVEL_ID = PRD.PRODUCT_LEVEL_ID AND "
			+ " PR.PRODUCT_ID = PRD.PRODUCT_ID " + " LEFT JOIN PR_STRATEGY PRS ON PRS.STRATEGY_ID = PRD.STRATEGY_ID "
			+ " WHERE PR.RUN_ID IN (%RUN_IDS%)";

	private static final String GET_REC_ITEMS_OF_RUNS = "SELECT PRR.RUN_ID, PRR.PR_RECOMMENDATION_ID, PRR.ITEM_CODE, "
			+ " CASE PRR.LIR_IND WHEN 'Y' THEN null ELSE IL.RET_LIR_ID END AS RET_LIR_ID, PRR.LIR_IND, "
			+ " PRR.CUR_REG_MULTIPLE, PRR.CUR_REG_PRICE, PRR.CUR_LIST_COST, PRR.CUR_VIP_COST,"
			+ " PRR.STRATEGY_ID, PRR.PRICE_CHECK_LIST_ID, PRR.RECOMMENDED_REG_MULTIPLE, PRR.RECOMMENDED_REG_PRICE, "
			+ " PRR.OVERRIDE_REG_PRICE, PRR.COST_CHG_IND, "
			+ " PRR.CUR_COMP_REG_MULTIPLE, PRR.CUR_COMP_REG_PRICE, PRR.IS_CONFLICT, PRR.LOG, "
			+ " PRR.PREDICTION_STATUS, PRR.PREDICTED_MOVEMENT, PRR.IS_REC_PRICE_ADJUSTED, PRR.REC_PRICE_BEFORE_ADJUST, "
			+ " PRR.OPPORTUNITY_PRICE, PRR.OPPORTUNITY_QUANTITY, PRR.IS_OPPORTUNITY, PRR.AVG_MOVEMENT,"
			+ " PRR.IS_PRE_PRICED, PRR.IS_SUBSTITUTE, PRR.IS_LOCKED_PRICE, "
			+ " PRS.LOCATION_LEVEL_ID AS STRATEGY_LOCATION_LEVEL_ID, PRS.LOCATION_ID AS STRATEGY_LOCATION_ID, "
			+ " PRS.PRODUCT_LEVEL_ID AS STRATEGY_PRODUCT_LEVEL_ID, PRS.PRODUCT_ID AS STRATEGY_PRODUCT_ID, "
			+ " PRS.APPLY_TO AS STRATEGY_APPLY_TO, PRS.VENDOR_ID AS STRATEGY_VENDOR_ID, PRS.STATE_ID AS STRATEGY_STATE_ID, "
			+ " REC_REG_PRED_REASONS, REC_SALE_PRED_REASONS, PRR.OVERRIDE_REG_PRICE, PRR.OVERRIDE_REG_MULTIPLE,IL.UPC,  "
			+ " PRR.REC_WEEK_SALE_MULTIPLE, PRR.REC_WEEK_SALE_PRICE, PRR.REC_WEEK_PROMO_TYPE_ID, PRR.REC_WEEK_SALE_START_DATE,"
			+ " PRR.REC_WEEK_SALE_END_DATE, PRR.REC_WEEK_SALE_COST, PRR.REC_WEEK_AD_PAGE_NO, PRR.REC_WEEK_AD_BLOCK_NO, "
			+ " PRR.REC_WEEK_DISPLAY_TYPE_ID, PRR.IS_SALE, PRR.IS_AD, PRR.IS_USER_OVERRIDE,PRR.COMP_STR_ID, PRR.PRED_MOV_WO_SUBS_EFFECT, "
			+ " PRR.CUR_REG_PRICE_PREDICTED_MOV, PRR.ACTUAL_ZONE_ID, RPZ.ZONE_NUM FROM PR_RECOMMENDATION PRR "
			+ " LEFT JOIN ITEM_LOOKUP IL ON PRR.ITEM_CODE = IL.ITEM_CODE "
			+ " LEFT JOIN PR_RECOMMENDATION_RUN_HEADER PRH ON PRR.RUN_ID = PRH.RUN_ID "
			+ " LEFT JOIN PR_STRATEGY PRS ON PRR.STRATEGY_ID = PRS.STRATEGY_ID "
			+ " LEFT JOIN RETAIL_PRICE_ZONE RPZ ON RPZ.PRICE_ZONE_ID = PRR.ACTUAL_ZONE_ID "
			+ " WHERE PRR.RUN_ID IN(%RUN_IDS%) AND RECOMMENDED_REG_PRICE IS NOT NULL";

	private static final String GET_PRICE_GROUP_ITEMS = " SELECT LIR_ID_OR_ITEM_CODE, LIR_IND FROM PR_PRICE_GROUP_DETAIL "
			+
			// " WHERE LIR_ID_OR_ITEM_CODE IN (%ITEM_CODES%)";
			" WHERE LIR_ID_OR_ITEM_CODE IN (%s)";

	private static final String UPDATE_PRICE_ADJUST = " UPDATE PR_RECOMMENDATION SET "
			+ " RECOMMENDED_REG_PRICE = ?, IS_REC_PRICE_ADJUSTED = ?, REC_PRICE_BEFORE_ADJUST = ?, "
			+ " IS_CONFLICT = ?, LOG = ?, PREDICTION_STATUS = ?, PREDICTED_MOVEMENT = ?, "
			+ " IS_OPPORTUNITY = ?, OPPORTUNITY_QUANTITY = ?, OPPORTUNITY_PRICE = ?,  "
			+ " IS_PRICE_RECOMMENDED = ?, REC_SALES_D = ?, REC_MARGIN_D = ? " + " WHERE PR_RECOMMENDATION_ID = ?";

	private static final String GET_PRICE_ADJUSTED_ITEMS = "SELECT PRR.RUN_ID, PRR.STRATEGY_ID, "
			// + " PRH.CALENDAR_ID, "
			+ " PRR.PR_RECOMMENDATION_ID, PRR.ITEM_CODE, IL.RET_LIR_ID, IL.LIR_IND, "
			+ " PRR.RECOMMENDED_REG_MULTIPLE, PRR.RECOMMENDED_REG_PRICE, PRR.OVERRIDE_REG_PRICE, PRR.REC_PRICE_BEFORE_ADJUST, "
			+ " PRR.IS_CONFLICT, PRR.LOG, PRR.REC_REG_PRED_REASONS, PRR.REC_SALE_PRED_REASONS, "
			// + " PRR.CHILD_LOCATION_LEVEL_ID, PRR.CHILD_LOCATION_ID, "
			+ " PRR.PREDICTION_STATUS, PRR.PREDICTED_MOVEMENT FROM PR_RECOMMENDATION PRR "
			+ " LEFT JOIN ITEM_LOOKUP IL ON PRR.ITEM_CODE = IL.ITEM_CODE "
			+ " LEFT JOIN PR_RECOMMENDATION_RUN_HEADER PRH ON PRR.RUN_ID = PRH.RUN_ID "
			+ " WHERE PRR.RUN_ID IN(%RUN_IDS%) AND PRR.IS_REC_PRICE_ADJUSTED = 1";

	private static final String GET_STORE_COUNT_OF_ZONE = "SELECT PRICE_ZONE_ID, COUNT(COMP_STR_ID) AS NO_OF_STORES FROM COMPETITOR_STORE "
			+ " WHERE PRICE_ZONE_ID IN (%ZONE_IDS%) AND ACTIVE_INDICATOR='Y' AND (STORE_EXCLUSION_FLAG = 'N' OR STORE_EXCLUSION_FLAG IS NULL) GROUP BY PRICE_ZONE_ID ORDER BY COUNT(COMP_STR_ID) DESC";

	private static final String GET_STORE_COUNT_OF_ZONE_GLOBAL = "SELECT PRICE_ZONE_ID, COUNT(COMP_STR_ID) AS NO_OF_STORES FROM COMPETITOR_STORE "
			+ " WHERE PRICE_ZONE_ID_3 IN (%ZONE_IDS%) GROUP BY PRICE_ZONE_ID ORDER BY COUNT(COMP_STR_ID) DESC";

	private static final String GET_PRICE_AND_STRATEGY_ZONES_NO = "SELECT SID.*, RPZ.ZONE_NUM FROM (SELECT DISTINCT(PRICE_ZONE_ID) "
			+ "AS STRATEGY_ZONE_ID FROM (SELECT * FROM ( " + " SELECT PLS.STORE_ID FROM PR_PRODUCT_LOCATION_STORE PLS "
			+ " WHERE PLS.PRODUCT_LOCATION_MAPPING_ID = (SELECT PRODUCT_LOCATION_MAPPING_ID FROM PR_PRODUCT_LOCATION_MAPPING PLM "
			+ " WHERE PLM.PRODUCT_LEVEL_ID = ? AND PLM.PRODUCT_ID = ? AND PLM.LOCATION_LEVEL_ID = ? AND PLM.LOCATION_ID = ?)) PSS "
			+ " LEFT JOIN COMPETITOR_STORE CS ON CS.COMP_STR_ID = PSS.STORE_ID)) SID "
			+ " LEFT JOIN RETAIL_PRICE_ZONE RPZ ON RPZ.PRICE_ZONE_ID =  SID.STRATEGY_ZONE_ID";

	private static final String GET_PRICE_ZONES_NO = "SELECT LOCATION_NO AS ZONE_NUM FROM PR_PRODUCT_LOCATION_MAPPING PLM "
			+ " WHERE PLM.PRODUCT_LEVEL_ID = ? AND PLM.PRODUCT_ID = ? AND PLM.LOCATION_LEVEL_ID = ? AND PLM.LOCATION_ID = ?";

	private static final String GET_STORES_OF_PRICE_ZONE = "SELECT PLS.STORE_ID FROM PR_PRODUCT_LOCATION_STORE PLS "
			+ " WHERE PLS.PRODUCT_LOCATION_MAPPING_ID = (SELECT PRODUCT_LOCATION_MAPPING_ID FROM PR_PRODUCT_LOCATION_MAPPING PLM "
			+ " WHERE PLM.PRODUCT_LEVEL_ID = ? AND PLM.PRODUCT_ID = ? AND PLM.LOCATION_LEVEL_ID = ? AND PLM.LOCATION_ID = ?) ";

	private static final String GET_IS_PRICE_ZONE = "SELECT PRODUCT_LOCATION_MAPPING_ID FROM PR_PRODUCT_LOCATION_MAPPING PLM "
			+ " WHERE PLM.PRODUCT_LEVEL_ID = ? AND PLM.PRODUCT_ID = ? AND PLM.LOCATION_LEVEL_ID = ? AND PLM.LOCATION_ID = ? ";

//	private static final String GET_LATEST_RUN_ID = " SELECT MAX(RUN_ID) AS RUN_ID FROM PR_RECOMMENDATION_RUN_HEADER " + " WHERE RUN_TYPE <> '"
//			+ PRConstants.RUN_TYPE_TEMP + "' AND LOCATION_LEVEL_ID = ? AND LOCATION_ID = ? " + " AND PRODUCT_LEVEL_ID = ? AND PRODUCT_ID = ?";

	private static final String GET_LATEST_RUN_ID = "SELECT RUN_ID FROM (SELECT RUN_ID, RANK() OVER (PARTITION BY PRODUCT_ID "
			+ " ORDER BY END_RUN_TIME DESC) AS RANK FROM PR_RECOMMENDATION_RUN_HEADER WHERE LOCATION_LEVEL_ID = ? AND LOCATION_ID = ? "
			+ " AND PRODUCT_LEVEL_ID=? AND PRODUCT_ID = ? AND RUN_TYPE <> '" + PRConstants.RUN_TYPE_TEMP
			+ "' AND END_RUN_TIME IS NOT NULL) WHERE RANK=1";

	private static final String GET_LATEST_RUN_ID_FOR_WEEK = "SELECT RUN_ID FROM (SELECT RUN_ID, RANK() OVER (PARTITION BY PRODUCT_ID "
			+ " ORDER BY RUN_ID DESC) AS RANK FROM PR_QUARTER_REC_HEADER WHERE START_CALENDAR_ID = ? AND"
			+ " LOCATION_LEVEL_ID = ? AND LOCATION_ID = ? "
			+ " AND PRODUCT_LEVEL_ID=? AND PRODUCT_ID = ? AND RUN_TYPE <> '" + PRConstants.RUN_TYPE_TEMP
			+ "') WHERE RANK=1";
	
	private static final String GET_LATEST_RUN_ID_QTR = "SELECT RUN_ID FROM (SELECT RUN_ID, RANK() OVER (PARTITION BY PRODUCT_ID "
			+ " ORDER BY RUN_ID DESC) AS RANK FROM PR_QUARTER_REC_HEADER WHERE "
			+ " LOCATION_LEVEL_ID = ? AND LOCATION_ID = ? "
			+ " AND PRODUCT_LEVEL_ID=? AND PRODUCT_ID = ? AND RUN_TYPE <> '" + PRConstants.RUN_TYPE_TEMP
			+ "') WHERE RANK=1";

	private static final String GET_EXISTING_REG_PRICE_FOR_ZONE = " SELECT PRODUCT_ID, REG_PRICE FROM ( "
			+ " SELECT PRODUCT_ID, CASE WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE > 0) THEN ('1' || '/' || NVL(REG_PRICE,0)) "
			+ " WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE = 0) THEN (REG_M_PACK || '/' || NVL(REG_PRICE,0)) "
			+ " ELSE (REG_M_PACK || '/' || NVL(REG_M_PRICE,0)) END AS REG_PRICE "
			// + " FROM SYNONYM_IMS_WEEKLY IMS "
			+ " FROM SYN_ITEM_METRIC_SUMMARY_WEEKLY IMS "
			+ " WHERE CALENDAR_ID IN (SELECT CALENDAR_ID FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W' AND "
			+ " RC.START_DATE <= TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE >= TO_DATE(?,'MM/DD/YYYY') - ?) "
			+ " AND LOCATION_LEVEL_ID = ? AND LOCATION_ID IN (%PRICE_ZONE_STORES%) AND PRODUCT_LEVEL_ID =  ? AND PRODUCT_ID IN "
			+ "(%s)) GROUP BY PRODUCT_ID, REG_PRICE";

	private static final String GET_LAST_X_MONTHS_MOV_FOR_ZONE = " SELECT PRODUCT_ID, SUM(TOT_MOVEMENT) AS TOT_MOVEMENT "
			// + " FROM SYNONYM_IMS_WEEKLY IMS "
			+ " FROM %TABLE_NAME% IMS "
			+ " WHERE CALENDAR_ID IN (SELECT CALENDAR_ID FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W' AND "
			+ " RC.START_DATE <= TO_DATE(?,'MM/DD/YYYY') AND RC.START_DATE >= TO_DATE(?,'MM/DD/YYYY') - ?) "
			+ " AND LOCATION_LEVEL_ID = ? AND LOCATION_ID IN (%LOCATION_IDS%) AND PRODUCT_LEVEL_ID =  ? AND PRODUCT_ID IN "
			+ "(%s) GROUP BY PRODUCT_ID";

	private static final String GET_RECOMMENDATIONS_ITEMS_OF_RUNS = "SELECT PRR.RUN_ID, PRR.PR_RECOMMENDATION_ID, PRR.ITEM_CODE, "
			+ " CASE PRR.LIR_IND WHEN 'Y' THEN null ELSE IL.RET_LIR_ID END AS RET_LIR_ID, PRR.LIR_IND, "
			+ " PRR.CUR_REG_MULTIPLE, PRR.CUR_REG_PRICE, PRR.CUR_LIST_COST, PRR.CUR_VIP_COST,"
			+ " PRR.STRATEGY_ID, PRR.PRICE_CHECK_LIST_ID, PRR.RECOMMENDED_REG_MULTIPLE, PRR.RECOMMENDED_REG_PRICE, "
			+ " PRR.OVERRIDE_REG_PRICE, PRR.COST_CHG_IND, PRR.REC_REG_PRED_REASONS, PRR.REC_SALE_PRED_REASONS  , "
			+ " PRR.CUR_COMP_REG_MULTIPLE, PRR.CUR_COMP_REG_PRICE, PRR.IS_CONFLICT, PRR.LOG, "
			+ " PRR.PREDICTION_STATUS, PRR.PREDICTED_MOVEMENT, PRR.IS_REC_PRICE_ADJUSTED, PRR.REC_PRICE_BEFORE_ADJUST, "
			+ " PRR.OPPORTUNITY_PRICE, PRR.OPPORTUNITY_QUANTITY, PRR.IS_OPPORTUNITY, PRR.AVG_MOVEMENT,"
			+ " PRR.IS_PRE_PRICED, PRR.IS_SUBSTITUTE, PRR.IS_LOCKED_PRICE, "
			+ " PRS.LOCATION_LEVEL_ID AS STRATEGY_LOCATION_LEVEL_ID, PRS.LOCATION_ID AS STRATEGY_LOCATION_ID, "
			+ " PRS.PRODUCT_LEVEL_ID AS STRATEGY_PRODUCT_LEVEL_ID, PRS.PRODUCT_ID AS STRATEGY_PRODUCT_ID, "
			+ " PRS.APPLY_TO AS STRATEGY_APPLY_TO, PRS.VENDOR_ID AS STRATEGY_VENDOR_ID, PRS.STATE_ID AS STRATEGY_STATE_ID "
			+ " FROM PR_RECOMMENDATION PRR " + " LEFT JOIN ITEM_LOOKUP IL ON PRR.ITEM_CODE = IL.ITEM_CODE "
			+ " LEFT JOIN PR_RECOMMENDATION_RUN_HEADER PRH ON PRR.RUN_ID = PRH.RUN_ID "
			+ " LEFT JOIN PR_STRATEGY PRS ON PRR.STRATEGY_ID = PRS.STRATEGY_ID " + " WHERE PRR.RUN_ID IN(%RUN_IDS%) ";
//			+ " AND PRR.ITEM_CODE IN (151216,24254)";

	private static final String GET_SALE_PRICE = "SELECT BUY_ITEM.ITEM_CODE, BUY_ITEM.SALE_QTY, BUY_ITEM.SALE_PRICE, BUY_ITEM.SALE_M_PRICE, "
			+ " TO_CHAR(RC1.START_DATE,'MM/dd/yyyy') AS PROMO_ACTUAL_START_DATE, TO_CHAR(RC2.START_DATE,'MM/dd/yyyy') AS PROMO_ACTUAL_END_DATE,"
			+ " TO_CHAR(RC3.START_DATE,'MM/dd/yyyy') AS PROMO_WEEK_START_DATE, PM.PROMO_TYPE_ID,PM.PROMO_PRIORITY, PBR.CONSTRAINT, "
			+ " PBR.MIN_QTY_REQUIRED, POD.OFFER_UNIT_TYPE, POD.OFFER_VALUE,"
			+ " PM.ACTUAL_PROMO_START_DATE , PM.ACTUAL_PROMO_END_DATE,PBR.MUSTBUY_QTY,PBR.MUSTBUY_AMT "
			+ " FROM (SELECT PROMO_DEFINITION_ID, ITEM_CODE, SALE_QTY, SALE_PRICE, SALE_M_PRICE, START_CALENDAR_ID, END_CALENDAR_ID "
			+ " FROM PM_PROMO_BUY_ITEM WHERE PROMO_DEFINITION_ID IN (SELECT PD.PROMO_DEFINITION_ID FROM PM_PROMO_DEFINITION PD "
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC1 ON RC1.CALENDAR_ID = PD.START_CALENDAR_ID"
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC2 ON RC2.CALENDAR_ID = PD.END_CALENDAR_ID"
			+ " WHERE RC1.START_DATE >= TO_DATE(?,'MM/dd/yyyy') AND RC2.START_DATE <= TO_DATE(?,'MM/dd/yyyy') + (?-1)"
			// 14th Oct 2016, as super coupon is also loaded, which needs to handled
			// differently, so
			// temporarily only simple and bogo are taken
			// Added to take promoIds from propertyFile
			+ " AND PD.PROMO_TYPE_ID IN (%PROMO_ID%))"
			/*
			 * + PromoTypeLookup.BOGO.getPromoTypeId() + "," +
			 * PromoTypeLookup.STANDARD.getPromoTypeId() // 7th Feb 2018, GE:fetch reward
			 * promotions also + "," + PromoTypeLookup.REWARD_PROMO.getPromoTypeId() + "," +
			 * PromoTypeLookup.BMSM.getPromoTypeId() + "," +
			 * PromoTypeLookup.MUST_BUY.getPromoTypeId() + "))"
			 */
			+ " AND ITEM_CODE IN (%ITEMS_IN_CATEGORY%) "
			// + " AND ITEM_CODE IN (51220) "
			// + " AND ITEM_CODE IN (SELECT ITEM_CODE FROM ITEM_LOOKUP WHERE RET_LIR_ID =
			// 27313) "
			+ " AND PROMO_DEFINITION_ID IN (" + " SELECT DISTINCT(PROMO_DEFINITION_ID) FROM PM_PROMO_LOCATION PL"
			+ " WHERE PL.PROMO_DEFINITION_ID IN (SELECT DISTINCT(PROMO_DEFINITION_ID) FROM PM_PROMO_DEFINITION PD "
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC1 ON RC1.CALENDAR_ID = PD.START_CALENDAR_ID"
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC2 ON RC2.CALENDAR_ID = PD.END_CALENDAR_ID"
			+ " WHERE RC1.START_DATE >= TO_DATE(?,'MM/dd/yyyy') AND RC2.START_DATE <= TO_DATE(?,'MM/dd/yyyy') + (?-1)) AND"
			+ " (%PROMO_LOCATIONS%))) BUY_ITEM"
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC1 ON RC1.CALENDAR_ID = BUY_ITEM.START_CALENDAR_ID"
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC2 ON RC2.CALENDAR_ID = BUY_ITEM.END_CALENDAR_ID"
			+ " LEFT JOIN PM_PROMO_DEFINITION PM  ON PM.PROMO_DEFINITION_ID = BUY_ITEM.PROMO_DEFINITION_ID"
			+ " LEFT JOIN PM_PROMO_BUY_REQUIREMENT PBR ON PM.PROMO_DEFINITION_ID = PBR.PROMO_DEFINITION_ID"
			+ " LEFT JOIN PM_PROMO_OFFER_DETAIL POD ON POD.PROMO_BUY_REQUIREMENT_ID = PBR.PROMO_BUY_REQUIREMENT_ID"
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC3 ON RC3.CALENDAR_ID = PM.START_CALENDAR_ID";

	private static final String GET_AD_DETAILS = " SELECT ITEMS.ITEM_CODE, ITEMS.PAGE_NUMBER, ITEMS.BLOCK_NUMBER, "
			+ " TO_CHAR(RC.START_DATE,'MM/dd/YYYY') AS AD_DATE FROM"
			+ "	(SELECT PBI.PROMO_DEFINITION_ID, PBI.ITEM_CODE,PAGE_NUMBER, BLOCK_NUMBER, WEEKLY_AD_ID FROM PM_WEEKLY_AD_PROMO WAP"
			+ " LEFT JOIN PM_PROMO_BUY_ITEM PBI ON PBI.PROMO_DEFINITION_ID = WAP.PROMO_DEFINITION_ID "
			+ " LEFT JOIN PM_PROMO_DEFINITION PD ON PBI.PROMO_DEFINITION_ID = PD.PROMO_DEFINITION_ID "
			+ " LEFT JOIN PM_WEEKLY_AD_BLOCK WAB ON WAB.BLOCK_ID = WAP.BLOCK_ID "
			+ " LEFT JOIN PM_WEEKLY_AD_PAGE WAP ON WAB.PAGE_ID = WAP.PAGE_ID "
			+ " WHERE PD.PROMO_TYPE_ID IN (%PROMO_ID%)" + " AND WAP.PAGE_ID IN "
			/*
			 * + " WHERE PD.PROMO_TYPE_ID IN (" + PromoTypeLookup.BOGO.getPromoTypeId() +
			 * "," + PromoTypeLookup.STANDARD.getPromoTypeId() // 7th Feb 2018, GE:fetch
			 * reward promotions also + "," + PromoTypeLookup.REWARD_PROMO.getPromoTypeId()
			 * + "," + PromoTypeLookup.BMSM.getPromoTypeId() + "," +
			 * PromoTypeLookup.MUST_BUY.getPromoTypeId() + ")" + " AND WAP.PAGE_ID IN "
			 */
			+ " (SELECT PAGE_ID FROM PM_WEEKLY_AD_PAGE WHERE WEEKLY_AD_ID IN (SELECT WEEKLY_AD_ID FROM PM_WEEKLY_AD_DEFINITION "
			+ " WHERE (%PROMO_LOCATIONS%) AND CALENDAR_ID IN ( "
			+ " SELECT CALENDAR_ID FROM %RETAIL_CALENDAR_TAB_NAME% WHERE ROW_TYPE='W' AND START_DATE >= TO_DATE(?,'MM/dd/yyyy') "
			+ " AND START_DATE <= TO_DATE(?,'MM/dd/yyyy') + (?-1))))" + " AND PD.PROMO_DEFINITION_ID IN ("
			+ " SELECT DISTINCT(PROMO_DEFINITION_ID) FROM PM_PROMO_LOCATION PL"
			+ " WHERE PL.PROMO_DEFINITION_ID IN (SELECT DISTINCT(PROMO_DEFINITION_ID) FROM PM_PROMO_DEFINITION PD "
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC1 ON RC1.CALENDAR_ID = PD.START_CALENDAR_ID"
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC2 ON RC2.CALENDAR_ID = PD.END_CALENDAR_ID"
			+ " WHERE RC1.START_DATE >= TO_DATE(?,'MM/dd/yyyy') AND RC2.START_DATE <= TO_DATE(?,'MM/dd/yyyy') + (?-1)) AND"
			+ " (%PROMO_LOCATIONS%))" + ") ITEMS "
			+ " LEFT JOIN PM_WEEKLY_AD_DEFINITION WAD   ON WAD.WEEKLY_AD_ID = ITEMS.WEEKLY_AD_ID"
			+ " LEFT JOIN %RETAIL_CALENDAR_TAB_NAME% RC ON RC.CALENDAR_ID = WAD.CALENDAR_ID"
			+ "	WHERE ITEM_CODE IN (%ITEMS_IN_CATEGORY%)";
	// + " WHERE ITEM_CODE IN (10832, 10952) ";
	// + " WHERE ITEM_CODE IN (SELECT ITEM_CODE FROM ITEM_LOOKUP WHERE RET_LIR_ID =
	// 27313) ";//

	private static final String GET_DISPLAY_DETAILS = " SELECT PBI.ITEM_CODE, DISPLAY.DISPLAY_TYPE_ID, "
			+ " TO_CHAR(RC.START_DATE, 'MM/dd/YYYY') AS WEEK_START_DATE FROM"
			+ " (SELECT PROMO_DEFINITION_ID, DISPLAY_TYPE_ID, WEEK_CALENDAR_ID FROM PM_PROMO_DISPLAY"
			+ " WHERE WEEK_CALENDAR_ID IN (SELECT CALENDAR_ID FROM RETAIL_CALENDAR"
			+ " WHERE ROW_TYPE  ='W' AND START_DATE >= TO_DATE(?,'MM/dd/yyyy') AND START_DATE <= TO_DATE(?,'MM/dd/yyyy') + (?-1))"
			+ " AND (%PROMO_LOCATIONS%)) DISPLAY"
			+ "	LEFT JOIN PM_PROMO_BUY_ITEM PBI ON PBI.PROMO_DEFINITION_ID = DISPLAY.PROMO_DEFINITION_ID"
			+ " LEFT JOIN PM_PROMO_DEFINITION PD ON PBI.PROMO_DEFINITION_ID = PD.PROMO_DEFINITION_ID "
			+ "	LEFT JOIN RETAIL_CALENDAR RC ON RC.CALENDAR_ID = DISPLAY.WEEK_CALENDAR_ID"
			+ "	WHERE PD.PROMO_TYPE_ID IN (%PROMO_ID%) " + " AND PD.PROMO_DEFINITION_ID IN ("
			+ " SELECT DISTINCT(PROMO_DEFINITION_ID) FROM PM_PROMO_LOCATION PL"
			+ " WHERE PL.PROMO_DEFINITION_ID IN (SELECT DISTINCT(PROMO_DEFINITION_ID) FROM PM_PROMO_DEFINITION PD "
			+ " LEFT JOIN RETAIL_CALENDAR RC1 ON RC1.CALENDAR_ID = PD.START_CALENDAR_ID"
			+ " LEFT JOIN RETAIL_CALENDAR RC2 ON RC2.CALENDAR_ID = PD.END_CALENDAR_ID"
			+ " WHERE RC1.START_DATE >= TO_DATE(?,'MM/dd/yyyy') AND RC2.START_DATE <= TO_DATE(?,'MM/dd/yyyy') + (?-1)) AND"
			+ " (%PROMO_LOCATIONS%))" + " AND PBI.ITEM_CODE IN (%ITEMS_IN_CATEGORY%)";
	// + " AND PBI.ITEM_CODE IN (10832, 10952)";

	private static final String GET_REC_RULES = "SELECT RR.RULE_CODE, RRM.OBJECTIVE_TYPE_ID, RRM.ENABLED FROM PR_RECOMMENDATION_RULE_MAP RRM "
			+ " LEFT JOIN PR_RECOMMENDATION_RULE RR ON RRM.RULE_ID = RR.RULE_ID";

	private static final String GET_LEAD_DEPENDENT_ZONE = "SELECT DEPENDENT_ZONE_ID, USE_STRATEGY_OF_LEAD_ZONE FROM PR_LEAD_DEPENDENT_STRATEGY_MAP"
			+ " WHERE DEPENDENT_ZONE_ID = ?";

	private static final String UPDATE_RE_RECOMMENDATION_DETAILS = "UPDATE PR_RECOMMENDATION SET OVERRIDE_REG_MULTIPLE = ?, "
			+ " OVERRIDE_REG_PRICE = ?, OVERRIDE_SALES_D =?, OVERRIDE_MARGIN_D = ?, OVERRIDE_PRICE_PREDICTED_MOV = ?, IS_SYSTEM_OVERRIDE = ?, "
			// + " IS_PRICE_RECOMMENDED= ?, "
			+ " REC_WEEK_SALE_PRED_AT_REC_REG = ?, OVERRIDE_PRED_UPDATE_STATUS=?, PREDICTION_STATUS = ?, "
			+ " REC_WEEK_SALE_PRED_STATUS_REC = ?, IS_USER_OVERRIDE = ?, SYS_OVERRIDE_LOG = ? WHERE RUN_ID = ? AND ITEM_CODE = ? and LIR_IND= ? ";

	private static final String UPDATE_SUBS_PRED_MOV_FOR_RE_RECOMMENDATION_ITEMS = "UPDATE PR_RECOMMENDATION SET PRED_MOV_WO_SUBS_EFFECT = ? "
			+ "WHERE RUN_ID = ? AND ITEM_CODE = ? AND LIR_IND=?";
	private static final String UPDATE_OVERRIDE_PRED_STATUS_IN_RUN_HEADER = "UPDATE PR_RECOMMENDATION_RUN_HEADER SET OVERRIDE_PRED_UPDATE_STATUS = ? WHERE RUN_ID = ?";

	private static final String UPDATE_OVERRIDE_PRED_STATUS_IN_RUN_HEADER_QR = "UPDATE PR_QUARTER_REC_HEADER SET OVERRIDE_PRED_UPDATE_STATUS = ? WHERE RUN_ID = ?";

	private static final String GET_ORDER_SELL_CODE_V2 = "SELECT FRH.FRESH_RELATION_HEADER_ID,FRO.FRESH_RELATION_ORDER_ID, FRO.ORDER_ITEM_CODE,"
			+ " FRS.FRESH_RELATION_SELL_ID,"
			+ " FRS.SELL_ITEM_CODE, FRS.SELL_UPC, FRS.YIELD FROM PR_FRESH_RELATION_HEADER FRH"
			+ " LEFT JOIN PR_FRESH_RELATION_ORDER FRO ON FRH.FRESH_RELATION_HEADER_ID = FRO.FRESH_RELATION_HEADER_ID"
			+ " LEFT JOIN PR_FRESH_RELATION_SELL FRS ON FRH.FRESH_RELATION_HEADER_ID = FRS.FRESH_RELATION_HEADER_ID"
			+ " WHERE FRH.FRESH_RELATION_HEADER_ID= (SELECT FRESH_RELATION_HEADER_ID FROM ("
			+ " SELECT FRESH_RELATION_HEADER_ID, START_DATE, END_DATE,START_DATE_RANK,"
			+ " RANK() OVER (PARTITION BY START_DATE_RANK ORDER BY FRESH_RELATION_HEADER_ID DESC) HEADER_ID_RANK FROM ("
			+ " SELECT FRESH_RELATION_HEADER_ID, START_DATE, END_DATE,DAYS,DAYS_RANK, RANK() OVER"
			+ " (PARTITION BY DAYS_RANK ORDER BY START_DATE DESC) START_DATE_RANK FROM ("
			+ " SELECT FRESH_RELATION_HEADER_ID, START_DATE, END_DATE,DAYS, RANK() OVER (ORDER BY DAYS ASC) AS DAYS_RANK FROM ("
			+ " SELECT FRESH_RELATION_HEADER_ID,START_DATE, END_DATE,"
			+ " CASE WHEN END_DATE IS NOT NULL AND START_DATE IS NOT NULL THEN TO_CHAR(END_DATE - START_DATE)"
			+ " ELSE CASE WHEN START_DATE IS NOT NULL THEN TO_CHAR (TO_DATE(?,'MM/dd/yyyy') - TO_DATE(START_DATE,'MM/dd/yyyy'))"
			+ " ELSE NULL END END AS DAYS FROM ("
			+ " SELECT FRESH_RELATION_HEADER_ID, SRC.START_DATE AS START_DATE, ERC.START_DATE AS END_DATE"
			+ " FROM PR_FRESH_RELATION_HEADER FRH LEFT JOIN RETAIL_CALENDAR SRC ON FRH.RELATION_START_CALENDAR_ID = SRC.CALENDAR_ID"
			+ " LEFT JOIN RETAIL_CALENDAR ERC ON FRH.RELATION_END_CALENDAR_ID = ERC.CALENDAR_ID "
			+ " WHERE FRH.FRESH_RELATION_PRODUCT_ID = (SELECT FRESH_RELATION_PRODUCT_ID FROM ("
			+ " SELECT FRESH_RELATION_PRODUCT_ID,LOCATION_ID, LOCATION_LEVEL_ID,"
			+ " RANK() OVER(PARTITION BY LOCATION_LEVEL_ID,LOCATION_ID ORDER BY FRESH_RELATION_PRODUCT_ID DESC) AS RECENT_RELATION_ID,"
			+ " RANK() OVER(ORDER BY LOCATION_HIERRACHY asc) as LOCATION_HIERRACHY_RANK,LOCATION_HIERRACHY FROM ("
			+ " SELECT FRESH_RELATION_PRODUCT_ID, LOCATION_ID, LOCATION_LEVEL_ID,"
			+ " CASE WHEN LOCATION_LEVEL_ID = ? THEN 1 ELSE CASE WHEN LOCATION_LEVEL_ID = ? THEN 2 ELSE CASE"
			+ "	WHEN LOCATION_LEVEL_ID = ? THEN 3 ELSE NULL END END END AS LOCATION_HIERRACHY FROM PR_FRESH_RELATION_PRODUCT"
			+ " WHERE PRODUCT_ID = ? AND PRODUCT_LEVEL_ID=? AND (LOCATION_ID = ?"
			+ " OR LOCATION_ID IN (SELECT DISTINCT DIVISION_ID FROM COMPETITOR_STORE WHERE PRICE_ZONE_ID=?)"
			+ " OR LOCATION_ID = (SELECT COMP_CHAIN_ID FROM COMPETITOR_CHAIN WHERE PRESTO_SUBSCRIBER = 'Y'))))"
			+ " WHERE  RECENT_RELATION_ID=1 AND LOCATION_HIERRACHY_RANK =1))"
			+ "	WHERE ((Select TRUNC(START_DATE+1, 'IW')-1 FROM_DATE From dual) <= TO_DATE(?,'MM/dd/yyyy')"
			+ " OR START_DATE IS NULL) AND"
			+ " ((Select TRUNC(END_DATE+1, 'IW')+5 FROM_DATE From dual) >= TO_DATE(?,'MM/dd/yyyy') OR END_DATE IS NULL)))"
			+ "	 WHERE DAYS_RANK=1) WHERE START_DATE_RANK=1) WHERE HEADER_ID_RANK=1)";

	private static final String GET_COMP_PRICE_DATA_FOR_ITEMS = "SELECT ITEM_PRICES.ITEM_CODE, IL.RETAILER_ITEM_CODE, "
			+ "   RET_LIR_ID, " + "   TO_CHAR(START_DATE,'MM/DD/YYYY') AS START_DATE, "
			+ "   REG_PRICE, REG_M_PRICE, REG_M_PACK," + "   SALE_M_PACK, SALE_PRICE, SALE_M_PRICE, "
			+ "   TO_CHAR(EFF_REG_START_DATE,'MM/DD/YYYY') AS EFF_REG_START_DATE, "
			+ "   TO_CHAR(CHECK_DATETIME, 'MM/DD/YYYY')    AS CHECK_DATETIME " + " FROM " + "   (SELECT CD.ITEM_CODE, "
			+ "   S.START_DATE, " + "   S.END_DATE, "
			+ "   CD.REG_PRICE,CD.REG_M_PRICE, CD.REG_M_PACK, CD.EFF_REG_START_DATE, CD.CHECK_DATETIME, "
			+ "   CD.SALE_M_PACK, CD.SALE_PRICE, CD.SALE_M_PRICE, "
			+ "   RANK() OVER (PARTITION BY ITEM_CODE ORDER BY CHECK_DATETIME DESC) RANK"
			+ "   FROM SYN_COMPETITIVE_DATA CD " + "   LEFT JOIN SCHEDULE S "
			+ "   ON CD.SCHEDULE_ID   = S.SCHEDULE_ID " + "   WHERE " + "   CD.ITEM_CODE IN (%s) "
			+ " 	AND S.COMP_STR_ID = ? " + "   AND START_DATE     <= TO_DATE(?,'MM/DD/YYYY') "
			+ "   AND START_DATE     >= TO_DATE(?,'MM/DD/YYYY') - ? " + "   )ITEM_PRICES "
			+ " LEFT JOIN ITEM_LOOKUP IL " + " ON ITEM_PRICES.ITEM_CODE = IL.ITEM_CODE " + " WHERE RANK = ?";

	private static final String UPDATE_RERECOMMENDATION_STATUS = "UPDATE PR_RECOMMENDATION_RUN_HEADER SET UPDATE_REC_MESSAGE = ?, "
			+ "UPDATE_REC_PCT_COMPLETION = ?, UPDATE_REC_STATUS = ? WHERE RUN_ID = ?";

	private static final String UPDATE_REC_RUN_STATUS = "UPDATE PR_RECOMMENDATION_RUN_HEADER SET UPDATE_REC_STATUS = ? "
			+ " WHERE RUN_ID = ?";

	private static final String UPDATE_REC_RUN_STATUS_QR = "UPDATE PR_QUARTER_REC_HEADER SET UPDATE_REC_STATUS = ? "
			+ " WHERE RUN_ID = ?";

	private static final String UPDATE_RERECOMMENDATION_STATUS_QR = "UPDATE PR_QUARTER_REC_HEADER SET UPDATE_REC_MESSAGE = ?, "
			+ "UPDATE_REC_PCT_COMPLETION = ?, UPDATE_REC_STATUS = ? WHERE RUN_ID = ?";

	String PRICE_CHECK_LIST_FOR_PRICE_TEST = " SELECT PCL.*, IL.RET_LIR_ID, IL.LIR_IND, PCLTL.PRECEDENCE, MIN_PRICE, MAX_PRICE, LOCKED_RETAIL, END_DATE, PCLTL.CODE AS CHECKLIST_NAME  FROM ("
			+ " SELECT ITEM.PRICE_CHECK_LIST_ID, ITEM.ITEM_CODE, ITEM.MIN_PRICE, ITEM.MAX_PRICE, ITEM.LOCKED_RETAIL, ITEM.END_DATE, "
			+ " PRICE_CHECK_LIST_TYPE_ID, LOCATION_LEVEL_ID, LOCATION_ID, PRICE_CHECK_LIST.CREATE_DATETIME, PRICE_CHECK_LIST.UPDATE_DATETIME FROM( "
			+ " SELECT PRICE_CHECK_LIST_ID, ITEM_CODE, MIN_PRICE, MAX_PRICE, " + " LOCKED_RETAIL, TO_CHAR(END_DATE, '"
			+ Constants.DB_DATE_FORMAT + "') AS END_DATE FROM PRICE_CHECK_LIST_ITEMS   "
			+ " WHERE (PRICE_CHECK_LIST_ID IN   " + " (SELECT ID FROM PRICE_CHECK_LIST WHERE "
			+ " (IS_SYSTEM_LIST IS NULL OR IS_SYSTEM_LIST <> 'Y')" + " AND PRICE_CHECK_LIST_TYPE_ID  in(SELECT price_check_list_type_id FROM PRICE_CHECK_LIST_TYPE_LOOKUP where DISPLAY_NAME LIKE'PRICE TEST')"
			+ " AND (PRICE_CHECK_LIST_TYPE_ID IS NOT NULL AND PRICE_CHECK_LIST_TYPE_ID > 0) AND ACTIVE_STATUS='Y' "
			+ "))   " + " AND ITEM_CODE IN " + " ( " + " SELECT CHILD_PRODUCT_ID AS ITEM_CODE FROM " + " ( "
			+ " SELECT CHILD_PRODUCT_ID,   " + "   CHILD_PRODUCT_LEVEL_ID  " + " FROM PRODUCT_GROUP_RELATION_REC PGR  "
			+ "   START WITH PRODUCT_LEVEL_ID       = ?  " + " AND PRODUCT_ID                      = ?  "
			+ "   CONNECT BY PRIOR CHILD_PRODUCT_ID = PRODUCT_ID  "
			+ " AND PRIOR CHILD_PRODUCT_LEVEL_ID    = PRODUCT_LEVEL_ID " + " ) " + " WHERE CHILD_PRODUCT_LEVEL_ID = 1 "
			+ " )" + " )ITEM LEFT JOIN PRICE_CHECK_LIST ON ITEM.PRICE_CHECK_LIST_ID = PRICE_CHECK_LIST.ID)"
			+ " PCL LEFT JOIN ITEM_LOOKUP IL ON PCL.ITEM_CODE = IL.ITEM_CODE "
			+ " LEFT JOIN PRICE_CHECK_LIST_TYPE_LOOKUP PCLTL ON PCL.PRICE_CHECK_LIST_TYPE_ID = PCLTL.PRICE_CHECK_LIST_TYPE_ID";


	/** PROM-2223 changes started **/
	private static final String GET_LATEST_REG_PRICES = "SELECT PRODUCT_ID,REG_PRICE,MOV_52_WEEK FROM PR_QUARTER_REC_ITEM WHERE RUN_ID IN("
			+"SELECT MAX(RUN_ID) FROM PR_QUARTER_REC_HEADER WHERE PRODUCT_ID=? AND  LOCATION_ID IN("
			+"SELECT PRICE_ZONE_ID FROM RETAIL_PRICE_ZONE WHERE ZONE_TYPE='W' AND GLOBAL_ZONE='N' AND ACTIVE_INDICATOR='Y')" 
			+"AND RUN_STATUS='S' AND RUN_TYPE<>'T' GROUP BY LOCATION_ID) AND CAL_TYPE='Q' AND PRODUCT_LEVEL_ID=1 ORDER BY PRODUCT_ID";
	/** PROM-2223 changes started **/
	
	private static final String GET_QUEUED_RECCS = "SELECT PR.PRODUCT_ID,PR.REC_REG_PRICE,PR.PRC_CHANGE_IMPACT,PR.REC_REG_MULTIPLE,PR.OVERRIDE_REG_PRICE,PR.OVERRIDE_REG_MULTIPLE FROM PR_QUARTER_REC_ITEM PR"
			+ " JOIN PR_PRICE_EXPORT PE ON PE.RUN_ID=PR.RUN_ID AND PE.ITEM_CODE=PR.PRODUCT_ID JOIN PR_QUARTER_REC_HEADER RH"
			+ " ON RH.RUN_ID= PE.RUN_ID  WHERE  RH.PRODUCT_ID =? AND RH.LOCATION_ID=? AND  PR.CAL_TYPE='Q' ";

	/** PROM-2214 changes started **/
	private static final String GET_STORE_ITEM_COUNT_FOR_GLOBAL_ZONE = "SELECT ITEM_CODE,SUM(STORE_COUNT)AS STORE_COUNT FROM ITEM_STORE_COUNT WHERE ITEM_CODE IN ("
			+ "SELECT ITEM_CODE FROM ITEM_LOOKUP WHERE  ITEM_CODE IN ("
			+ "		SELECT CHILD_PRODUCT_ID FROM (SELECT CHILD_PRODUCT_ID,CHILD_PRODUCT_LEVEL_ID FROM PRODUCT_GROUP_RELATION_REC PGR"
			+ "		START WITH PRODUCT_LEVEL_ID =" + Constants.RECOMMENDATIONUNIT + " AND PRODUCT_ID = ?  "
			+ "	 CONNECT BY  PRIOR CHILD_PRODUCT_ID = PRODUCT_ID  AND  PRIOR CHILD_PRODUCT_LEVEL_ID = PRODUCT_LEVEL_ID"
			+ "		 ) WHERE CHILD_PRODUCT_LEVEL_ID = 1  )) AND ACTIVE_INDICATOR='Y' AND PRICE_ZONE_ID IN(SELECT PRICE_ZONE_ID FROM RETAIL_PRICE_ZONE WHERE ZONE_TYPE='W' AND ACTIVE_INDICATOR='Y' AND PRIMARY_COMP_STR_ID IS NOT NULL) GROUP BY ITEM_CODE";

	private static final String GET_STORE_ITEM_COUNT = "SELECT ITEM_CODE,STORE_COUNT  FROM ITEM_STORE_COUNT WHERE ITEM_CODE IN ("
			+ "SELECT ITEM_CODE FROM ITEM_LOOKUP WHERE  ITEM_CODE IN ("
			+ "		SELECT CHILD_PRODUCT_ID FROM (SELECT CHILD_PRODUCT_ID,CHILD_PRODUCT_LEVEL_ID FROM PRODUCT_GROUP_RELATION_REC PGR"
			+ "		START WITH PRODUCT_LEVEL_ID =" + Constants.RECOMMENDATIONUNIT + " AND PRODUCT_ID = ?  "
			+ "	 CONNECT BY  PRIOR CHILD_PRODUCT_ID = PRODUCT_ID  AND  PRIOR CHILD_PRODUCT_LEVEL_ID = PRODUCT_LEVEL_ID"
			+ "		 ) WHERE CHILD_PRODUCT_LEVEL_ID = 1  )) AND ACTIVE_INDICATOR='Y' AND PRICE_ZONE_ID=? ORDER BY ITEM_CODE";
	/** PROM-2214 changes  End **/
	
	private static final String GET_ITEMS_AND_RUN_ID_FROM_EXPORT_QUEUE = " SELECT  PRH.RUN_ID,PE.ITEM_CODE FROM PR_PRICE_EXPORT PE"
			+ " JOIN PR_QUARTER_REC_HEADER PRH  ON PRH.RUN_ID = PE.RUN_ID AND PRH.LOCATION_LEVEL_ID  = ? "
			+ " AND PRH.LOCATION_ID =?  AND PRH.PRODUCT_LEVEL_ID = ?  AND PRH.PRODUCT_ID= ?";
	
	private static final String GET_LAST_YEARS_MOVEMENT_FROM_IMS = " SELECT  ITEM_CODE, "
			+ " SUM(TOTAL_QUANTITY) MOVEMENT, SUM(TOTAL_REVENUE) REVENUE FROM" + "(SELECT CALENDAR_ID, PRODUCT_ID AS ITEM_CODE, "
			+ " CASE" + " WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE > 0) THEN  ('1' ||  '/' || NVL(REG_PRICE,0))"
			+ " WHEN (NVL(REG_M_PACK,0) <= 1 AND REG_PRICE = 0) THEN  (REG_M_PACK ||  '/' || NVL(REG_PRICE,0))"
			+ " ELSE (REG_M_PACK || '/' || NVL(REG_M_PRICE,0))" + " END AS REG_PRICE ," + " CASE"
			+ " WHEN (NVL(SALE_M_PACK,0) <= 1 AND SALE_PRICE > 0) THEN  ('1' ||  '/' || NVL(SALE_PRICE,0))"
			+ " WHEN (NVL(SALE_M_PACK,0) <= 1 AND SALE_PRICE = 0) THEN  (SALE_M_PACK ||  '/' || NVL(SALE_PRICE,0))"
			+ " ELSE (SALE_M_PACK || '/' || NVL(SALE_M_PRICE,0))" + " END AS SALE_PRICE,"
			+ " TOT_MOVEMENT AS TOTAL_QUANTITY, TOT_REVENUE AS TOTAL_REVENUE, FINAL_PRICE AS FINAL_UNIT_PRICE"
			+ " FROM IMS_WEEKLY_ZONE IMS  " + " WHERE PRODUCT_ID IN  (%s) "
			+ " AND CALENDAR_ID IN (SELECT CALENDAR_ID FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W' AND "
			+ " RC.START_DATE >= TO_DATE(?,'MM/DD/YYYY')-365 AND RC.START_DATE <= TO_DATE(?,'MM/DD/YYYY')-365)"
			+ " AND LOCATION_ID IN (%PRICE_ZONE_ID%)) GROUP BY ITEM_CODE ";
	
	
	String substituteForPrediction = (PropertyManager.getProperty("SUBSTITUE_FOR_PREDICTION", "52_WEEKS_AVG"));
	
	
	private ProductService service = null;

	private List<ExecutionTimeLog> executionTimeLogs;
	private ExecutionTimeLog executionTimeLog = null;

	public PricingEngineDAO(List<ExecutionTimeLog> executionTimeLogs) {
		if (executionTimeLogs == null)
			executionTimeLogs = new ArrayList<ExecutionTimeLog>();
		this.executionTimeLogs = executionTimeLogs;
	}

	public PricingEngineDAO() {
		service = new ProductService();
		this.executionTimeLogs = new ArrayList<ExecutionTimeLog>();
	}

	/**
	 * Returns parent child product level relation map
	 * 
	 * @return
	 */
	public HashMap<Integer, Integer> getParentChildRelationMap() {
		return service.getProductLevelRelationMap();
	}

	/**
	 * Generates a Map that contains product level type id as the key and products
	 * under it as list of items
	 * 
	 * @param itemList
	 * @return
	 */
//	public HashMap<Integer, ArrayList<Integer>> getProductsAtAllProductLevels(ArrayList<PRItemDTO> itemList){
//		HashMap<Integer, Set<Integer>> productsMap = new HashMap<Integer, Set<Integer>>();
//		HashMap<Integer, ArrayList<Integer>> finalProductsMap = new HashMap<Integer, ArrayList<Integer>>();
//		HashMap<Integer, Integer> parentChildRelationMap = service.getProductLevelRelationMap();
//		
//		for(PRItemDTO item : itemList){
//			for(Integer productLevel : parentChildRelationMap.keySet()){
//				if(productLevel == 5)
//					populateProductMap(productLevel, item.getDeptProductId(), productsMap);
//				else if(productLevel == 8)
//					populateProductMap(productLevel, item.getPortfolioProductId(), productsMap);
//				else if(productLevel == 4)
//					populateProductMap(productLevel, item.getCategoryProductId(), productsMap);
//				else if(productLevel == 3)
//					populateProductMap(productLevel, item.getSubCatProductId(), productsMap);
//				else if(productLevel == 2)
//					populateProductMap(productLevel, item.getSegmentProductId(), productsMap);
//				else if(productLevel == 1)
//					populateProductMap(productLevel, item.getItemCode(), productsMap);
//			}
//		}
//		
//		for(Map.Entry<Integer, Set<Integer>> entry : productsMap.entrySet()){
//			ArrayList<Integer> productList = new ArrayList(entry.getValue());
//			finalProductsMap.put(entry.getKey(), productList);
//		}
//		
//		return finalProductsMap;
//	}

	/**
	 * Generates a Map that contains product level type id as the key and products
	 * under it as list of items
	 * 
	 * @param itemList
	 * @return
	 * @throws GeneralException
	 */
//	public HashMap<Integer, List<Integer>> getProductsAtAllProductLevels(Connection conn, PRStrategyDTO inputDTO, 
//			HashMap<ItemKey, PRItemDTO> itemDataMap) throws GeneralException{
//		HashMap<Integer, Set<Integer>> productsMap = new HashMap<Integer, Set<Integer>>();
//		HashMap<Integer, List<Integer>> finalProductsMap = new HashMap<Integer, List<Integer>>();
//		HashMap<Integer, Integer> parentChildRelationMap = service.getProductLevelRelationMap();
//		
//		if(parentChildRelationMap == null || parentChildRelationMap.size() == 0){
//			parentChildRelationMap = service.getProductLevelRelationMap(conn, inputDTO.getProductLevelId());
//		}
//		
//		for(PRItemDTO item : itemDataMap.values()){
//			for(Integer productLevel : parentChildRelationMap.keySet()){
//				if(productLevel == Constants.DEPARTMENTLEVELID)
//					populateProductMap(productLevel, item.getDeptProductId(), productsMap);
//				else if(productLevel == Constants.PORTFOLIO)
//					populateProductMap(productLevel, item.getPortfolioProductId(), productsMap);
//				else if(productLevel == Constants.CATEGORYLEVELID)
//					populateProductMap(productLevel, item.getCategoryProductId(), productsMap);
//				else if(productLevel == Constants.SUBCATEGORYLEVELID)
//					populateProductMap(productLevel, item.getSubCatProductId(), productsMap);
//				else if(productLevel == Constants.SEGMENT_LEVEL_PRODUCT_LEVEL_ID)
//					populateProductMap(productLevel, item.getSegmentProductId(), productsMap);
//				else if(productLevel == Constants.ITEMLEVELID)
//					populateProductMap(productLevel, item.getItemCode(), productsMap);
//			}
//		}
//		
//		for(Map.Entry<Integer, Set<Integer>> entry : productsMap.entrySet()){
//			List<Integer> productList = new ArrayList(entry.getValue());
//			finalProductsMap.put(entry.getKey(), productList);
//		}
//		
//		return finalProductsMap;
//	}
	/**
	 * Populates Map with product level id as key and list of products under it as
	 * its value
	 * 
	 * @param productLevelId
	 * @param productId
	 * @param productsMap
	 */
//	private void populateProductMap(int productLevelId, int productId, HashMap<Integer, Set<Integer>> productsMap){
//		if(productsMap.get(productLevelId) != null){
//			Set<Integer> productList = productsMap.get(productLevelId);
//			productList.add(productId);
//			productsMap.put(productLevelId, productList);
//		}else{
//			Set<Integer> productList = new HashSet<Integer>();
//			productList.add(productId);
//			productsMap.put(productLevelId, productList);
//		}
//	}

	/**
	 * Retrieves base zone price data for the week specified
	 * 
	 * @param conn
	 * @param inputDTO
	 * @param weekCalendarId
	 * @param itemCodeList
	 * @param inputDataMap
	 * @throws GeneralException
	 */
	public void getPriceDataOptimized(Connection connection, Integer chainId, PRStrategyDTO inputDTO,
			RetailCalendarDTO calDTO, RetailCalendarDTO resetCalDTO, int noOfWeeksBehind,
			HashMap<ItemKey, PRItemDTO> inputDataMap, HashMap<Integer, HashMap<ItemKey, PRItemDTO>> itemDataMapStore,
			HashMap<Integer, HashMap<ItemKey, PRItemDTO>> itemDataMapStoreNotInCache, boolean fetchZoneData,
			List<String> priceAndStrategyZoneNos, List<Integer> priceZoneStores) throws GeneralException {

		RetailPriceCostKey chainKey = new RetailPriceCostKey(Constants.CHAIN_LEVEL_TYPE_ID, chainId);
		RetailPriceCostKey zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, inputDTO.getLocationId());

		RetailCalendarDAO calendarDAO = new RetailCalendarDAO();
		RetailPriceServiceOptimized priceService = new RetailPriceServiceOptimized(connection);
		boolean fetchStoreData = false;

		if (itemDataMapStore != null && itemDataMapStore.size() > 0)
			fetchStoreData = true;

		if (fetchZoneData || fetchStoreData) {
			List<RetailCalendarDTO> retailCalendarList = calendarDAO.getCalendarList(connection, calDTO.getCalendarId(),
					noOfWeeksBehind);
			Set<Integer> itemCodeSet = new HashSet<Integer>();
			for (PRItemDTO item : inputDataMap.values()) {
				if (!item.isLir())
					itemCodeSet.add(item.getItemCode());
			}

			logger.debug("Loading current week Price");
			for (RetailCalendarDTO curCalDTO : retailCalendarList) {
//				logger.debug(
//						"Running for calendar id " + curCalDTO.getCalendarId() + " for items " + itemCodeSet.size());
				if (itemCodeSet.size() > 0) {
					HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>> priceDataMap = priceService
							.getRetailPrice(curCalDTO.getCalendarId(), chainId, priceAndStrategyZoneNos,
									priceZoneStores, fetchStoreData, itemCodeSet);
					// Populate price data for zone
					if (fetchZoneData) {
						for (Map.Entry<ItemKey, PRItemDTO> entry : inputDataMap.entrySet()) {
							int itemCode = entry.getKey().getItemCodeOrRetLirId();
							PRItemDTO item = entry.getValue();
							zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
							// logger.debug("Price -- Actual Zone Id: " + item.getPriceZoneId());
							if (priceDataMap.get(itemCode) != null) {
								HashMap<RetailPriceCostKey, RetailPriceDTO> costMap = priceDataMap.get(itemCode);
								RetailPriceDTO priceDTO = priceService.findPriceForZone(costMap, zoneKey, chainKey);
								populateCurrentPrice(item, priceDTO);
								if (itemCodeSet.contains(itemCode))
									itemCodeSet.remove(itemCode);
							}
						}
					}

					// Populate price data for store
					if (fetchStoreData) {
						for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : itemDataMapStoreNotInCache
								.entrySet()) {
							RetailPriceCostKey storeKey = new RetailPriceCostKey(Constants.STORE_LEVEL_TYPE_ID,
									entry.getKey());
							for (Map.Entry<ItemKey, PRItemDTO> inEntry : entry.getValue().entrySet()) {
								int itemCode = inEntry.getKey().getItemCodeOrRetLirId();
								// PRItemDTO item = itemDataMapStore.get(entry.getKey()).get(itemCode);
								PRItemDTO item = itemDataMapStore.get(entry.getKey()).get(inEntry.getKey());
								// Look for store's zone if not present at store level (price and strategy zone
								// changes)
								zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
								if (priceDataMap.get(itemCode) != null) {
									HashMap<RetailPriceCostKey, RetailPriceDTO> costMap = priceDataMap.get(itemCode);
									RetailPriceDTO priceDTO = priceService.findPriceForStore(costMap, storeKey, zoneKey,
											chainKey);
									populateCurrentPrice(item, priceDTO);
									if (itemCodeSet.contains(itemCode))
										itemCodeSet.remove(itemCode);
								}
							}
						}
					}
				}
			}

			if (resetCalDTO != null) {
				retailCalendarList = calendarDAO.getCalendarList(connection, resetCalDTO.getCalendarId(),
						noOfWeeksBehind);
				itemCodeSet = new HashSet<Integer>();
				for (PRItemDTO item : inputDataMap.values()) {
					if (!item.isLir())
						itemCodeSet.add(item.getItemCode());
				}

				logger.debug("Loading previous week Price");
				for (RetailCalendarDTO resCalDTO : retailCalendarList) {
//					logger.debug("Running for calendar id " + resCalDTO.getCalendarId() + " for items "
//							+ itemCodeSet.size());
					if (itemCodeSet.size() > 0) {
						HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>> priceDataMap = priceService
								.getRetailPrice(resCalDTO.getCalendarId(), chainId, priceAndStrategyZoneNos,
										priceZoneStores, fetchStoreData, itemCodeSet);
						itemCodeSet.clear();

						// Populate price data for zone
						if (fetchZoneData)
							for (Map.Entry<ItemKey, PRItemDTO> entry : inputDataMap.entrySet()) {
								int itemCode = entry.getKey().getItemCodeOrRetLirId();
								PRItemDTO item = entry.getValue();
								zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
								if (priceDataMap.get(itemCode) != null) {
									HashMap<RetailPriceCostKey, RetailPriceDTO> priceMap = priceDataMap.get(itemCode);
									RetailPriceDTO priceDTO = priceService.findPriceForZone(priceMap, zoneKey,
											chainKey);
									populatePreviousPrice(item, priceDTO);
									if (itemCodeSet.contains(itemCode))
										itemCodeSet.remove(itemCode);
								}
							}

						// Populate price data for store
						if (fetchStoreData)
							for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : itemDataMapStoreNotInCache
									.entrySet()) {
								RetailPriceCostKey storeKey = new RetailPriceCostKey(Constants.STORE_LEVEL_TYPE_ID,
										entry.getKey());
								for (Map.Entry<ItemKey, PRItemDTO> inEntry : entry.getValue().entrySet()) {
									int itemCode = inEntry.getKey().getItemCodeOrRetLirId();
									// PRItemDTO item = itemDataMapStore.get(entry.getKey()).get(itemCode);
									PRItemDTO item = itemDataMapStore.get(entry.getKey()).get(inEntry.getKey());
									zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID,
											item.getPriceZoneId());
									if (priceDataMap.get(itemCode) != null) {
										HashMap<RetailPriceCostKey, RetailPriceDTO> costMap = priceDataMap
												.get(itemCode);
										RetailPriceDTO priceDTO = priceService.findPriceForStore(costMap, storeKey,
												zoneKey, chainKey);
										populatePreviousPrice(item, priceDTO);
										if (itemCodeSet.contains(itemCode))
											itemCodeSet.remove(itemCode);
									}
								}
							}
					}
				}
			}
		}
	}

	/**
	 * 
	 * @param connection
	 * @param chainId
	 * @param inputDTO
	 * @param calDTO
	 * @param resetCalDTO
	 * @param noOfWeeksBehind
	 * @param inputDataMap
	 * @param itemDataMapStoreNotInCache
	 * @param priceAndStrategyZoneNos
	 * @param priceZoneStores
	 * @return linked map of price data in descending order
	 * @throws GeneralException
	 */
	public LinkedHashMap<Integer, HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>>> getLatestPriceDataOptimized(
			Connection connection, Integer chainId, RetailCalendarDTO calDTO, int noOfWeeksBehind,
			HashMap<ItemKey, PRItemDTO> inputDataMap, List<String> priceAndStrategyZoneNos,
			List<Integer> priceZoneStores) throws GeneralException {

		LinkedHashMap<Integer, HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>>> priceDataMap = new LinkedHashMap<>();

		RetailCalendarDAO calendarDAO = new RetailCalendarDAO();
		RetailPriceServiceOptimized priceService = new RetailPriceServiceOptimized(connection);
		List<RetailCalendarDTO> retailCalendarList = calendarDAO.getCalendarList(connection, calDTO.getCalendarId(),
				noOfWeeksBehind);

		Set<Integer> itemCodeSet = new HashSet<Integer>();
		for (PRItemDTO item : inputDataMap.values()) {
			if (!item.isLir())
				itemCodeSet.add(item.getItemCode());
		}

		boolean fetchStoreData = false;

		for (RetailCalendarDTO curCalDTO : retailCalendarList) {
//			logger.debug("Running for calendar id " + curCalDTO.getCalendarId() + " for items " + itemCodeSet.size());
			if (itemCodeSet.size() > 0) {
				HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>> priceMap = priceService.getRetailPrice(
						curCalDTO.getCalendarId(), chainId, priceAndStrategyZoneNos, priceZoneStores, fetchStoreData,
						itemCodeSet);

				for (Map.Entry<ItemKey, PRItemDTO> entry : inputDataMap.entrySet()) {
					int itemCode = entry.getKey().getItemCodeOrRetLirId();
					if (priceMap.containsKey(itemCode)) {
						if (itemCodeSet.contains(itemCode))
							itemCodeSet.remove(itemCode);
					}
				}

				priceDataMap.put(curCalDTO.getCalendarId(), priceMap);
			}
		}

		return priceDataMap;
	}

	/**
	 * 
	 * @param priceDataMap
	 * @param inputDataMap
	 * @param chainId
	 * @param inputDTO
	 */
	public void setCurrentPriceForItems(
			LinkedHashMap<Integer, HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>>> priceDataMap,
			HashMap<ItemKey, PRItemDTO> inputDataMap, int chainId, PRStrategyDTO inputDTO) {
		
		int locationId = 0;

		if (inputDTO.isPriceTestZone())
			locationId = inputDTO.getTempLocationID();
		else
			locationId = inputDTO.getLocationId();

		RetailPriceCostKey chainKey = new RetailPriceCostKey(Constants.CHAIN_LEVEL_TYPE_ID, chainId);
		RetailPriceCostKey zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, locationId);

		RetailPriceServiceOptimized priceService = new RetailPriceServiceOptimized();
		Set<Integer> processedItems = new HashSet<>();
		for (Map.Entry<Integer, HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>>> priceWeekEntry : priceDataMap
				.entrySet()) {

			for (Map.Entry<ItemKey, PRItemDTO> entry : inputDataMap.entrySet()) {

				int itemCode = entry.getKey().getItemCodeOrRetLirId();
				PRItemDTO item = entry.getValue();
				if(!item.isLir()) {			

					zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());

					if (priceWeekEntry.getValue().get(itemCode) != null && !processedItems.contains(itemCode)) {

						HashMap<RetailPriceCostKey, RetailPriceDTO> priceMap = priceWeekEntry.getValue().get(itemCode);
						RetailPriceDTO priceDTO = priceService.findPriceForZone(priceMap, zoneKey, chainKey);
						populateCurrentPrice(item, priceDTO);
						processedItems.add(itemCode);
						if (item.getSecondaryZones() != null && item.getSecondaryZones().size() > 0) {
							item.getSecondaryZones().forEach(secZone -> {
								RetailPriceCostKey secZoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID,
										secZone.getPriceZoneId());
								RetailPriceDTO secZonePriceDTO = priceService.findPriceForZone(priceMap, secZoneKey,
										chainKey);
								populateSecondaryZonePrice(secZone, secZonePriceDTO);
							});
						}
					}
				}
			}
		}
	}

	public HashMap<Integer, HashMap<String, List<RetailPriceDTO>>> getPriceHistory(Connection conn, Integer chainId,
			HashMap<String, RetailCalendarDTO> allWeekCalendarDetails, RetailCalendarDTO calDTO,
			RetailCalendarDTO resetCalDTO, HashMap<ItemKey, PRItemDTO> inputDataMap,
			List<String> priceAndStrategyZoneNos, List<Integer> priceZoneStores, boolean fetchStorePrice)
			throws GeneralException {

		int noOfPriceHistory = Integer.parseInt(PropertyManager.getProperty("FETCH_PRICE_HISTORY_NO_OF_WEEKS"));
		HashSet<Integer> calendarIdToFetch = new HashSet<Integer>();
		HashMap<Integer, HashMap<String, List<RetailPriceDTO>>> itemPriceHistory = new HashMap<Integer, HashMap<String, List<RetailPriceDTO>>>();
		RetailPriceServiceOptimized priceService = new RetailPriceServiceOptimized(conn);
		Set<Integer> itemCodeSet = new HashSet<Integer>();

		try {
			Date latestWeekWithPriceStartDate = DateUtil.toDate(calDTO.getStartDate());

			// All the calendar id's for which price to be fetched
			for (int i = 0; i < noOfPriceHistory; i++) {
				String weekStartDate = DateUtil.dateToString(
						DateUtil.incrementDate(latestWeekWithPriceStartDate, -(7 * (i))), Constants.APP_DATE_FORMAT);
				if (allWeekCalendarDetails.get(weekStartDate) != null) {
					RetailCalendarDTO retailCalendarDTO = allWeekCalendarDetails.get(weekStartDate);
					calendarIdToFetch.add(retailCalendarDTO.getCalendarId());
				}
			}

			// Add reset week calendar id's also, making sure those data is also fetched
			if (resetCalDTO != null) {
				if (allWeekCalendarDetails.get(resetCalDTO.getStartDate()) != null) {
					RetailCalendarDTO retailCalendarDTO = allWeekCalendarDetails.get(resetCalDTO.getStartDate());
					calendarIdToFetch.add(retailCalendarDTO.getCalendarId());
				}
			}

			itemCodeSet = new HashSet<Integer>();
			for (PRItemDTO item : inputDataMap.values()) {
				if (!item.isLir())
					itemCodeSet.add(item.getItemCode());
			}

			itemPriceHistory = priceService.getRetailPrice(calendarIdToFetch, chainId, priceAndStrategyZoneNos,
					priceZoneStores, fetchStorePrice, itemCodeSet);

		} catch (GeneralException ex) {
			logger.error("Error while executing getPriceHistory() " + ex);
			throw new GeneralException("Exception in getPriceHistory()", ex);
		}
		return itemPriceHistory;
	}

	private void populatePreviousPrice(PRItemDTO item, RetailPriceDTO priceDTO) {
		double price = priceDTO.getRegQty() > 1 ? (priceDTO.getRegMPrice() / priceDTO.getRegQty())
				: priceDTO.getRegPrice();
		item.setPreRegPrice(price);
	}

	private void populateCurrentPrice(PRItemDTO item, RetailPriceDTO priceDTO) {
		double price = priceDTO.getRegQty() > 1 ? (priceDTO.getRegMPrice() / priceDTO.getRegQty())
				: priceDTO.getRegPrice();
		item.setRegPrice(price);
		item.setRegMPack((priceDTO.getRegQty() == 0 ? 1 : priceDTO.getRegQty()));
		item.setRegMPrice(new Double(priceDTO.getRegMPrice()));
		item.setCurRegPriceEffDate(priceDTO.getRegEffectiveDate());
		item.setCoreRetail(priceDTO.getCoreRetail());
		if ((item.getRegMPack() == 1 && item.getRegPrice() == 0)
				|| (item.getRegMPack() > 1 && item.getRegMPrice() == 0)) {
			item.setRegMPack(0);
		}
	}

	public List<PRStorePrice> getStorePrices(Connection conn, long recommendationRunId, List<Integer> items)
			throws OfferManagementException {
		String chainId = null;
		PRStrategyDTO inputDTO = new PRStrategyDTO();
		RetailCalendarDTO calDTO = new RetailCalendarDTO();
		HashMap<ItemKey, PRItemDTO> inputDataMap = new HashMap<ItemKey, PRItemDTO>();
		HashMap<Integer, HashMap<ItemKey, PRItemDTO>> itemDataMapStore = new HashMap<Integer, HashMap<ItemKey, PRItemDTO>>();
		HashMap<Integer, HashMap<ItemKey, PRItemDTO>> itemDataMapStoreNotInCache = new HashMap<Integer, HashMap<ItemKey, PRItemDTO>>();
		List<String> priceAndStrategyZoneNos = new ArrayList<String>();
		List<Integer> priceZoneStores = new ArrayList<Integer>();
		List<ExecutionTimeLog> executionTimeLogs = new ArrayList<ExecutionTimeLog>();
		List<PRItemDTO> allStoreItems = new ArrayList<PRItemDTO>();
		ItemService itemService = new ItemService(executionTimeLogs);
		List<PRStorePrice> storePrices = new ArrayList<PRStorePrice>();
		PRStorePrice storePrice;

		try {
			// Get Chain Id
			chainId = new RetailPriceDAO().getChainId(conn);

			// Get Recommendation Run Header Detail
			PRRecommendationRunHeader recRunHeader = getRecommendationRunHeader(conn, recommendationRunId);

			// Fill Calendar Id
			calDTO.setCalendarId(recRunHeader.getCurRetailCalendarId());

			// Get priceZoneStores
			priceZoneStores = itemService.getPriceZoneStores(conn, recRunHeader.getProductLevelId(),
					recRunHeader.getProductId(), recRunHeader.getLocationLevelId(), recRunHeader.getLocationId());

			// Get items
			allStoreItems = itemService.getAuthorizedItemsOfZoneAndStore(conn, recRunHeader.getProductLevelId(),
					recRunHeader.getProductId(), items, priceZoneStores);
			// Find priceAndStrategyZoneNos
			priceAndStrategyZoneNos = itemService.getPriceAndStrategyZoneNos(allStoreItems);

			// Fill inputDataMap, itemDataMapStore, itemDataMapStoreNotInCache,
			for (PRItemDTO itemInfo : allStoreItems) {
				ItemKey itemKey = PRCommonUtil.getItemKey(itemInfo);
				HashMap<ItemKey, PRItemDTO> tMap = null;

				inputDataMap.put(itemKey, itemInfo);

				if (itemDataMapStore.get(itemInfo.getChildLocationId()) != null) {
					tMap = itemDataMapStore.get(itemInfo.getChildLocationId());
				} else {
					tMap = new HashMap<ItemKey, PRItemDTO>();
				}

				tMap.put(itemKey, itemInfo);
				itemDataMapStore.put(itemInfo.getChildLocationId(), tMap);
				itemDataMapStoreNotInCache.put(itemInfo.getChildLocationId(), tMap);
			}

			getPriceDataOptimized(conn, Integer.valueOf(chainId), inputDTO, calDTO, null, 0, inputDataMap,
					itemDataMapStore, itemDataMapStoreNotInCache, false, priceAndStrategyZoneNos, priceZoneStores);

			for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : itemDataMapStore.entrySet()) {
				for (Map.Entry<ItemKey, PRItemDTO> inEntry : entry.getValue().entrySet()) {
					PRItemDTO itemDTO = inEntry.getValue();
					storePrice = new PRStorePrice();
					storePrice.setItemCode(inEntry.getKey().getItemCodeOrRetLirId());
					storePrice.setStoreId(entry.getKey());
					storePrice.setRegMPack(itemDTO.getRegMPack());
					if (itemDTO.getRegMPrice() != null)
						storePrice.setRegMPrice(PRFormatHelper.roundToTwoDecimalDigitAsDouble(itemDTO.getRegMPrice()));
					else
						storePrice.setRegMPrice(itemDTO.getRegMPrice());
					if (itemDTO.getRegPrice() != null)
						storePrice.setRegPrice(PRFormatHelper.roundToTwoDecimalDigitAsDouble(itemDTO.getRegPrice()));
					else
						storePrice.setRegPrice(itemDTO.getRegPrice());
					storePrices.add(storePrice);
				}
			}

		} catch (Exception | GeneralException ex) {
			logger.error("Error while executing getStorePrices() ");
			throw new OfferManagementException("Error in getStorePrices() - " + ex,
					RecommendationErrorCode.GENERAL_EXCEPTION);
		}

		return storePrices;
	}

	/**
	 * Retrieves base zone cost data for the week specified
	 * 
	 * @param conn
	 * @param inputDTO
	 * @param weekCalendarId
	 * @param itemCodeList
	 * @param inputMap
	 * @throws GeneralException
	 */
	public void getCostDataOptimized(Connection connection, Integer chainId, PRStrategyDTO inputDTO,
			RetailCalendarDTO calDTO, RetailCalendarDTO resetCalDTO, int noOfWeeksBehind,
			HashMap<ItemKey, PRItemDTO> inputMap, HashMap<Integer, HashMap<ItemKey, PRItemDTO>> inputMapForStore,
			HashMap<Integer, HashMap<ItemKey, PRItemDTO>> storeItemsNotInCache, boolean fetchZoneData,
			List<String> priceAndStrategyZoneNos, List<Integer> priceZoneStores) throws GeneralException {
		// double costChangeThreshold =
		// Double.parseDouble(PropertyManager.getProperty("PR_DASHBOARD.COST_CHANGE_THRESHOLD",
		// "0.10"));
		double costChangeThreshold = 0;
		DecimalFormat df = new DecimalFormat("######.##");
		RetailPriceCostKey chainKey = new RetailPriceCostKey(Constants.CHAIN_LEVEL_TYPE_ID, chainId);
		RetailPriceCostKey zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, inputDTO.getLocationId());

		RetailCalendarDAO calendarDAO = new RetailCalendarDAO();
		RetailCostServiceOptimized costService = new RetailCostServiceOptimized(connection);
		boolean fetchStoreData = false;

		if (inputMapForStore != null && inputMapForStore.size() > 0)
			fetchStoreData = true;

		if (fetchZoneData || fetchStoreData) {
			// Get all weeks from calDTO to noOfWeeksBehind
			List<RetailCalendarDTO> retailCalendarList = calendarDAO.getCalendarList(connection, calDTO.getCalendarId(),
					noOfWeeksBehind);
			Set<Integer> itemCodeSet = new HashSet<Integer>();
			// Get all lig members and non lig
			for (PRItemDTO item : inputMap.values()) {
				if (!item.isLir())
					itemCodeSet.add(item.getItemCode());
			}

			logger.debug("Loading current week cost");
			for (RetailCalendarDTO curCalDTO : retailCalendarList) {
//				logger.debug(
//						"Running for calendar id " + curCalDTO.getCalendarId() + " for items " + itemCodeSet.size());
				if (itemCodeSet.size() > 0) {
					HashMap<Integer, HashMap<RetailPriceCostKey, RetailCostDTO>> costDataMap = costService
							.getRetailCost(curCalDTO.getCalendarId(), chainId, priceAndStrategyZoneNos, priceZoneStores,
									fetchStoreData, itemCodeSet);

					// Populate cost data for zone
					if (fetchZoneData)
						for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
							int itemCode = entry.getKey().getItemCodeOrRetLirId();
							PRItemDTO item = entry.getValue();
							zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
							// logger.debug("Actual Zone Id of item:" + item.getPriceZoneId());
							if (costDataMap.get(itemCode) != null) {
								HashMap<RetailPriceCostKey, RetailCostDTO> costMap = costDataMap.get(itemCode);
								RetailCostDTO costDTO = costService.findCostForZone(costMap, zoneKey, chainKey);
								populateCurrentCost(item, costDTO);
								if (itemCodeSet.contains(itemCode))
									itemCodeSet.remove(itemCode);
							}
						}

					// Populate cost data for store
					if (fetchStoreData)
						for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : storeItemsNotInCache.entrySet()) {
							RetailPriceCostKey storeKey = new RetailPriceCostKey(Constants.STORE_LEVEL_TYPE_ID,
									entry.getKey());
							for (Map.Entry<ItemKey, PRItemDTO> inEntry : entry.getValue().entrySet()) {
								int itemCode = inEntry.getKey().getItemCodeOrRetLirId();
								// PRItemDTO item = inputMapForStore.get(entry.getKey()).get(itemCode);
								PRItemDTO item = inputMapForStore.get(entry.getKey()).get(inEntry.getKey());
								zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
								if (costDataMap.get(itemCode) != null) {
									HashMap<RetailPriceCostKey, RetailCostDTO> costMap = costDataMap.get(itemCode);
									RetailCostDTO costDTO = costService.findCostForStore(costMap, storeKey, zoneKey,
											chainKey);
									populateCurrentCost(item, costDTO);
									if (itemCodeSet.contains(itemCode))
										itemCodeSet.remove(itemCode);
								}
							}
						}
				}
			}

			// Load previous cost
			// Get all weeks from resetCalDTO to noOfWeeksBehind
			retailCalendarList = calendarDAO.getCalendarList(connection, resetCalDTO.getCalendarId(), noOfWeeksBehind);
			itemCodeSet = new HashSet<Integer>();
			for (PRItemDTO item : inputMap.values()) {
				if (!item.isLir())
					itemCodeSet.add(item.getItemCode());
			}

			for (RetailCalendarDTO resCalDTO : retailCalendarList) {
//				logger.debug(
//						"Running for calendar id " + resCalDTO.getCalendarId() + " for items " + itemCodeSet.size());
				if (itemCodeSet.size() > 0) {
					HashMap<Integer, HashMap<RetailPriceCostKey, RetailCostDTO>> costDataMap = costService
							.getRetailCost(resCalDTO.getCalendarId(), chainId, priceAndStrategyZoneNos, priceZoneStores,
									fetchStoreData, itemCodeSet);
					itemCodeSet.clear();

					// Populate cost data for zone
					if (fetchZoneData)
						for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
							int itemCode = entry.getKey().getItemCodeOrRetLirId();
							PRItemDTO item = entry.getValue();
							zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
							if (costDataMap.get(itemCode) != null) {
								HashMap<RetailPriceCostKey, RetailCostDTO> costMap = costDataMap.get(itemCode);
								RetailCostDTO costDTO = costService.findCostForZone(costMap, zoneKey, chainKey);
								populatePreviousCost(item, costDTO, costChangeThreshold, df);
								if (itemCodeSet.contains(itemCode))
									itemCodeSet.remove(itemCode);
							}
						}

					// Populate cost data for store
					if (fetchStoreData)
						for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : storeItemsNotInCache.entrySet()) {
							RetailPriceCostKey storeKey = new RetailPriceCostKey(Constants.STORE_LEVEL_TYPE_ID,
									entry.getKey());
							for (Map.Entry<ItemKey, PRItemDTO> inEntry : entry.getValue().entrySet()) {
								int itemCode = inEntry.getKey().getItemCodeOrRetLirId();
								// PRItemDTO item = inputMapForStore.get(entry.getKey()).get(itemCode);
								PRItemDTO item = inputMapForStore.get(entry.getKey()).get(inEntry.getKey());
								zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
								if (costDataMap.get(itemCode) != null) {
									HashMap<RetailPriceCostKey, RetailCostDTO> costMap = costDataMap.get(itemCode);
									RetailCostDTO costDTO = costService.findCostForStore(costMap, storeKey, zoneKey,
											chainKey);
									populatePreviousCost(item, costDTO, costChangeThreshold, df);
									if (itemCodeSet.contains(itemCode))
										itemCodeSet.remove(itemCode);
								}
							}
						}
				}
			}
		}
	}

	private void populatePreviousCost(PRItemDTO tDTO, RetailCostDTO zoneLevelCost, double costChangeThreshold,
			DecimalFormat df) {
		double preCost = Double.valueOf(zoneLevelCost.getListCost());
		tDTO.setPreListCost(preCost);
		boolean isMarkAsReview = Boolean
				.parseBoolean(PropertyManager.getProperty("MARK_AS_REVIEW_IF_COST_CHANGE", "FALSE"));
		if (tDTO.getListCost() != null) {
			double costChange = new Double(df.format(Math.abs(tDTO.getListCost() - preCost)));
			if (tDTO.getPreListCost() != tDTO.getListCost() && costChange > costChangeThreshold) {
				// 19th May 2016, set mark for review, when there is cost change for CVS
				if (tDTO.getListCost() < tDTO.getPreListCost()) {
					tDTO.setCostChgIndicator(-1);
				} else if (tDTO.getListCost() > tDTO.getPreListCost()) {
					tDTO.setCostChgIndicator(+1);
				}
				if (tDTO.getCostChgIndicator() != 0 && isMarkAsReview) {
					tDTO.setIsMarkedForReview(String.valueOf(Constants.YES));
				}
			}
		}
		double preVipCost = Double.valueOf(zoneLevelCost.getVipCost());
		if (preVipCost > 0)
			tDTO.setPreVipCost(preVipCost);
		if (tDTO.getVipCost() != null && tDTO.getPreVipCost() != null) {
			double vipCostChange = new Double(df.format(Math.abs(tDTO.getVipCost() - preVipCost)));
			if (tDTO.getPreVipCost() != tDTO.getVipCost() && vipCostChange > costChangeThreshold) {
				if (tDTO.getVipCost() < tDTO.getPreVipCost()) {
					tDTO.setVipCostChgIndicator(-1);
				} else if (tDTO.getVipCost() > tDTO.getPreVipCost()) {
					tDTO.setVipCostChgIndicator(+1);
				}
				if (tDTO.getVipCostChgIndicator() != 0 && isMarkAsReview) {
					tDTO.setIsMarkedForReview(String.valueOf(Constants.YES));
				}
			}
		}
	}

	private void populateCurrentCost(PRItemDTO itemDTO, RetailCostDTO zoneLevelCost) {
		itemDTO.setListCost(Double.valueOf(zoneLevelCost.getListCost()));
		itemDTO.setListCostEffDate(zoneLevelCost.getEffListCostDate());
		if (zoneLevelCost.getVipCost() > 0)
			itemDTO.setVipCost(Double.valueOf(zoneLevelCost.getVipCost()));
		if (zoneLevelCost.getDealCost() > 0) {
			// TODO:: since there is no future deal cost, latest deal cost is taken
			// as recommended week's deal cost
			itemDTO.setRecWeekDealCost(Double.valueOf(zoneLevelCost.getDealCost()));
		}

		// Set sale cost
		Double recWeekSaleCost = (itemDTO.getRecWeekDealCost() != null && itemDTO.getRecWeekDealCost() > 0)
				? itemDTO.getRecWeekDealCost()
				: itemDTO.getListCost();
		itemDTO.setRecWeekSaleCost(recWeekSaleCost);
	}

//	public void getCompPriceData(Connection conn, PRStrategyDTO inputDTO, RetailCalendarDTO calDTO, RetailCalendarDTO resetCalDTO,
//			int noOfWeeksBehind, HashMap<ItemKey, PRItemDTO> inputMap) throws GeneralException, Exception {
//		// Get Current Comp Prices
//		HashMap<Integer, CompetitiveDataDTO> currentPriceData = getCompPriceData(conn, inputDTO, calDTO.getStartDate(), noOfWeeksBehind * 7);
//
//		// group the input items by retailer item code
//		HashMap<String, List<PRItemDTO>> itemGroupedByRetItemCode = groupItemByRetailerItemCode(inputMap);
//
//		// 6th Jun 2016, comp check may not come for all items which has same retailer item code.
//		// e.g. if there are 10 items with same retailer item code, there will be 10 diff presto item code.
//		// price check will be there for only item, the price for rest of the 9 items
//		// to be copied from that 1 item. another scenario, out of 10 items, only 2 is not having comp price
//		// then apply most common price to those 2 items
//
//		// Find comp price for items with same retailer item code (where one item has price and other doesn't have)
//		findCompPriceForSameRetailerCodeItems(itemGroupedByRetItemCode, currentPriceData);
//
//		// Sort currentPriceData by using its latest Check date
//		HashMap<Integer, CompetitiveDataDTO> sortedCurrentPrice = getLatestPriceData(currentPriceData.values());
//
//		// Find most common reg price of each lig
//		HashMap<Integer, CompetitiveDataDTO> ligPriceData = getMostOccuringCompPriceForLIG(sortedCurrentPrice.values());
//
//		for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
//			int itemCode = entry.getKey().getItemCodeOrRetLirId();
//			PRItemDTO tDTO = entry.getValue();
//			CompetitiveDataDTO compDataDTO = null;
//			// Check if the item has comp price, if not take the most common price of the lig
//			if (sortedCurrentPrice.get(itemCode) != null)
//				compDataDTO = sortedCurrentPrice.get(itemCode);
//			else if (ligPriceData.get(tDTO.getRetLirId()) != null)
//				compDataDTO = ligPriceData.get(tDTO.getRetLirId());
//
//			if (compDataDTO != null) {
//				double curPrice = compDataDTO.regPrice;
//				double regMPrice = compDataDTO.regMPrice;
//				LocationKey locationKey = new LocationKey(inputDTO.getLocationLevelId(), inputDTO.getLocationId());
//				MultiplePrice multiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.regMPack, curPrice, regMPrice);
//				MultiplePrice saleMultiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.saleMPack, (double) compDataDTO.fSalePrice,
//						(double) compDataDTO.fSaleMPrice);
//				tDTO.addAllCompPrice(locationKey, multiplePrice);
//				tDTO.addAllCompSalePrice(locationKey, saleMultiplePrice);
//				tDTO.addAllCompPriceCheckDate(locationKey, compDataDTO.checkDate);
//			}
//		}
//		// Get Previous Comp Prices
//		HashMap<Integer, CompetitiveDataDTO> prevPriceData = getCompPriceData(conn, inputDTO, resetCalDTO.getStartDate(), noOfWeeksBehind * 7);
//
//		// Find comp price for items with same retailer item code (where one item has price and other doesn't have)
//		findCompPriceForSameRetailerCodeItems(itemGroupedByRetItemCode, prevPriceData);
//
//		// Sort prevPriceData by using its latest Check date
//		HashMap<Integer, CompetitiveDataDTO> sortedPrevPrice = getLatestPriceData(prevPriceData.values());
//
//		// Find most common reg price of each lig
//		ligPriceData = getMostOccuringCompPriceForLIG(sortedPrevPrice.values());
//
//		for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
//			int itemCode = entry.getKey().getItemCodeOrRetLirId();
//			PRItemDTO itemDTO = entry.getValue();
//			CompetitiveDataDTO prePriceCompDataDTO = null;
//			if (sortedPrevPrice.get(itemCode) != null)
//				prePriceCompDataDTO = sortedPrevPrice.get(itemCode);
//			else if (ligPriceData.get(itemDTO.getRetLirId()) != null)
//				prePriceCompDataDTO = ligPriceData.get(itemDTO.getRetLirId());
//
//			// If there is previous price
//			if (prePriceCompDataDTO != null) {
//				// double prePrice = prePriceCompDataDTO.regPrice;
//				double regPrice = prePriceCompDataDTO.regPrice;
//				double regMPrice = prePriceCompDataDTO.regMPrice;
//				MultiplePrice preMultiplePrice = PRCommonUtil.getMultiplePrice(prePriceCompDataDTO.regMPack, regPrice, regMPrice);
//				LocationKey locationKey = new LocationKey(inputDTO.getLocationLevelId(), inputDTO.getLocationId());
//				// itemDTO.addAllCompPreviousPrice(inputDTO.getLocationId(), preMultiplePrice);
//				itemDTO.addAllCompPreviousPrice(locationKey, preMultiplePrice);
//				// If there is current price
//				// if(itemDTO.getAllCompPrice() != null && itemDTO.getAllCompPrice().get(inputDTO.getLocationId()) != null){
//				if (itemDTO.getAllCompPrice() != null && itemDTO.getAllCompPrice().get(locationKey) != null) {
//					// MultiplePrice curMultiplePrice = itemDTO.getAllCompPrice().get(inputDTO.getLocationId());
//					MultiplePrice curMultiplePrice = itemDTO.getAllCompPrice().get(locationKey);
//					// There is cur and prev price and both are greater than 0
//					// compare against unit price
//					double curCompPrice = PRCommonUtil.getUnitPrice(curMultiplePrice, true);
//					double preCompPrice = PRCommonUtil.getUnitPrice(preMultiplePrice, true);
//					if (curCompPrice > 0 && preCompPrice > 0) {
//						if (curCompPrice < preCompPrice) {
//							itemDTO.addAllCompPriceChgIndicator(locationKey, -1);
//							// itemDTO.addAllCompPriceChgIndicator(inputDTO.getLocationId(), -1);
//						} else if (curCompPrice > preCompPrice) {
//							itemDTO.addAllCompPriceChgIndicator(locationKey, 1);
//							// itemDTO.addAllCompPriceChgIndicator(inputDTO.getLocationId(), 1);
//						} else {
//							itemDTO.addAllCompPriceChgIndicator(locationKey, 0);
//							// itemDTO.addAllCompPriceChgIndicator(inputDTO.getLocationId(), 0);
//						}
//					}
//				}
//			}
//		}
//	}

	public void getCompPriceData(Connection conn, PRStrategyDTO inputDTO, RetailCalendarDTO calDTO,
			RetailCalendarDTO resetCalDTO, int noOfWeeksBehind, HashMap<ItemKey, PRItemDTO> inputMap)
			throws GeneralException, Exception {

		// Get Current Comp Prices
		HashMap<Integer, CompetitiveDataDTO> currentPriceData = getLatestCompPriceData(conn, inputDTO,
				calDTO.getStartDate(), noOfWeeksBehind * 7);

		// Get previous Comp Prices
		HashMap<Integer, CompetitiveDataDTO> prevPriceData = getPreviousCompPriceData(conn, inputDTO,
				calDTO.getStartDate(), noOfWeeksBehind * 7);

		getCompPriceData(inputDTO, calDTO, noOfWeeksBehind, inputMap, currentPriceData, prevPriceData);
	}

	/**
	 * Retrieves Competition Data
	 * 
	 * @param conn
	 * @param inputDTO
	 * @param calDTO
	 * @param resetCalDTO
	 * @param noOfWeeksBehind
	 * @param inputMap
	 * @throws GeneralException
	 * @throws Exception
	 */
	public void getCompPriceData(PRStrategyDTO inputDTO, RetailCalendarDTO calDTO, int noOfWeeksBehind,
			HashMap<ItemKey, PRItemDTO> inputMap, HashMap<Integer, CompetitiveDataDTO> latestCompPriceMap,
			HashMap<Integer, CompetitiveDataDTO> previousCompPriceMap) throws GeneralException, Exception {
		// Get Current Comp Prices
		// HashMap<Integer, CompetitiveDataDTO> currentPriceData =
		// getCompPriceData(conn, inputDTO, calDTO.getStartDate(),
		// noOfWeeksBehind * 7, false);

		// group the input items by retailer item code
		HashMap<String, List<PRItemDTO>> itemGroupedByRetItemCode = groupItemByRetailerItemCode(inputMap);

		// 6th Jun 2016, comp check may not come for all items which has same retailer
		// item code.
		// e.g. if there are 10 items with same retailer item code, there will be 10
		// diff presto item code.
		// price check will be there for only item, the price for rest of the 9 items
		// to be copied from that 1 item. another scenario, out of 10 items, only 2 is
		// not having comp price
		// then apply most common price to those 2 items

		// Find comp price for items with same retailer item code (where one item has
		// price and other doesn't have)
		findCompPriceForSameRetailerCodeItems(itemGroupedByRetItemCode, latestCompPriceMap);

		// Sort currentPriceData by using its latest Check date
		HashMap<Integer, CompetitiveDataDTO> sortedCurrentPrice = getLatestPriceData(latestCompPriceMap.values());

		// Find most common reg price of each lig
		HashMap<Integer, CompetitiveDataDTO> ligPriceData = getMostOccuringCompPriceForLIG(sortedCurrentPrice.values());

		for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
			int itemCode = entry.getKey().getItemCodeOrRetLirId();
			PRItemDTO tDTO = entry.getValue();
			// Condition added by Karishma to set CompPrices only for items and not lir
			if (!tDTO.isLir()) {
				CompetitiveDataDTO compDataDTO = null;
				// Check if the item has comp price, if not take the most common price of the
				// lig
				if (sortedCurrentPrice.get(itemCode) != null)
					compDataDTO = sortedCurrentPrice.get(itemCode);
				else if (ligPriceData.get(tDTO.getRetLirId()) != null)
					compDataDTO = ligPriceData.get(tDTO.getRetLirId());

				if (compDataDTO != null) {
					double curPrice = compDataDTO.regPrice;
					double regMPrice = compDataDTO.regMPrice;
					LocationKey locationKey = new LocationKey(inputDTO.getLocationLevelId(), inputDTO.getLocationId());
					locationKey.setChainId(inputDTO.getChainId());
					MultiplePrice multiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.regMPack, curPrice,
							regMPrice);
					MultiplePrice saleMultiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.saleMPack,
							(double) compDataDTO.fSalePrice, (double) compDataDTO.fSaleMPrice);
					tDTO.addAllCompPrice(locationKey, multiplePrice);
					tDTO.addAllCompSalePrice(locationKey, saleMultiplePrice);
					tDTO.addAllCompPriceCheckDate(locationKey, compDataDTO.checkDate);
				}
			}
		}
		// Get Previous Comp Prices
		// HashMap<Integer, CompetitiveDataDTO> prevPriceData = getCompPriceData(conn,
		// inputDTO, resetCalDTO.getStartDate(), noOfWeeksBehind * 7);

		// Find comp price for items with same retailer item code (where one item has
		// price and other doesn't have)
		findCompPriceForSameRetailerCodeItems(itemGroupedByRetItemCode, previousCompPriceMap);

		// Sort prevPriceData by using its latest Check date
		HashMap<Integer, CompetitiveDataDTO> sortedPrevPrice = getLatestPriceData(previousCompPriceMap.values());

		// Find most common reg price of each lig
		ligPriceData = getMostOccuringCompPriceForLIG(sortedPrevPrice.values());

		for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
			int itemCode = entry.getKey().getItemCodeOrRetLirId();
			PRItemDTO itemDTO = entry.getValue();
			CompetitiveDataDTO prePriceCompDataDTO = null;
			MultiplePrice latestCompPrice = null, preMultiplePrice = null;
			LocationKey locationKey = new LocationKey(inputDTO.getLocationLevelId(), inputDTO.getLocationId());
			String latestCompPriceCheckDate = null;

			if (sortedPrevPrice.get(itemCode) != null) {
				prePriceCompDataDTO = sortedPrevPrice.get(itemCode);
			} else if (ligPriceData.get(itemDTO.getRetLirId()) != null) {
				prePriceCompDataDTO = ligPriceData.get(itemDTO.getRetLirId());
			}

			if (itemDTO.getAllCompPrice() != null && itemDTO.getAllCompPrice().get(locationKey) != null) {
				latestCompPrice = itemDTO.getAllCompPrice().get(locationKey);
				latestCompPriceCheckDate = itemDTO.getAllCompPriceCheckDate().get(locationKey);
			}

			if (prePriceCompDataDTO != null) {
				preMultiplePrice = PRCommonUtil.getMultiplePrice(prePriceCompDataDTO.regMPack,
						(double) prePriceCompDataDTO.regPrice, (double) prePriceCompDataDTO.regMPrice);
			}

			// 23rd Mar 2017, previously previous comp price was found based on reset date,
			// that triggered price change for every week considering there is comp increase
			// as reset date is not set.

			// now the previous comp price is considered, only when the comp change in not
			// reflected
			// in the price. for e.g. if there is a price change after the comp change
			// it will be assumed that the comp change is reflected

			double latestCompUnitPrice = PRCommonUtil.getUnitPrice(latestCompPrice, true);
			double preCompUnitPrice = PRCommonUtil.getUnitPrice(preMultiplePrice, true);

			boolean isPreviousCompSet = false;

			// If there is current and previous comp price and both are different
			if (latestCompUnitPrice != preCompUnitPrice) {
				Integer compPriceChgIndicator = getCompChgIndicator(itemDTO, latestCompUnitPrice, preCompUnitPrice,
						latestCompPriceCheckDate, calDTO.getStartDate());
				if (compPriceChgIndicator != null) {
					itemDTO.addAllCompPriceChgIndicator(locationKey, compPriceChgIndicator);
					itemDTO.addAllCompPreviousPrice(locationKey, preMultiplePrice);
					isPreviousCompSet = true;
				}
			}

			if (!isPreviousCompSet) {
				itemDTO.addAllCompPreviousPrice(locationKey, latestCompPrice);
			}

		}
	}

	/**
	 * 
	 * @param inputMap
	 * @param latestCompPriceMap
	 * @param compStrId
	 * @throws Exception
	 */
	public void setCompPriceData(HashMap<ItemKey, PRItemDTO> inputMap,
			HashMap<Integer, CompetitiveDataDTO> latestCompPriceMap, int compStrId, int compChainId) throws Exception {

		// group the input items by retailer item code
		HashMap<String, List<PRItemDTO>> itemGroupedByRetItemCode = groupItemByRetailerItemCode(inputMap);

		findCompPriceForSameRetailerCodeItems(itemGroupedByRetItemCode, latestCompPriceMap);

		// Sort currentPriceData by using its latest Check date
		HashMap<Integer, CompetitiveDataDTO> sortedCurrentPrice = getLatestPriceData(latestCompPriceMap.values());

		// Find most common reg price of each lig
		HashMap<Integer, CompetitiveDataDTO> ligPriceData = getMostOccuringCompPriceForLIG(sortedCurrentPrice.values());

		for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
			int itemCode = entry.getKey().getItemCodeOrRetLirId();
			PRItemDTO tDTO = entry.getValue();
			CompetitiveDataDTO compDataDTO = null;
			// Check if the item has comp price, if not take the most common price of the
			// lig
			if (sortedCurrentPrice.get(itemCode) != null)
				compDataDTO = sortedCurrentPrice.get(itemCode);
			else if (ligPriceData.get(tDTO.getRetLirId()) != null)
				compDataDTO = ligPriceData.get(tDTO.getRetLirId());

			if (compDataDTO != null) {
				double curPrice = compDataDTO.regPrice;
				double regMPrice = compDataDTO.regMPrice;
				LocationKey locationKey = new LocationKey(Constants.STORE_LEVEL_ID, compStrId);
				locationKey.setChainId(compChainId);
				MultiplePrice multiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.regMPack, curPrice, regMPrice);
				MultiplePrice saleMultiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.saleMPack,
						(double) compDataDTO.fSalePrice, (double) compDataDTO.fSaleMPrice);
				tDTO.addAllCompPrice(locationKey, multiplePrice);
				tDTO.addAllCompSalePrice(locationKey, saleMultiplePrice);
				tDTO.addAllCompPriceCheckDate(locationKey, compDataDTO.checkDate);
			}
		}
	}

	public Integer getCompChgIndicator(PRItemDTO itemDTO, double latestCompUnitPrice, double preCompUnitPrice,
			String latestCompPriceCheckDate, String weekStartDate) throws GeneralException {
		Integer compPriceChgIndicator = null;

		boolean isConsiderAsCompChange = false;

		// when there is no list comp effective date, consider the week
		// in which the comp changed as comp effective date
		String compEffDate = (latestCompPriceCheckDate != null ? latestCompPriceCheckDate : weekStartDate);

		// when there is no reg retail effective date, but there is comp change
		if (itemDTO.getCurRegPriceEffDate() == null) {
			isConsiderAsCompChange = true;
		} else {
			Date curRegPriceEffDate = DateUtil.toDate(itemDTO.getCurRegPriceEffDate());
			// if reg effective date is equal or after cost effective date
			if (curRegPriceEffDate.equals(DateUtil.toDate(compEffDate))
					|| curRegPriceEffDate.after(DateUtil.toDate(compEffDate))) {
				isConsiderAsCompChange = false;
			} else if (curRegPriceEffDate.before(DateUtil.toDate(compEffDate))) {
				isConsiderAsCompChange = true;
			}
		}

		if (isConsiderAsCompChange) {
			if (latestCompUnitPrice > 0 && preCompUnitPrice > 0) {
				if (latestCompUnitPrice < preCompUnitPrice) {
					compPriceChgIndicator = -1;
				} else if (latestCompUnitPrice > preCompUnitPrice) {
					compPriceChgIndicator = 1;
				} else {
					compPriceChgIndicator = 0;
				}
			}
		}

		return compPriceChgIndicator;
	}

	private HashMap<String, List<PRItemDTO>> groupItemByRetailerItemCode(HashMap<ItemKey, PRItemDTO> inputMap) {
		HashMap<String, List<PRItemDTO>> groupItemByRetItemCode = new HashMap<String, List<PRItemDTO>>();
		HashMap<String, List<PRItemDTO>> groupItemByRetItemCodeFinal = new HashMap<String, List<PRItemDTO>>();
		for (Map.Entry<ItemKey, PRItemDTO> entry : inputMap.entrySet()) {
			ItemKey itemKey = entry.getKey();
			PRItemDTO itemDTO = entry.getValue();
			List<PRItemDTO> items = new ArrayList<PRItemDTO>();
			// non-lig and lig members
			if (itemKey.getLirIndicator() == PRConstants.NON_LIG_ITEM_INDICATOR) {
				if (groupItemByRetItemCode.get(itemDTO.getRetailerItemCode()) != null) {
					items = groupItemByRetItemCode.get(itemDTO.getRetailerItemCode());
				}
				items.add(itemDTO);
				groupItemByRetItemCode.put(itemDTO.getRetailerItemCode(), items);
				if(items.size()>1)
				{
					groupItemByRetItemCodeFinal.put(itemDTO.getRetailerItemCode(), items);
				}
			
			}
		}
		return groupItemByRetItemCodeFinal;
	}

	/**
	 * comp check may not come for all items which has same retailer item code. e.g.
	 * if there are 10 items with same retailer item code, there will be 10 diff
	 * presto item code. price check will be there for only item, the price for rest
	 * of the 9 items to be copied from that 1 item. another scenario, out of 10
	 * items, only 2 is not having comp price then apply most common price to those
	 * 2 items
	 * 
	 * @param itemGroupedByRetItemCode
	 * @param compPriceData
	 */
	private void findCompPriceForSameRetailerCodeItems(HashMap<String, List<PRItemDTO>> itemGroupedByRetItemCode,
			HashMap<Integer, CompetitiveDataDTO> compPriceData) {
		// Loop items with same retailer item codes
		for (Map.Entry<String, List<PRItemDTO>> entry : itemGroupedByRetItemCode.entrySet()) {
			List<PRItemDTO> sameRetailerItemCodeItems = entry.getValue();
			List<PRItemDTO> itemsWithCompPrice = new ArrayList<PRItemDTO>();
			MostOccurrenceData mostOccurrenceData = new MostOccurrenceData();

			// Take all comp prices of items with same retailer item code
			for (PRItemDTO itemDTO : sameRetailerItemCodeItems) {
				if (compPriceData.get(itemDTO.getItemCode()) != null) {
					CompetitiveDataDTO compDataDTO = compPriceData.get(itemDTO.getItemCode());
					PRItemDTO prItemDTO = new PRItemDTO();
					MultiplePrice multiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.regMPack,
							(double) compDataDTO.regPrice, (double) compDataDTO.regMPrice);
					prItemDTO.setCompPrice(multiplePrice);
					// When the comp price is 0, it will be null
					if (multiplePrice != null)
						itemsWithCompPrice.add(prItemDTO);
				}
			}

			// Atleast one of the retailer item code has comp price
			if (itemsWithCompPrice.size() > 0) {
				CompetitiveDataDTO representingCompData = new CompetitiveDataDTO();
				List<CompetitiveDataDTO> clonedCompPrices = new ArrayList<CompetitiveDataDTO>();
				// Find common price
				MultiplePrice commonCompPrice = (MultiplePrice) mostOccurrenceData.getMaxOccurance(itemsWithCompPrice,
						"CurCompRegPrice");

				// pick any one compdata with that price, to fill other details
				for (PRItemDTO itemDTO : sameRetailerItemCodeItems) {
					if (compPriceData.get(itemDTO.getItemCode()) != null) {
						CompetitiveDataDTO compDataDTO = compPriceData.get(itemDTO.getItemCode());
						MultiplePrice multiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.regMPack,
								(double) compDataDTO.regPrice, (double) compDataDTO.regMPrice);

						if (commonCompPrice.equals(multiplePrice)) {
							representingCompData = compPriceData.get(itemDTO.getItemCode());
							break;
						}
					}
				}

				for (PRItemDTO itemDTO : sameRetailerItemCodeItems) {
					// Clone for item's for which there is no comp price
					if (compPriceData.get(itemDTO.getItemCode()) == null) {
						CompetitiveDataDTO compDataDTO = new CompetitiveDataDTO();
						compDataDTO.itemcode = itemDTO.getItemCode();
						compDataDTO.retailerItemCode = itemDTO.getRetailerItemCode();
						compDataDTO.weekStartDate = representingCompData.weekStartDate;
						compDataDTO.regMPack = commonCompPrice.multiple;
						compDataDTO.regPrice = (float) (commonCompPrice.multiple == 1 ? commonCompPrice.price : 0);
						compDataDTO.regMPrice = (float) (commonCompPrice.multiple > 1 ? commonCompPrice.price : 0);
						compDataDTO.effRegRetailStartDate = representingCompData.effRegRetailStartDate;
						compDataDTO.saleMPack = representingCompData.saleMPack;
						compDataDTO.fSaleMPrice = representingCompData.fSaleMPrice;
						compDataDTO.fSalePrice = representingCompData.fSalePrice;
						compDataDTO.lirId = itemDTO.getRetLirId();
						compDataDTO.checkDate = representingCompData.checkDate;
						clonedCompPrices.add(compDataDTO);
					}
				}

				// Insert it in currentPriceData
				for (CompetitiveDataDTO competitiveDataDTO : clonedCompPrices) {
					compPriceData.put(competitiveDataDTO.itemcode, competitiveDataDTO);
				}
			}
		}
	}

	/**
	 * Returns most occuring competition data for every LIG
	 * 
	 * @param compPriceData
	 * @return
	 */
	public HashMap<Integer, CompetitiveDataDTO> getMostOccuringCompPriceForLIG(
			Collection<CompetitiveDataDTO> compPriceData) {
		HashMap<Integer, ArrayList<PRItemDTO>> ligMemberPrice = new HashMap<Integer, ArrayList<PRItemDTO>>();
		// Keep lig and its members in a hashmap
		for (CompetitiveDataDTO compDataDTO : compPriceData) {
			if (compDataDTO.lirId > 0) {
				PRItemDTO itemDTO = new PRItemDTO();
				double regPrice = compDataDTO.regPrice;
				double regMPrice = compDataDTO.regMPrice;
				double salePrice = compDataDTO.fSalePrice;
				double saleMPrice = compDataDTO.fSaleMPrice;
				MultiplePrice multiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.regMPack, regPrice, regMPrice);
				MultiplePrice saleMultiplePrice = PRCommonUtil.getMultiplePrice(compDataDTO.saleMPack, salePrice,
						saleMPrice);
				itemDTO.setCompPrice(multiplePrice);
				itemDTO.setCompCurSalePrice(saleMultiplePrice);
				itemDTO.setCompPriceCheckDate(compDataDTO.checkDate);
				ArrayList<PRItemDTO> ligMemberList = null;
				if (ligMemberPrice.get(compDataDTO.lirId) != null)
					ligMemberList = ligMemberPrice.get(compDataDTO.lirId);
				else
					ligMemberList = new ArrayList<PRItemDTO>();
				ligMemberList.add(itemDTO);
				ligMemberPrice.put(compDataDTO.lirId, ligMemberList);
			}
		}

		// Find most common reg price of each lig
		MostOccurrenceData mostOccurrenceData = new MostOccurrenceData();
		HashMap<Integer, CompetitiveDataDTO> ligPrice = new HashMap<Integer, CompetitiveDataDTO>();
		// Loop through each lig members
		for (Map.Entry<Integer, ArrayList<PRItemDTO>> entry : ligMemberPrice.entrySet()) {
			// Get most common reg price of the lig
			if (mostOccurrenceData.getMaxOccurance(entry.getValue(), "CurCompRegPrice") != null) {
				CompetitiveDataDTO compDataDTO = new CompetitiveDataDTO();
				MultiplePrice multiPrice = (MultiplePrice) mostOccurrenceData.getMaxOccurance(entry.getValue(),
						"CurCompRegPrice");
				MultiplePrice saleMultiPrice = (MultiplePrice) mostOccurrenceData.getMaxOccurance(entry.getValue(),
						"CurCompSalePrice");
				// compDataDTO.regPrice =
				// ((Double)mostOccurrenceData.getMaxOccurance(entry.getValue(),
				// "CurCompRegPrice")).floatValue();
				// compDataDTO.checkDate =
				// (String)mostOccurrenceData.getMaxOccurance(entry.getValue(),
				// "CompPriceCheckDate");
				compDataDTO.regMPack = multiPrice.multiple;
				if (multiPrice.multiple > 1)
					compDataDTO.regMPrice = multiPrice.price.floatValue();
				else
					compDataDTO.regPrice = multiPrice.price.floatValue();

				compDataDTO.checkDate = (String) mostOccurrenceData.getMaxOccurance(entry.getValue(),
						"CompPriceCheckDate");

				if (saleMultiPrice != null) {
					compDataDTO.saleMPack = saleMultiPrice.multiple;
					if (saleMultiPrice.multiple > 1)
						compDataDTO.fSaleMPrice = saleMultiPrice.price.floatValue();
					else
						compDataDTO.fSalePrice = saleMultiPrice.price.floatValue();
				}

				ligPrice.put(entry.getKey(), compDataDTO);
			}

		}
		return ligPrice;
	}

	public HashMap<Integer, CompetitiveDataDTO> getLatestCompPriceData(Connection connection, PRStrategyDTO inputDTO,
			String weekStartDate, int maxDataLookupRange) throws GeneralException {

		HashMap<Integer, CompetitiveDataDTO> priceData = getCompPriceData(connection, inputDTO, weekStartDate,
				maxDataLookupRange, 1);

		return priceData;
	}

	public HashMap<Integer, CompetitiveDataDTO> getLatestCompPriceData(Connection connection, PRStrategyDTO inputDTO,
			String weekStartDate, int maxDataLookupRange, String productIdList) throws GeneralException {

		HashMap<Integer, CompetitiveDataDTO> priceData = getCompPriceData(connection, inputDTO, weekStartDate,
				maxDataLookupRange, 1, productIdList);

		return priceData;
	}

	public HashMap<Integer, CompetitiveDataDTO> getPreviousCompPriceData(Connection connection, PRStrategyDTO inputDTO,
			String weekStartDate, int maxDataLookupRange) throws GeneralException {

		HashMap<Integer, CompetitiveDataDTO> priceData = getCompPriceData(connection, inputDTO, weekStartDate,
				maxDataLookupRange, 2);

		return priceData;
	}

	/**
	 * Retrieves competition data from database
	 * 
	 * @param connection
	 * @param inputDTO
	 * @param weekStartDate
	 * @param maxDataLookupRange
	 * @return
	 * @throws GeneralException
	 */
	private HashMap<Integer, CompetitiveDataDTO> getCompPriceData(Connection connection, PRStrategyDTO inputDTO,
			String weekStartDate, int maxDataLookupRange, int rank) throws GeneralException {
		long startTime = System.currentTimeMillis();
		PreparedStatement statement = null;
		ResultSet resultSet = null;
		int productLevelId = inputDTO.getProductLevelId();
		int productId = inputDTO.getProductId();
		HashMap<Integer, CompetitiveDataDTO> priceData = new HashMap<Integer, CompetitiveDataDTO>();
		try {
			String query = new String(GET_COMP_PRICE_DATA);
			query = query.replaceAll("%QUERY_CONDITION%", getQueryCondition(productLevelId, productId));

			String compCondition = "";
			if (inputDTO.getLocationLevelId() == Constants.COMP_STORE_LIST_LEVEL_ID) {
				compCondition = " S.LOCATION_LEVEL_ID = " + inputDTO.getLocationLevelId() + " AND S.LOCATION_ID = "
						+ inputDTO.getLocationId();
			} else {
				compCondition = " S.COMP_STR_ID = " + inputDTO.getLocationId();
			}

			query = query.replaceAll("%COMP_CONDITION%", compCondition);

//			logger.debug("Comp Price Query " + query);
//			logger.debug("Query Parameters. 1--" + inputDTO.getLocationId() + ",2,3--" + weekStartDate + ",4--"
//					+ maxDataLookupRange + ",5--" + productLevelId + ",6--" + productId);
			statement = connection.prepareStatement(query);

			int counter = 0;
			// statement.setInt(++counter, inputDTO.getLocationId());
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekStartDate);
			statement.setInt(++counter, maxDataLookupRange);
			if (productLevelId > 1) {
				statement.setInt(++counter, productLevelId);
				if (productId > 0) {
					statement.setLong(++counter, productId);
				}
			} else if (productLevelId == 1) {
				statement.setLong(++counter, productId);
			}

			// 23rd March, logic change in getting previous comp price change
			// pick 2nd latest with in x weeks as previous comp price
			statement.setLong(++counter, rank);

			statement.setFetchSize(10000);
			resultSet = statement.executeQuery();
			long endTime = System.currentTimeMillis();
//			logger.debug("Time taken to retrieve price data " + (endTime - startTime));
//			logger.debug("Price Query executed");

			while (resultSet.next()) {
				CompetitiveDataDTO compDataDTO = new CompetitiveDataDTO();
				compDataDTO.itemcode = resultSet.getInt("ITEM_CODE");
				if (compDataDTO.itemcode == 0)
					continue;
				compDataDTO.retailerItemCode = resultSet.getString("RETAILER_ITEM_CODE");
				compDataDTO.weekStartDate = resultSet.getString("START_DATE");
				compDataDTO.regPrice = resultSet.getFloat("REG_PRICE");
				compDataDTO.regMPack = resultSet.getInt("REG_M_PACK");
				compDataDTO.regMPrice = resultSet.getFloat("REG_M_PRICE");
				compDataDTO.fSalePrice = resultSet.getFloat("SALE_PRICE");
				compDataDTO.saleMPack = resultSet.getInt("SALE_M_PACK");
				compDataDTO.fSaleMPrice = resultSet.getFloat("SALE_M_PRICE");
				compDataDTO.effRegRetailStartDate = resultSet.getString("EFF_REG_START_DATE");
				compDataDTO.lirId = resultSet.getInt("RET_LIR_ID");
				compDataDTO.checkDate = resultSet.getString("CHECK_DATETIME");
				priceData.put(compDataDTO.itemcode, compDataDTO);
			}
		} catch (SQLException e) {
			logger.error("Error while executing GET_COMP_PRICE_DATA " + e);
			throw new GeneralException("Error while executing GET_COMP_PRICE_DATA " + e);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}
		long endTime = System.currentTimeMillis();
		//logger.debug("Time taken to retrieve price data " + (endTime - startTime));
		return priceData;
	}

	/**
	 * Retrieves competition data from database
	 * 
	 * @param connection
	 * @param inputDTO
	 * @param weekStartDate
	 * @param maxDataLookupRange
	 * @return
	 * @throws GeneralException
	 */
	private HashMap<Integer, CompetitiveDataDTO> getCompPriceData(Connection connection, PRStrategyDTO inputDTO,
			String weekStartDate, int maxDataLookupRange, int rank, String productList) throws GeneralException {
		long startTime = System.currentTimeMillis();
		PreparedStatement statement = null;
		ResultSet resultSet = null;
		int productLevelId = inputDTO.getProductLevelId();
		int productId = inputDTO.getProductId();
		HashMap<Integer, CompetitiveDataDTO> priceData = new HashMap<Integer, CompetitiveDataDTO>();
		try {
			String query = new String(GET_COMP_PRICE_DATA);
			query = query.replaceAll("%QUERY_CONDITION%", getQueryCondition(productLevelId, productList));

			String compCondition = "";
			if (inputDTO.getLocationLevelId() == Constants.COMP_STORE_LIST_LEVEL_ID) {
				compCondition = " S.LOCATION_LEVEL_ID = " + inputDTO.getLocationLevelId() + " AND S.LOCATION_ID = "
						+ inputDTO.getLocationId();
			} else {
				compCondition = " S.COMP_STR_ID = " + inputDTO.getLocationId();
			}

			query = query.replaceAll("%COMP_CONDITION%", compCondition);

//			logger.debug("Comp Price Query " + query);
//			logger.debug("Query Parameters. 1--" + inputDTO.getLocationId() + ",2,3--" + weekStartDate + ",4--"
//					+ maxDataLookupRange + ",5--" + productLevelId + ",6--" + productId);
			statement = connection.prepareStatement(query);

			int counter = 0;
			// statement.setInt(++counter, inputDTO.getLocationId());
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekStartDate);
			statement.setInt(++counter, maxDataLookupRange);
			if (productLevelId > 1) {
				statement.setInt(++counter, productLevelId);
				if (productId > 0) {
					statement.setLong(++counter, productId);
				}
			} else if (productLevelId == 1) {
				statement.setLong(++counter, productId);
			}

			// 23rd March, logic change in getting previous comp price change
			// pick 2nd latest with in x weeks as previous comp price
			statement.setLong(++counter, rank);

			statement.setFetchSize(10000);
			resultSet = statement.executeQuery();
			long endTime = System.currentTimeMillis();
//			logger.debug("Time taken to retrieve price data " + (endTime - startTime));
//			logger.debug("Price Query executed");

			while (resultSet.next()) {
				CompetitiveDataDTO compDataDTO = new CompetitiveDataDTO();
				compDataDTO.itemcode = resultSet.getInt("ITEM_CODE");
				if (compDataDTO.itemcode == 0)
					continue;
				compDataDTO.retailerItemCode = resultSet.getString("RETAILER_ITEM_CODE");
				compDataDTO.weekStartDate = resultSet.getString("START_DATE");
				compDataDTO.regPrice = resultSet.getFloat("REG_PRICE");
				compDataDTO.regMPack = resultSet.getInt("REG_M_PACK");
				compDataDTO.regMPrice = resultSet.getFloat("REG_M_PRICE");
				compDataDTO.fSalePrice = resultSet.getFloat("SALE_PRICE");
				compDataDTO.saleMPack = resultSet.getInt("SALE_M_PACK");
				compDataDTO.fSaleMPrice = resultSet.getFloat("SALE_M_PRICE");
				compDataDTO.effRegRetailStartDate = resultSet.getString("EFF_REG_START_DATE");
				compDataDTO.lirId = resultSet.getInt("RET_LIR_ID");
				compDataDTO.checkDate = resultSet.getString("CHECK_DATETIME");
				priceData.put(compDataDTO.itemcode, compDataDTO);
			}
		} catch (SQLException e) {
			logger.error("Error while executing GET_COMP_PRICE_DATA " + e);
			throw new GeneralException("Error while executing GET_COMP_PRICE_DATA " + e);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}
		long endTime = System.currentTimeMillis();
		logger.debug("Time taken to retrieve price data " + (endTime - startTime));
		return priceData;
	}

	public void getMovementDataForZone(HashMap<Integer, HashMap<Integer, ProductMetricsDataDTO>> movementData,
			HashMap<ItemKey, PRItemDTO> inputMap, LinkedHashMap<Integer, RetailCalendarDTO> previousCalendarDetails,
			int noOfWeeksBehind) throws GeneralException {

		for (Map.Entry<Integer, HashMap<Integer, ProductMetricsDataDTO>> entry : movementData.entrySet()) {
			double avgRevenue = 0;
			double avgMovement = 0;
			int count = 0;
			int noOfWeeksCount = 1;
			ItemKey itemKey = new ItemKey(entry.getKey(), PRConstants.NON_LIG_ITEM_INDICATOR);
			HashMap<Integer, ProductMetricsDataDTO> movementHistoryData = entry.getValue();

			// Pick only last 13 weeks data
			//Added a config for AZ to use new method to calculate the average movement
			if (!substituteForPrediction.equalsIgnoreCase(PRConstants.LAST_YEAR_SIMILAR_WEEKS_MOVEMENT)) {
				for (RetailCalendarDTO retailCalendarDTO : previousCalendarDetails.values()) {
					if (noOfWeeksCount > noOfWeeksBehind) {
						break;
					} else {
						ProductMetricsDataDTO productMetricsDataDTO = movementHistoryData
								.get(retailCalendarDTO.getCalendarId());
						if (productMetricsDataDTO != null) {
							avgMovement = avgMovement + productMetricsDataDTO.getTotalMovement();
							avgRevenue = avgRevenue + productMetricsDataDTO.getTotalRevenue();
							count++;
						}
					}
					noOfWeeksCount++;
				}
				// Added By Karishma to fix issue for incorrect avg movement shown for items
			// having -ve units in current units
				// Condition change to check revenue and avgMovement !=0 instead of checking >0
				// since AZ has items where movement can be -negative
				if (avgRevenue != 0)
					avgRevenue = avgRevenue / count;
				if (avgMovement != 0)
					avgMovement = avgMovement / count;
			}

			if (inputMap.get(itemKey) != null) {
				PRItemDTO tDTO = inputMap.get(itemKey);
				if (!substituteForPrediction.equalsIgnoreCase(PRConstants.LAST_YEAR_SIMILAR_WEEKS_MOVEMENT)) {
					tDTO.setAvgMovement(avgMovement);
					tDTO.setAvgRevenue(avgRevenue);
				}
				tDTO.setLastXWeeksMovDetail(movementHistoryData);
				inputMap.put(itemKey, tDTO);
			}
		}
	}

	public HashMap<Integer, HashMap<Integer, ProductMetricsDataDTO>> getMovementDataForZone(Connection conn,
			PRStrategyDTO inputDTO, List<Integer> priceZoneStores, String startDate, int noOfWeeksBehind,
			HashMap<ItemKey, PRItemDTO> inputMap) throws GeneralException {
		Set<Integer> itemList = new HashSet<Integer>();
		for (PRItemDTO prItemDTO : inputMap.values()) {
			if (!prItemDTO.isLir())
				itemList.add(prItemDTO.getItemCode());
		}

		List<Integer> itemCodeList = new ArrayList<Integer>();
//		HashMap<Integer, List<MovementWeeklyDTO>> movementData = new HashMap<Integer, List<MovementWeeklyDTO>>();
		HashMap<Integer, HashMap<Integer, ProductMetricsDataDTO>> movementData = new HashMap<Integer, HashMap<Integer, ProductMetricsDataDTO>>();
		int limitcount = 0;

		for (Integer itemCode : itemList) {
			itemCodeList.add(itemCode);
			limitcount++;
			if (limitcount > 0 && (limitcount % this.commitCount == 0)) {
				Object[] values = itemCodeList.toArray();
				retrieveMovementDataForZone(conn, priceZoneStores, startDate, noOfWeeksBehind, movementData, inputDTO,
						values);
				itemCodeList.clear();
			}
		}
		if (itemCodeList.size() > 0) {
			Object[] values = itemCodeList.toArray();
			retrieveMovementDataForZone(conn, priceZoneStores, startDate, noOfWeeksBehind, movementData, inputDTO,
					values);
			itemCodeList.clear();
		}

		return movementData;
	}

//	public void retrieveMovementDataForZone(Connection connection, List<Integer> priceZoneStores, String weekStartDate, int maxDataLookupRange, 
//			HashMap<Integer, List<MovementWeeklyDTO>> movementData, Object...values) throws GeneralException{
//		long startTime = System.currentTimeMillis();
//		PreparedStatement statement = null;
//	    ResultSet resultSet = null;
//	    
//		try{
//			String query = new String(GET_MOVE_DATA_FOR_ZONE_FROM_IMS);
//			String storeIds = PRCommonUtil.getCommaSeperatedStringFromIntArray(priceZoneStores);
//			query = query.replaceAll("%PRICE_ZONE_STORES%", storeIds);
//			logger.debug("Movement Query " + query);
//			String items = "";
//			for(Object itemCode : values){
//				items = items + "," + (Integer) itemCode;
//			}
//			logger.debug("Parameters: 1-" + Constants.STORE_LEVEL_ID + ",2-" + Constants.ITEMLEVELID + ",3-" + 
//					weekStartDate + ",4-" + weekStartDate + ",5-" + maxDataLookupRange + ",6-" + items);
//			statement = connection.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));
//			
//			int counter = 0;
//			statement.setInt(++counter, Constants.STORE_LEVEL_ID);
//			statement.setInt(++counter, Constants.ITEMLEVELID);			
//			statement.setString(++counter,  weekStartDate);
//			statement.setString(++counter,  weekStartDate);
//			statement.setInt(++counter,  maxDataLookupRange);
//			PristineDBUtil.setValues(statement, 6, values);
//			statement.setFetchSize(100000);
//			resultSet = statement.executeQuery();
//			long endTimeTemp = System.currentTimeMillis();
//			logger.debug("Time taken by statement.executeQuery() " + (endTimeTemp - startTime));
//			logger.debug("Movement Query executed");
//			
//			while(resultSet.next()){
//				MovementWeeklyDTO movementWeeklyDTO = new MovementWeeklyDTO();
//				movementWeeklyDTO.setItemCode(resultSet.getInt("ITEM_CODE"));
//				if(movementWeeklyDTO.getItemCode() == 0)
//					continue;
//				movementWeeklyDTO.setWeekStartDate(resultSet.getString("START_DATE"));
//				movementWeeklyDTO.setregGrossRevenue(resultSet.getDouble("TOTAL_REVENUE"));
//				movementWeeklyDTO.setQuantityRegular(resultSet.getDouble("TOTAL_QUANTITY"));
//				if(movementData.get(movementWeeklyDTO.getItemCode()) != null){
//					List<MovementWeeklyDTO> tempList = movementData.get(movementWeeklyDTO.getItemCode());
//					tempList.add(movementWeeklyDTO);
//					movementData.put(movementWeeklyDTO.getItemCode(), tempList);
//				}else{
//					List<MovementWeeklyDTO> tempList = new ArrayList<MovementWeeklyDTO>();
//					tempList.add(movementWeeklyDTO);
//					movementData.put(movementWeeklyDTO.getItemCode(), tempList);
//				}
//			}
//		}
//		catch (SQLException e)
//		{
//			logger.error("Error while executing retrieveMovementDataForZone " + e);
//			throw new GeneralException("Error while executing retrieveMovementDataForZone " + e);
//		}
//		finally{
//			PristineDBUtil.close(resultSet);
//			PristineDBUtil.close(statement);
//		}
//		long endTime = System.currentTimeMillis();
//		logger.debug("Time taken to retrieve movement data " + (endTime - startTime));
//	}

	public void retrieveMovementDataForZone(Connection connection, List<Integer> priceZoneStores, String weekStartDate,
			int noOfWeeksBehind, HashMap<Integer, HashMap<Integer, ProductMetricsDataDTO>> movementData,
			PRStrategyDTO inputDTO, Object... values) throws GeneralException {
		long startTime = System.currentTimeMillis();
		PreparedStatement statement = null;
		ResultSet resultSet = null;

		try {
			String query = "";
			String imsSource = PropertyManager.getProperty("IMS_SOURCE", "STORE");
			if (imsSource.equals("STORE")) {
				query = new String(GET_MOVE_DATA_FOR_ZONE_FROM_IMS_STORE_TABLE);
				String storeIds = PRCommonUtil.getCommaSeperatedStringFromIntArray(priceZoneStores);
				query = query.replaceAll("%PRICE_ZONE_STORES%", storeIds);
			} else {
				query = new String(GET_MOVE_DATA_FOR_ZONE_FROM_IMS_ZONE_TABLE);
				query = query.replaceAll("%PRICE_ZONE_ID%", String.valueOf(inputDTO.getLocationId()));
			}

//			logger.debug("Movement Query " + query);
			String items = "";
			for (Object itemCode : values) {
				items = items + "," + (Integer) itemCode;
			}
//			logger.debug("Parameters: 1-" + weekStartDate + ",2-" + weekStartDate + ",3-" + noOfWeeksBehind + ",4-"
//					+ Constants.STORE_LEVEL_ID + ",5-" + Constants.ITEMLEVELID + ",6-" + items);
			statement = connection
					.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));

			int counter = values.length;
			PristineDBUtil.setValues(statement, 1, values);
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekStartDate);
			statement.setInt(++counter, noOfWeeksBehind);
//			statement.setInt(++counter, Constants.STORE_LEVEL_ID);
//			statement.setInt(++counter, Constants.ITEMLEVELID);	

			statement.setFetchSize(100000);
			resultSet = statement.executeQuery();
			long endTimeTemp = System.currentTimeMillis();
//			logger.debug("Time taken by statement.executeQuery() " + (endTimeTemp - startTime));
//			logger.debug("Movement Query executed");

			while (resultSet.next()) {
				HashMap<Integer, ProductMetricsDataDTO> movementMap = new HashMap<Integer, ProductMetricsDataDTO>();
				int calendarId = resultSet.getInt("CALENDAR_ID");
				ProductMetricsDataDTO productMetricsDataDTO = new ProductMetricsDataDTO();
				productMetricsDataDTO.setProductId(resultSet.getInt("ITEM_CODE"));
				if (productMetricsDataDTO.getProductId() == 0)
					continue;
				// movementWeeklyDTO.setWeekStartDate(resultSet.getString("START_DATE"));

				// NU::8th July 2017, for questionable predictions
				productMetricsDataDTO.setRegularQuantity(resultSet.getDouble("REG_M_PACK"));
				productMetricsDataDTO.setRegularPrice(resultSet.getDouble("REG_PRICE"));

				productMetricsDataDTO.setTotalRevenue(resultSet.getDouble("TOTAL_REVENUE"));
				productMetricsDataDTO.setTotalMovement(resultSet.getDouble("TOTAL_QUANTITY"));
				productMetricsDataDTO.setFinalPrice(resultSet.getDouble("FINAL_UNIT_PRICE"));
				productMetricsDataDTO.setSalePrice(resultSet.getDouble("SALE_PRICE"));
				productMetricsDataDTO.setSaleQuantity(resultSet.getInt("SALE_M_PACK"));
				if (movementData.get(productMetricsDataDTO.getProductId()) != null) {
					movementMap = movementData.get(productMetricsDataDTO.getProductId());
				}
				movementMap.put(calendarId, productMetricsDataDTO);
				movementData.put(productMetricsDataDTO.getProductId(), movementMap);
			}
		} catch (SQLException e) {
			logger.error("Error while executing retrieveMovementDataForZone " + e);
			throw new GeneralException("Error while executing retrieveMovementDataForZone " + e);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}
		long endTime = System.currentTimeMillis();
		//logger.debug("Time taken to retrieve movement data " + (endTime - startTime));
	}

	/**
	 * Retrieves avg revenue and movement for past weeks
	 * 
	 * @param conn
	 * @param inputDTO
	 * @return
	 * @throws GeneralException
	 */
	public void getMovementDataForStore(Connection conn, PRStrategyDTO inputDTO, RetailCalendarDTO calDTO,
			int noOfWeeksBehind, HashMap<Integer, HashMap<ItemKey, PRItemDTO>> inputMap,
			HashMap<Integer, HashMap<ItemKey, PRItemDTO>> inputMapNotInCache) throws GeneralException {

		for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : inputMapNotInCache.entrySet()) {
			// for(Map.Entry<Integer, PRItemDTO> inEntry :
			// entry.getValue().entrySet()){
			HashMap<ItemKey, PRItemDTO> inputMapForStore = inputMap.get(entry.getKey());

			Set<Integer> itemsInStore = new HashSet<Integer>();
			for (Map.Entry<ItemKey, PRItemDTO> storeItems : inputMapForStore.entrySet()) {
				if (!storeItems.getValue().isLir())
					itemsInStore.add(storeItems.getKey().getItemCodeOrRetLirId());
			}

			HashMap<Integer, List<MovementWeeklyDTO>> movementData = getMovementDataForStore(conn, inputDTO,
					entry.getKey(), calDTO.getStartDate(), noOfWeeksBehind * 7, itemsInStore);

			for (Map.Entry<Integer, List<MovementWeeklyDTO>> mEntry : movementData.entrySet()) {
				double avgRevenue = 0;
				double avgMovement = 0;
				int count = 0;
				for (MovementWeeklyDTO movDTO : mEntry.getValue()) {
					avgMovement = avgMovement + movDTO.getQuantityRegular();
					avgRevenue = avgRevenue + movDTO.getregGrossRevenue();
					count++;
				}
				if (avgRevenue > 0)
					avgRevenue = avgRevenue / count;
				if (avgMovement > 0)
					avgMovement = avgMovement / count;

				ItemKey itemKey = new ItemKey(mEntry.getKey(), PRConstants.NON_LIG_ITEM_INDICATOR);

				if (inputMapForStore.get(itemKey) != null) {
					PRItemDTO tDTO = inputMapForStore.get(itemKey);
					tDTO.setAvgMovement(avgMovement);
					tDTO.setAvgRevenue(avgRevenue);
				}
			}
			// }
		}
	}

	private HashMap<Integer, List<MovementWeeklyDTO>> getMovementDataForStore(Connection conn, PRStrategyDTO inputDTO,
			Integer compStrId, String startDate, int noOfWeeksBehind, Set<Integer> itemCodeSet)
			throws GeneralException {
		List<Integer> itemCodeList = new ArrayList<Integer>();
		HashMap<Integer, List<MovementWeeklyDTO>> movementData = new HashMap<Integer, List<MovementWeeklyDTO>>();
		int limitcount = 0;

		for (Integer itemCode : itemCodeSet) {
			itemCodeList.add(itemCode);
			limitcount++;
			if (limitcount > 0 && (limitcount % this.commitCount == 0)) {
				Object[] values = itemCodeList.toArray();
				retrieveMovementDataForStore(conn, compStrId, startDate, noOfWeeksBehind, movementData, values);
				itemCodeList.clear();
			}
		}
		if (itemCodeList.size() > 0) {
			Object[] values = itemCodeList.toArray();
			retrieveMovementDataForStore(conn, compStrId, startDate, noOfWeeksBehind, movementData, values);
			itemCodeList.clear();
		}

		// retrieveMovementDataForStore(conn, compStrId, startDate,
		// noOfWeeksBehind, movementData, inputDTO.getProductLevelId(),
		// inputDTO.getProductId());

		return movementData;
	}

	public void retrieveMovementDataForStore(Connection connection, int compStrId, String weekStartDate,
			int maxDataLookupRange, HashMap<Integer, List<MovementWeeklyDTO>> movementData, Object... values)
			throws GeneralException {
		long startTime = System.currentTimeMillis();
		PreparedStatement statement = null;
		ResultSet resultSet = null;

		try {
			// String query = new String(GET_MOVEMENT_DATA_FOR_STORE);
			String query = new String(GET_MOVE_DATA_FOR_STORE_FROM_IMS);

//			logger.debug("Movement Query " + query);

			statement = connection
					.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));

			// query = query.replaceAll("%QUERY_CONDITION%",
			// getQueryCondition(productLevelId, productId));

			int counter = 0;
			statement.setInt(++counter, compStrId);
			statement.setInt(++counter, Constants.STORE_LEVEL_ID);
			statement.setInt(++counter, Constants.ITEMLEVELID);
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekStartDate);
			statement.setInt(++counter, maxDataLookupRange);
			// statement.setInt(++counter, 140);
			PristineDBUtil.setValues(statement, 7, values);
			/*
			 * if (productLevelId > 1) { statement.setInt(++counter, productLevelId); if
			 * (productId > 0) { statement.setLong(++counter, productId); } } else if
			 * (productLevelId == 1) { statement.setLong(++counter, productId); }
			 */
			statement.setFetchSize(100000);
			resultSet = statement.executeQuery();
			long endTimeTemp = System.currentTimeMillis();
//			logger.debug("Time taken by statement.executeQuery() " + (endTimeTemp - startTime));
//			logger.debug("Movement Query executed");

			while (resultSet.next()) {
				MovementWeeklyDTO movementWeeklyDTO = new MovementWeeklyDTO();
				movementWeeklyDTO.setItemCode(resultSet.getInt("ITEM_CODE"));
				if (movementWeeklyDTO.getItemCode() == 0)
					continue;
				// movementWeeklyDTO.setLirId(resultSet.getInt("RET_LIR_ID"));
				movementWeeklyDTO.setWeekStartDate(resultSet.getString("START_DATE"));
				movementWeeklyDTO.setListCost(resultSet.getFloat("LIST_COST"));
				// movementWeeklyDTO.setEffListCostDate(resultSet.getString("EFF_LIST_COST_DATE"));
				movementWeeklyDTO.setregGrossRevenue(resultSet.getDouble("TOTAL_REVENUE"));
				movementWeeklyDTO.setQuantityRegular(resultSet.getDouble("TOTAL_QUANTITY"));
				if (movementData.get(movementWeeklyDTO.getItemCode()) != null) {
					List<MovementWeeklyDTO> tempList = movementData.get(movementWeeklyDTO.getItemCode());
					tempList.add(movementWeeklyDTO);
					movementData.put(movementWeeklyDTO.getItemCode(), tempList);
				} else {
					List<MovementWeeklyDTO> tempList = new ArrayList<MovementWeeklyDTO>();
					tempList.add(movementWeeklyDTO);
					movementData.put(movementWeeklyDTO.getItemCode(), tempList);
				}
			}
		} catch (SQLException e) {
			logger.error("Error while executing GET_MOVEMENT_DATA_FOR_STORE " + e);
			throw new GeneralException("Error while executing GET_MOVEMENT_DATA_FOR_STORE " + e);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}
		long endTime = System.currentTimeMillis();
		logger.debug("Time taken to retrieve movement data " + (endTime - startTime));
	}

	public HashMap<Integer, Integer> getCompetitors(Connection conn, PRStrategyDTO inputDTO) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		String sql = null;
		HashMap<Integer, Integer> compTypeMap = null;
		if (inputDTO.getLocationLevelId() == Constants.STORE_LEVEL_ID) {
			sql = GET_STORE_COMPETITORS;
		} else {
			sql = GET_ZONE_COMPETITORS;
		}

		try {
			stmt = conn.prepareStatement(sql);
			stmt.setInt(1, inputDTO.getLocationId());
			rs = stmt.executeQuery();
			if (rs.next()) {
				compTypeMap = new HashMap<Integer, Integer>();
				compTypeMap.put(PRConstants.COMP_TYPE_1, rs.getInt("PRIMARY_COMP_STR_ID"));
				compTypeMap.put(PRConstants.COMP_TYPE_2, rs.getInt("SECONDARY_COMP_STR_ID_1"));
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving competitors - " + exception.toString());
			throw new GeneralException("Error when retrieving competitors - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}

		return compTypeMap;
	}

	public long insertRecommendationHeader(Connection conn, int calendarId, PRStrategyDTO strategy)
			throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		long runId = -1;
		try {
			stmt = conn.prepareStatement(GET_RECOMMENDATION_RUN_ID);
			rs = stmt.executeQuery();
			if (rs.next()) {
				runId = rs.getLong("RUN_ID");
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving recommendation run id - " + exception.toString());
			throw new GeneralException("Error when retrieving recommendation run id - " + exception.toString());
		}

		PristineDBUtil.close(rs);
		PristineDBUtil.close(stmt);

		try {
			stmt = conn.prepareStatement(INSERT_RECOMMENDATION_HEADER);
			int counter = 0;
			stmt.setLong(++counter, runId);
			stmt.setInt(++counter, calendarId);
			stmt.setInt(++counter, strategy.getLocationLevelId());
			stmt.setInt(++counter, strategy.getLocationId());
			stmt.setInt(++counter, strategy.getProductLevelId());
			stmt.setInt(++counter, strategy.getProductId());
			stmt.setString(++counter, String.valueOf(strategy.getRunType()));
			stmt.setString(++counter, strategy.getPredictedBy());
			stmt.executeUpdate();
		} catch (SQLException exception) {
			logger.error("Error when inserting recommendation header - " + exception.toString());
			throw new GeneralException("Error when inserting recommendation header - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return runId;
	}

	public void insertRecommendationItems(Connection conn, List<PRItemDTO> itemList) throws GeneralException {
		PreparedStatement stmt = null;
//		DecimalFormat df = new DecimalFormat("######.##");
//		logger.debug("No of items " + itemList.size());
		ObjectMapper mapper = new ObjectMapper();
		String explainLogAsJson = "";
		try {
			stmt = conn.prepareStatement(INSERT_RECOMMENDATION_ITEM);
			int itemNoInBatch = 0;
			for (PRItemDTO item : itemList) {
				// logger.debug("Item Details: " + item.toString());
				explainLogAsJson = "";
				int counter = 0;
				stmt.setLong(++counter, item.getRunId());
//	        	if(item.isLir()) {
//	        		//logger.debug("Ret Lir Item Code: " + item.getRetLirItemCode());
//	        		stmt.setInt(++counter, item.getRetLirItemCode());
//	        	}
//	        	else {
//	        		//logger.debug("Item Code: " + item.getItemCode());
//	        		stmt.setInt(++counter, item.getItemCode());
//	        	}
				stmt.setInt(++counter, item.getItemCode());
				stmt.setLong(++counter, item.getStrategyId());
				if (item.getPriceCheckListId() != null)
					stmt.setInt(++counter, item.getPriceCheckListId());
				else
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				if (item.getPredictedMovement() != null)
					stmt.setDouble(++counter, item.getPredictedMovement());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				if (item.getRegMPack() != null && item.getRegMPack() > 0) {
					stmt.setInt(++counter, item.getRegMPack());
					if (item.getRegMPack() > 1)
						stmt.setDouble(++counter, item.getRegMPrice());
					else
						stmt.setDouble(++counter, item.getRegPrice());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				}
				if (item.getListCost() != null) {
					stmt.setDouble(++counter, item.getListCost());
					stmt.setString(++counter, item.getListCostEffDate());
				} else {
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
					stmt.setString(++counter, "");
				}
				if (item.getVipCost() != null)
					stmt.setDouble(++counter, item.getVipCost());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);

				// stmt.setDouble(++counter, item.getCompPrice());
				if (item.getCompPrice() != null) {
					stmt.setInt(++counter, item.getCompPrice().multiple);
					stmt.setDouble(++counter, item.getCompPrice().price);
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				}

				stmt.setInt(++counter, item.getCompTypeId());
				if (item.getCompStrId() != null) {
					stmt.setInt(++counter, item.getCompStrId().getLocationId());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				/*
				 * if(item.getRecommendedRegMultiple() != null) stmt.setInt(++counter,
				 * item.getRecommendedRegMultiple()); else stmt.setNull(++counter,
				 * java.sql.Types.INTEGER); if(item.getRecommendedRegPrice() != null)
				 * stmt.setDouble(++counter, item.getRecommendedRegPrice()); else
				 * stmt.setNull(++counter, java.sql.Types.DOUBLE);
				 */

				if (item.getRecommendedRegPrice() != null) {
					stmt.setInt(++counter, item.getRecommendedRegPrice().multiple);
					stmt.setDouble(++counter, item.getRecommendedRegPrice().price);
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				}

				stmt.setDouble(++counter, item.getAvgMovement());
				stmt.setDouble(++counter, item.getAvgRevenue());
				stmt.setInt(++counter, item.getCostChgIndicator());
				stmt.setInt(++counter, item.getCompPriceChgIndicator());

				try {
					explainLogAsJson = mapper.writeValueAsString(item.getExplainLog());
				} catch (JsonProcessingException e) {
					explainLogAsJson = "";
					logger.error(
							"Error when converting explain log to json string - " + item.getItemCode() + e.toString());
				}
				stmt.setString(++counter, explainLogAsJson);

				stmt.setInt(++counter, item.getIsPrePriced());
				stmt.setInt(++counter, item.getIsLocPriced());
				/*
				 * if(item.getRecommendedRegPrice() != null){ if(item.getRegPrice() != null){
				 * Double tRegPrice = new Double(df.format(item.getRegPrice())); Double
				 * tRecPrice = new Double(df.format(item.getRecommendedRegPrice()));
				 * if(tRegPrice.doubleValue() != tRecPrice.doubleValue()){
				 * item.setIsNewPriceRecommended(1); } }else{
				 * if(item.getRecommendedRegPrice().doubleValue() > 0)
				 * item.setIsNewPriceRecommended(1); } }
				 */
//	        	if(isNewPriceRecommended(item, df))
//	        		item.setIsNewPriceRecommended(1);

				stmt.setString(++counter, item.getIsMarkedForReview());
				stmt.setInt(++counter, item.getIsNewPriceRecommended());
				stmt.setString(++counter, item.getCompPriceCheckDate());
				stmt.setInt(++counter, item.getIsConflict());
				stmt.setInt(++counter, item.getChildLocationLevelId());
				stmt.setInt(++counter, item.getChildLocationId());
				if (item.getPreRegPrice() != null)
					stmt.setDouble(++counter, item.getPreRegPrice());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				if (item.getPreListCost() != null)
					stmt.setDouble(++counter, item.getPreListCost());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				if (item.getCompPreviousPrice() != null)
					stmt.setDouble(++counter, PRCommonUtil.getUnitPrice(item.getCompPreviousPrice(), true));
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				stmt.setString(++counter, String.valueOf(item.getDistFlag()));
				// Changes to store opportunities
				stmt.setString(++counter, item.getIsOppurtunity());
				if (item.getOppurtunityPrice() != null)
					stmt.setDouble(++counter, item.getOppurtunityPrice());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				if (item.getOppurtunityQty() != null)
					stmt.setInt(++counter, item.getOppurtunityQty());
				else
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				if (item.getOppurtunityMovement() != null)
					stmt.setDouble(++counter, item.getOppurtunityMovement());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				// Changes to store opportunities - Ends
				// Change to update prediction status
				if (item.getPredictionStatus() != null)
					stmt.setInt(++counter, item.getPredictionStatus());
				else
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				// Change to update prediction status - Ends

				if (item.getCurRegPricePredictedMovement() != null)
					// 12th Apr 2016, don't round predicted movement
					// stmt.setDouble(++counter,
					// Math.round(item.getCurRegPricePredictedMovement()));
					// stmt.setDouble(++counter, item.getCurRegPricePredictedMovement());
					stmt.setDouble(++counter, item.getCurRegPricePredictedMovement());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);

				if (item.getPreVipCost() != null)
					stmt.setDouble(++counter, item.getPreVipCost());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);

				stmt.setInt(++counter, item.getVipCostChgIndicator());

				if (item.getItemSize() > 0) {
					stmt.setDouble(++counter, item.getItemSize());
				} else {
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				}

				stmt.setString(++counter, item.getUOMId());

				if (item.getIsZoneAndStorePriceSame() != null) {
					if (item.getIsZoneAndStorePriceSame())
						stmt.setString(++counter, String.valueOf(Constants.YES));
					else
						stmt.setString(++counter, String.valueOf(Constants.NO));
				} else {
					stmt.setNull(++counter, java.sql.Types.CHAR);
				}

				if (item.getVendorId() > 0)
					stmt.setInt(++counter, item.getVendorId());
				else
					stmt.setNull(++counter, java.sql.Types.INTEGER);

				if (item.getPriceCheckListTypeId() != null)
					stmt.setInt(++counter, item.getPriceCheckListTypeId());
				else
					stmt.setNull(++counter, java.sql.Types.INTEGER);

				if (item.isLir())
					stmt.setString(++counter, String.valueOf(Constants.YES));
				else
					stmt.setString(++counter, String.valueOf(Constants.NO));

				stmt.setInt(++counter, item.getItemCode());

				if (item.getIsRecError())
					stmt.setString(++counter, String.valueOf(Constants.YES));
				else
					stmt.setString(++counter, String.valueOf(Constants.NO));

				stmt.setString(++counter, PRCommonUtil.getCommaSeperatedStringFromIntArray(item.getRecErrorCodes()));

				if (item.getIsCurRetailSameAcrossStores())
					stmt.setString(++counter, String.valueOf(Constants.YES));
				else
					stmt.setString(++counter, String.valueOf(Constants.NO));

				/*
				 * logger.debug("Item Details: Run Id: " + item.getRunId() + ",Loc Level Id:" +
				 * item.getChildLocationLevelId() + ",Location Id:" + item.getChildLocationId()
				 * + ",Item Code:" + item.getItemCode() + ",Lir Indicator:" + item.isLir());
				 */

				stmt.setInt(++counter, item.getPriceZoneId());

				if (item.getIsPartOfSubstituteGroup())
					stmt.setString(++counter, String.valueOf(Constants.YES));
				else
					stmt.setString(++counter, String.valueOf(Constants.NO));

				if (item.getPredMovWOSubsEffect() != null)
					// 12th Apr 2016, don't round predicted movement
					// stmt.setDouble(++counter, Math.round(item.getPredMovWOSubsEffect()));
					stmt.setDouble(++counter, item.getPredMovWOSubsEffect());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);

				if (item.getCurRegPredMovWOSubsEffect() != null)
					// 12th Apr 2016, don't round predicted movement
					// stmt.setDouble(++counter, Math.round(item.getCurRegPredMovWOSubsEffect()));
					stmt.setDouble(++counter, item.getCurRegPredMovWOSubsEffect());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);

//	        	stmt.setDouble(++counter, Math.round(item.getCurRetailSalesDollar()));
//	        	stmt.setDouble(++counter, Math.round(item.getCurRetailMarginDollar()));
//	        	stmt.setDouble(++counter, Math.round(item.getRecRetailSalesDollar()));
//	        	stmt.setDouble(++counter, Math.round(item.getRecRetailMarginDollar()));

				stmt.setDouble(++counter, item.getCurRetailSalesDollar());
				stmt.setDouble(++counter, item.getCurRetailMarginDollar());
				stmt.setDouble(++counter, item.getRecRetailSalesDollar());
				stmt.setDouble(++counter, item.getRecRetailMarginDollar());

				if (item.getIsIncludeForSummaryCalculation())
					stmt.setString(++counter, String.valueOf(Constants.YES));
				else
					stmt.setString(++counter, String.valueOf(Constants.NO));

				stmt.setString(++counter, item.getCurRegPriceEffDate());

//	        	if(item.getCurSaleMultiplePrice() != null) {
//	        		stmt.setInt(++counter, item.getCurSaleMultiplePrice().multiple);
//	        		stmt.setDouble(++counter, item.getCurSaleMultiplePrice().price);
//	        	} else {
//	        		stmt.setNull(++counter, java.sql.Types.INTEGER);
//	        		stmt.setNull(++counter, java.sql.Types.DOUBLE);
//	        	}
//	        	
//	        	if (item.getPromoTypeId() > 0) {
//					stmt.setInt(++counter, item.getPromoTypeId());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}
//				stmt.setString(++counter, item.getCurSaleEffectiveStartDate());
//				stmt.setString(++counter, item.getCurSaleEffectiveEndDate());
//				stmt.setString(++counter, item.getWeeklyAdStartDate());
//				
//				if (item.getPageNumber() > 0) {
//					stmt.setInt(++counter, item.getPageNumber());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}
//
//				if (item.getBlockNumber() > 0) {
//					stmt.setInt(++counter, item.getBlockNumber());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}
//
//				if(item.getDisplayTypeId() != null) {
//					stmt.setInt(++counter, item.getDisplayTypeId());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}

				// "CUR_COMP_SALE_MULTIPLE, CUR_COMP_SALE_PRICE, " +
				if (item.getCompCurSalePrice() != null) {
					stmt.setInt(++counter, item.getCompCurSalePrice().multiple);
					stmt.setDouble(++counter, item.getCompCurSalePrice().price);
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				}

				// "CUR_SALE_MULTIPLE, CUR_SALE_PRICE,CUR_SALE_PROMO_TYPE_ID,
				// CUR_SALE_PRED_MOV, CUR_SALE_PRED_STATUS,CUR_SALE_COST "
//				if (item.getCurSaleInfo().getSalePrice() != null) {
//					stmt.setInt(++counter, item.getCurSaleInfo().getSalePrice().multiple);
//					stmt.setDouble(++counter, item.getCurSaleInfo().getSalePrice().price);
//					stmt.setInt(++counter, item.getCurSaleInfo().getSalePromoTypeLookup().getPromoTypeId());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//					stmt.setNull(++counter, java.sql.Types.DOUBLE);
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}

//				if (item.getCurSaleInfo().getSalePredStatus() != null) {
//					stmt.setDouble(++counter, item.getCurSaleInfo().getSalePredMov());
//					stmt.setInt(++counter, item.getCurSaleInfo().getSalePredStatus().getStatusCode());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.DOUBLE);
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}

//				if (item.getCurSaleInfo().getSaleCost() != null) {
//					stmt.setDouble(++counter, item.getCurSaleInfo().getSaleCost());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.DOUBLE);
//				}

				// "REC_WEEK_SALE_MULTIPLE, REC_WEEK_SALE_PRICE,
				// REC_WEEK_PROMO_TYPE_ID, REC_WEEK_SALE_START_DATE, " +
				// "REC_WEEK_SALE_END_DATE, REC_WEEK_SALE_PRED_MOV,
				// REC_WEEK_SALE_PRED_STATUS, REC_WEEK_SALE_COST " +

				PRItemSaleInfoDTO recWeekSaleInfo = null;
				if (item.isFuturePromotion()) {
					recWeekSaleInfo = item.getFutWeekSaleInfo();
				} else {
					recWeekSaleInfo = item.getRecWeekSaleInfo();
				}
				if (recWeekSaleInfo.getSalePrice() != null) {
					stmt.setInt(++counter, recWeekSaleInfo.getSalePrice().multiple);
					stmt.setDouble(++counter, recWeekSaleInfo.getSalePrice().price);
					stmt.setInt(++counter, recWeekSaleInfo.getPromoTypeId());
					stmt.setString(++counter, recWeekSaleInfo.getSaleStartDate());
					stmt.setString(++counter, recWeekSaleInfo.getSaleEndDate());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setString(++counter, null);
					stmt.setString(++counter, null);
				}

				if (recWeekSaleInfo.getSalePredStatusAtCurReg() != null) {
					if (recWeekSaleInfo.getSalePredMovAtCurReg() != null) {
						stmt.setDouble(++counter, recWeekSaleInfo.getSalePredMovAtCurReg());
					} else {
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					}
					stmt.setInt(++counter, recWeekSaleInfo.getSalePredStatusAtCurReg().getStatusCode());
				} else {
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				if (recWeekSaleInfo.getSalePredStatusAtRecReg() != null) {
					if (recWeekSaleInfo.getSalePredMovAtRecReg() != null) {
						stmt.setDouble(++counter, recWeekSaleInfo.getSalePredMovAtRecReg());
					} else {
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					}
					stmt.setInt(++counter, recWeekSaleInfo.getSalePredStatusAtRecReg().getStatusCode());
				} else {
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				if (item.getRecWeekSaleCost() != null) {
					stmt.setDouble(++counter, item.getRecWeekSaleCost());
				} else {
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				}

				// "FUT_WEEK_SALE_MULTIPLE, FUT_WEEK_SALE_PRICE, FUT_WEEK_PROMO_TYPE_ID,
				// FUT_WEEK_SALE_START_DATE, FUT_WEEK_SALE_END_DATE " +
				if (item.getFutWeekSaleInfo().getSalePrice() != null) {
					stmt.setInt(++counter, item.getFutWeekSaleInfo().getSalePrice().multiple);
					stmt.setDouble(++counter, item.getFutWeekSaleInfo().getSalePrice().price);
					stmt.setInt(++counter, item.getFutWeekSaleInfo().getPromoTypeId());
					stmt.setString(++counter, item.getFutWeekSaleInfo().getSaleStartDate());
					stmt.setString(++counter, item.getFutWeekSaleInfo().getSaleEndDate());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setString(++counter, null);
					stmt.setString(++counter, null);
				}

				// "CUR_AD_PAGE_NO, CUR_AD_BLOCK_NO,
//				if(item.getCurAdInfo().getAdPageNo() > 0) {
//					stmt.setInt(++counter, item.getCurAdInfo().getAdPageNo());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}
//				
//				if(item.getCurAdInfo().getAdBlockNo() > 0) {
//					stmt.setInt(++counter,  item.getCurAdInfo().getAdBlockNo());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}

				// REC_WEEK_AD_PAGE_NO, REC_WEEK_AD_BLOCK_NO, " +
				if (item.getRecWeekAdInfo().getAdPageNo() > 0) {
					stmt.setInt(++counter, item.getRecWeekAdInfo().getAdPageNo());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				if (item.getRecWeekAdInfo().getAdBlockNo() > 0) {
					stmt.setInt(++counter, item.getRecWeekAdInfo().getAdBlockNo());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				// FUT_WEEK_AD_START_DATE, FUT_WEEK_AD_PAGE_NO, FUT_WEEK_AD_BLOCK_NO " +
				stmt.setString(++counter, item.getFutWeekAdInfo().getWeeklyAdStartDate());

				if (item.getFutWeekAdInfo().getAdPageNo() > 0) {
					stmt.setInt(++counter, item.getFutWeekAdInfo().getAdPageNo());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				if (item.getFutWeekAdInfo().getAdBlockNo() > 0) {
					stmt.setInt(++counter, item.getFutWeekAdInfo().getAdBlockNo());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				// "CUR_DISPLAY_TYPE_ID,
//				if(item.getCurDisplayInfo().getDisplayTypeLookup() != null && item.getCurDisplayInfo().getDisplayTypeLookup().getDisplayTypeId() > 0) {
//					stmt.setInt(++counter, item.getCurDisplayInfo().getDisplayTypeLookup().getDisplayTypeId());
//				} else {
//					stmt.setNull(++counter, java.sql.Types.INTEGER);
//				}

				// REC_WEEK_DISPLAY_TYPE_ID,
				if (item.getRecWeekDisplayInfo().getDisplayTypeLookup() != null
						&& item.getRecWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId() > 0) {
					stmt.setInt(++counter, item.getRecWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				// FUT_WEEK_DISPLAY_START_DATE, FUT_WEEK_DISPLAY_TYPE_ID " +
				stmt.setString(++counter, item.getFutWeekDisplayInfo().getDisplayWeekStartDate());

				if (item.getFutWeekDisplayInfo().getDisplayTypeLookup() != null
						&& item.getFutWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId() > 0) {
					stmt.setInt(++counter, item.getFutWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId());
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				}

				// "IS_TPR, IS_SALE, IS_AD " +
				stmt.setInt(++counter, item.getIsTPR());
				stmt.setInt(++counter, item.getIsOnSale());
				stmt.setInt(++counter, item.getIsOnAd());

				stmt.setString(++counter, item.getRecPriceEffectiveDate());

				if (item.getFutureRecRetail() != null) {
					stmt.setInt(++counter, item.getFutureRecRetail().multiple);
					stmt.setDouble(++counter, item.getFutureRecRetail().price);
				} else {
					stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				}

				stmt.setInt(++counter, item.getLigRepItemCode());

				// Dinesh ::02/08/2018 - Code changes to handle duplicate values and to remove
				// unwanted commas
				if (item.getRegPricePredReasons() != null && !item.getRegPricePredReasons().trim().isEmpty()) {
					String[] quesPred = item.getRegPricePredReasons().split(",");
					Set<String> tempSet = Arrays.stream(quesPred).collect(Collectors.toSet());
					String quesPredReasons = tempSet.stream().filter(val -> val.trim() != null && !val.trim().isEmpty())
							.collect(Collectors.joining(","));
					stmt.setString(++counter, quesPredReasons);
				} else {
					stmt.setString(++counter, item.getRegPricePredReasons());
				}
				stmt.setString(++counter, item.getSalePricePredReasons());

				stmt.addBatch();
				itemNoInBatch++;

				if (itemNoInBatch % Constants.BATCH_UPDATE_COUNT == 0) {
					stmt.executeBatch();
					stmt.clearBatch();
					itemNoInBatch = 0;
				}
			}
			if (itemNoInBatch > 0) {
				stmt.executeBatch();
				stmt.clearBatch();
			}
			// updateRecommendationRunHeader(conn, runId);
		} catch (SQLException exception) {
			logger.error("Error when inserting recommendation items - " + exception.toString());
			throw new GeneralException("Error when inserting recommendation items - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

//	private boolean isNewPriceRecommended(PRItemDTO item, DecimalFormat df) {
//		boolean isNewPriceRecommended = false;
//
//		if (item.getRecommendedRegPrice() != null) {
//			if (item.getRegPrice() != null) {
//				Double tRegPrice = new Double(df.format(item.getRegPrice()));
//				Double tRecPrice = new Double(df.format(item.getRecommendedRegPrice()));
//				Integer tRegMultiple = 1;
//				Integer tRecMultiple = item.getRecommendedRegMultiple() == null ? 1 : item.getRecommendedRegMultiple();
//
//				// if recommended price is in multiples, then check against
//				// regmprice (pre-price/loc-price)
//				if (item.getRegMPack() != null && item.getRegMPack() > 1 && item.getRegMPrice() != null
//						&& item.getRegMPrice() > 0) {
//					tRegMultiple = item.getRegMPack();
//					tRegPrice = item.getRegMPrice();
//				}
//
//				// if (tRegPrice.doubleValue() != tRecPrice.doubleValue() &&
//				// tRegMultiple != tRecMultiple) {
//				if (!(tRegPrice.doubleValue() == tRecPrice.doubleValue() && tRegMultiple == tRecMultiple)) {
//					isNewPriceRecommended = true;
//				}
//			} else {
//				if (item.getRecommendedRegPrice().doubleValue() > 0)
//					isNewPriceRecommended = true;
//			}
//		}
//		return isNewPriceRecommended;
//	}

	public void updateRecommendationRunHeader(Connection conn, long runId, String runStatus) throws GeneralException {
		PreparedStatement stmt = null;
		try {
			if (PRConstants.RUN_STATUS_SUCCESS.equals(runStatus)) {
				stmt = conn.prepareStatement(UPDATE_RECOMMENDATION_HEADER);
			} else {
				stmt = conn.prepareStatement(UPDATE_RECOMMENDATION_HEADER_STATUS);
			}
			stmt.setString(1, runStatus);
			if (PRConstants.RUN_STATUS_SUCCESS.equals(runStatus))
				stmt.setInt(2, 1);
			else
				stmt.setInt(2, 5);
			stmt.setLong(3, runId);
			stmt.executeUpdate();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendation run header - " + exception.toString());
			throw new GeneralException("Error when updating recommendation run header - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	private String logInsertRecomendationItem(PRItemDTO itemDTO, ObjectMapper mapper) {
		StringBuilder builder = new StringBuilder();

		builder.append(
				" INSERT INTO PR_RECOMMENDATION (RUN_ID, ITEM_CODE, STRATEGY_ID, PRICE_CHECK_LIST_ID, PREDICTED_MOVEMENT, ");
		builder.append("CUR_REG_MULTIPLE, CUR_REG_PRICE, CUR_LIST_COST, CUR_LIST_COST_EFF_DATE, CUR_VIP_COST, ");
		builder.append("CUR_COMP_REG_MULTIPLE, CUR_COMP_REG_PRICE, ");
		builder.append(
				"COMP_LOCATION_TYPES_ID, COMP_STR_ID, RECOMMENDED_REG_MULTIPLE, RECOMMENDED_REG_PRICE, AVG_MOVEMENT, AVG_REVENUE, ");
		builder.append(
				"COST_CHG_IND, COMP_PRICE_CHG_IND, LOG, IS_PRE_PRICED, IS_LOCKED_PRICE, IS_MARKED_FOR_REVIEW, IS_PRICE_RECOMMENDED, ");
		builder.append(
				"COMP_PRICE_CHECK_DATE, IS_CONFLICT, CHILD_LOCATION_LEVEL_ID, CHILD_LOCATION_ID, PRE_REG_PRICE, PRE_LIST_COST, ");
		builder.append(
				"PRE_COMP_REG_PRICE, DIST_FLAG, IS_OPPORTUNITY, OPPORTUNITY_PRICE, OPPORTUNITY_QUANTITY, OPPORTUNITY_MOVEMENT, PREDICTION_STATUS, ");
		builder.append(
				"CUR_REG_PRICE_PREDICTED_MOV, PRE_VIP_COST, VIP_COST_CHG_IND, ITEM_SIZE, UOM_ID, IS_STORE_PRICE_SAME,");
		builder.append(
				"VENDOR_ID, PRICE_CHECK_LIST_TYPE_ID, LIR_IND, LIR_ID_OR_ITEM_CODE, IS_REC_ERROR, REC_ERROR_CODE,");
		builder.append(
				"IS_CUR_RET_SAME_IN_ALL_STORES, ACTUAL_ZONE_ID, IS_SUBSTITUTE, PRED_MOV_WO_SUBS_EFFECT, CUR_REG_PRED_MOV_WO_SUBS_EFT,");
		builder.append(
				"CUR_SALES_D,CUR_MARGIN_D,REC_SALES_D,REC_MARGIN_D,IS_INCLUDE_FOR_SUM_CAL,CUR_REG_PRICE_EFF_DATE,");
		builder.append("CUR_COMP_SALE_MULTIPLE, CUR_COMP_SALE_PRICE, ");
		builder.append(
				"REC_WEEK_SALE_MULTIPLE, REC_WEEK_SALE_PRICE, REC_WEEK_PROMO_TYPE_ID, REC_WEEK_SALE_START_DATE,  ");
		builder.append("REC_WEEK_SALE_END_DATE, REC_WEEK_SALE_PRED_AT_CUR_REG, REC_WEEK_SALE_PRED_STATUS_CUR, ");
		builder.append("REC_WEEK_SALE_PRED_AT_REC_REG,REC_WEEK_SALE_PRED_STATUS_REC,");
		builder.append("REC_WEEK_SALE_COST,  ");
		builder.append(
				"FUT_WEEK_SALE_MULTIPLE, FUT_WEEK_SALE_PRICE, FUT_WEEK_PROMO_TYPE_ID, FUT_WEEK_SALE_START_DATE, FUT_WEEK_SALE_END_DATE,  ");
		builder.append("REC_WEEK_AD_PAGE_NO, REC_WEEK_AD_BLOCK_NO, ");
		builder.append("FUT_WEEK_AD_START_DATE, FUT_WEEK_AD_PAGE_NO, FUT_WEEK_AD_BLOCK_NO,  ");
		builder.append("REC_WEEK_DISPLAY_TYPE_ID, FUT_WEEK_DISPLAY_START_DATE, FUT_WEEK_DISPLAY_TYPE_ID,  ");
		builder.append("IS_TPR, IS_SALE, IS_AD,");
		builder.append("REG_EFF_DATE, ");
		builder.append("REC_FUT_REG_MULTIPLE, REC_FUT_REG_PRICE ");
		builder.append(",LIG_REP_ITEM_CODE , REC_REG_PRED_REASONS, REC_SALE_PRED_REASONS ");
		builder.append(")");
		builder.append("VALUES(");

		builder.append(itemDTO.getRunId());
		builder.append("," + itemDTO.getItemCode());
		builder.append("," + itemDTO.getStrategyId());

		if (itemDTO.getPriceCheckListId() != null)
			builder.append("," + itemDTO.getPriceCheckListId());
		else
			builder.append("," + "NULL");

		if (itemDTO.getPredictedMovement() != null)
			builder.append("," + itemDTO.getPredictedMovement());
		else
			builder.append("," + "NULL");

		if (itemDTO.getRegMPack() != null && itemDTO.getRegMPack() > 0) {
			builder.append(itemDTO.getRegMPack());
			if (itemDTO.getRegMPack() > 1)
				builder.append("," + itemDTO.getRegMPrice());
			else
				builder.append("," + itemDTO.getRegPrice());
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
		}
		if (itemDTO.getListCost() != null) {
			builder.append("," + itemDTO.getListCost());
			builder.append(itemDTO.getListCostEffDate() != null
					? ",TO_DATE('" + itemDTO.getListCostEffDate() + "', 'MM/dd/yyyy')"
					: ",NULL");
		} else {
			builder.append(",NULL");
			builder.append(",''");
		}
		if (itemDTO.getVipCost() != null)
			builder.append("," + itemDTO.getVipCost());
		else
			builder.append(",NULL");

		if (itemDTO.getCompPrice() != null) {
			builder.append("," + itemDTO.getCompPrice().multiple);
			builder.append("," + itemDTO.getCompPrice().price);
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
		}

		builder.append("," + itemDTO.getCompTypeId());
		if (itemDTO.getCompStrId() != null) {
			builder.append("," + itemDTO.getCompStrId().getLocationId());
		} else {
			builder.append(",NULL");
		}

		if (itemDTO.getRecommendedRegPrice() != null) {
			builder.append("," + itemDTO.getRecommendedRegPrice().multiple);
			builder.append("," + itemDTO.getRecommendedRegPrice().price);
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
		}

		builder.append("," + itemDTO.getAvgMovement());
		builder.append("," + itemDTO.getAvgRevenue());
		builder.append("," + itemDTO.getCostChgIndicator());
		builder.append("," + itemDTO.getCompPriceChgIndicator());

		String explainLogAsJson = "";
		try {
			explainLogAsJson = mapper.writeValueAsString(itemDTO.getExplainLog());
		} catch (JsonProcessingException e) {
			explainLogAsJson = "";
		}
		builder.append(",'" + explainLogAsJson + "'");

		builder.append("," + itemDTO.getIsPrePriced());
		builder.append("," + itemDTO.getIsLocPriced());

		builder.append(",'" + itemDTO.getIsMarkedForReview() + "'");
		builder.append("," + itemDTO.getIsNewPriceRecommended());
		builder.append(itemDTO.getCompPriceCheckDate() != null
				? ",TO_DATE('" + itemDTO.getCompPriceCheckDate() + "', 'MM/dd/yyyy')"
				: ",NULL");
		builder.append("," + itemDTO.getIsConflict());
		builder.append("," + itemDTO.getChildLocationLevelId());
		builder.append("," + itemDTO.getChildLocationId());
		if (itemDTO.getPreRegPrice() != null)
			builder.append("," + itemDTO.getPreRegPrice());
		else
			builder.append(",NULL");
		if (itemDTO.getPreListCost() != null)
			builder.append("," + itemDTO.getPreListCost());
		else
			builder.append(",NULL");
		if (itemDTO.getCompPreviousPrice() != null)
			builder.append("," + PRCommonUtil.getUnitPrice(itemDTO.getCompPreviousPrice(), true));
		else
			builder.append(",NULL");
		builder.append(",'" + String.valueOf(itemDTO.getDistFlag()) + "'");
		builder.append(",'" + itemDTO.getIsOppurtunity() + "'");
		if (itemDTO.getOppurtunityPrice() != null)
			builder.append("," + itemDTO.getOppurtunityPrice());
		else
			builder.append(",NULL");
		if (itemDTO.getOppurtunityQty() != null)
			builder.append("," + itemDTO.getOppurtunityQty());
		else
			builder.append(",NULL");
		if (itemDTO.getOppurtunityMovement() != null)
			builder.append("," + itemDTO.getOppurtunityMovement());
		else
			builder.append(",NULL");
		if (itemDTO.getPredictionStatus() != null)
			builder.append("," + itemDTO.getPredictionStatus());
		else
			builder.append(",NULL");

		if (itemDTO.getCurRegPricePredictedMovement() != null)
			builder.append("," + itemDTO.getCurRegPricePredictedMovement());
		else
			builder.append(",NULL");

		if (itemDTO.getPreVipCost() != null)
			builder.append("," + itemDTO.getPreVipCost());
		else
			builder.append(",NULL");

		builder.append("," + itemDTO.getVipCostChgIndicator());

		if (itemDTO.getItemSize() > 0) {
			builder.append("," + itemDTO.getItemSize());
		} else {
			builder.append(",NULL");
		}

		builder.append("," + itemDTO.getUOMId());

		if (itemDTO.getIsZoneAndStorePriceSame() != null) {
			if (itemDTO.getIsZoneAndStorePriceSame())
				builder.append(",'" + String.valueOf(Constants.YES) + "'");
			else
				builder.append(",'" + String.valueOf(Constants.NO) + "'");
		} else {
			builder.append(",''");
		}

		if (itemDTO.getVendorId() > 0)
			builder.append("," + itemDTO.getVendorId());
		else
			builder.append(",NULL");

		if (itemDTO.getPriceCheckListTypeId() != null)
			builder.append("," + itemDTO.getPriceCheckListTypeId());
		else
			builder.append(",NULL");

		if (itemDTO.isLir())
			builder.append(",'" + String.valueOf(Constants.YES) + "'");
		else
			builder.append(",'" + String.valueOf(Constants.NO) + "'");

		builder.append("," + itemDTO.getItemCode());

		if (itemDTO.getIsRecError())
			builder.append(",'" + String.valueOf(Constants.YES) + "'");
		else
			builder.append(",'" + String.valueOf(Constants.NO) + "'");

		builder.append(",'" + PRCommonUtil.getCommaSeperatedStringFromIntArray(itemDTO.getRecErrorCodes()) + "'");

		if (itemDTO.getIsCurRetailSameAcrossStores())
			builder.append(",'" + String.valueOf(Constants.YES) + "'");
		else
			builder.append(",'" + String.valueOf(Constants.NO) + "'");

		builder.append("," + itemDTO.getPriceZoneId());

		if (itemDTO.getIsPartOfSubstituteGroup())
			builder.append(",'" + String.valueOf(Constants.YES) + "'");
		else
			builder.append(",'" + String.valueOf(Constants.NO) + "'");

		if (itemDTO.getPredMovWOSubsEffect() != null)
			builder.append("," + itemDTO.getPredMovWOSubsEffect());
		else
			builder.append(",NULL");

		if (itemDTO.getCurRegPredMovWOSubsEffect() != null)
			builder.append("," + itemDTO.getCurRegPredMovWOSubsEffect());
		else
			builder.append(",NULL");

		builder.append("," + itemDTO.getCurRetailSalesDollar());
		builder.append("," + itemDTO.getCurRetailMarginDollar());
		builder.append("," + itemDTO.getRecRetailSalesDollar());
		builder.append("," + itemDTO.getRecRetailMarginDollar());

		if (itemDTO.getIsIncludeForSummaryCalculation())
			builder.append(",'" + String.valueOf(Constants.YES) + "'");
		else
			builder.append(",'" + String.valueOf(Constants.NO) + "'");

		builder.append(itemDTO.getCurRegPriceEffDate() != null
				? ",TO_DATE('" + itemDTO.getCurRegPriceEffDate() + "', 'MM/dd/yyyy')"
				: ",NULL");

		if (itemDTO.getCompCurSalePrice() != null) {
			builder.append("," + itemDTO.getCompCurSalePrice().multiple);
			builder.append("," + itemDTO.getCompCurSalePrice().price);
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
		}

		if (itemDTO.getRecWeekSaleInfo().getSalePrice() != null) {
			builder.append("," + itemDTO.getRecWeekSaleInfo().getSalePrice().multiple);
			builder.append("," + itemDTO.getRecWeekSaleInfo().getSalePrice().price);
			builder.append("," + itemDTO.getRecWeekSaleInfo().getPromoTypeId());
			builder.append(itemDTO.getRecWeekSaleInfo().getSaleStartDate() != null
					? ",TO_DATE('" + itemDTO.getRecWeekSaleInfo().getSaleStartDate() + "', 'MM/dd/yyyy')"
					: ",NULL");
			builder.append(itemDTO.getRecWeekSaleInfo().getSaleEndDate() != null
					? ",TO_DATE('" + itemDTO.getRecWeekSaleInfo().getSaleEndDate() + "', 'MM/dd/yyyy')"
					: ",NULL");
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
			builder.append(",NULL");
			builder.append(",NULL");
			builder.append(",NULL");
		}

		if (itemDTO.getRecWeekSaleInfo().getSalePredStatusAtCurReg() != null) {
			if (itemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg() != null) {
				builder.append("," + itemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg());
			} else {
				builder.append(",NULL");
			}
			builder.append("," + itemDTO.getRecWeekSaleInfo().getSalePredStatusAtCurReg().getStatusCode());
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
		}

		if (itemDTO.getRecWeekSaleInfo().getSalePredStatusAtRecReg() != null) {
			if (itemDTO.getRecWeekSaleInfo().getSalePredMovAtRecReg() != null) {
				builder.append("," + itemDTO.getRecWeekSaleInfo().getSalePredMovAtRecReg());
			} else {
				builder.append(",NULL");
			}
			builder.append("," + itemDTO.getRecWeekSaleInfo().getSalePredStatusAtRecReg().getStatusCode());
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
		}

		if (itemDTO.getRecWeekSaleCost() != null) {
			builder.append("," + itemDTO.getRecWeekSaleCost());
		} else {
			builder.append(",NULL");
		}

		if (itemDTO.getFutWeekSaleInfo().getSalePrice() != null) {
			builder.append("," + itemDTO.getFutWeekSaleInfo().getSalePrice().multiple);
			builder.append("," + itemDTO.getFutWeekSaleInfo().getSalePrice().price);
			builder.append("," + itemDTO.getFutWeekSaleInfo().getPromoTypeId());
			builder.append(itemDTO.getFutWeekSaleInfo().getSaleStartDate() != null
					? ",TO_DATE('" + itemDTO.getFutWeekSaleInfo().getSaleStartDate() + "', 'MM/dd/yyyy')"
					: ",NULL");
			builder.append(itemDTO.getFutWeekSaleInfo().getSaleEndDate() != null
					? ",TO_DATE('" + itemDTO.getFutWeekSaleInfo().getSaleEndDate() + "', 'MM/dd/yyyy')"
					: ",NULL");
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
			builder.append(",NULL");
			builder.append(",NULL");
			builder.append(",NULL");
		}

		if (itemDTO.getRecWeekAdInfo().getAdPageNo() > 0) {
			builder.append("," + itemDTO.getRecWeekAdInfo().getAdPageNo());
		} else {
			builder.append(",NULL");
		}

		if (itemDTO.getRecWeekAdInfo().getAdBlockNo() > 0) {
			builder.append("," + itemDTO.getRecWeekAdInfo().getAdBlockNo());
		} else {
			builder.append(",NULL");
		}

		builder.append(itemDTO.getFutWeekAdInfo().getWeeklyAdStartDate() != null
				? ",TO_DATE('" + itemDTO.getFutWeekAdInfo().getWeeklyAdStartDate() + "', 'MM/dd/yyyy')"
				: ",NULL");

		if (itemDTO.getFutWeekAdInfo().getAdPageNo() > 0) {
			builder.append("," + itemDTO.getFutWeekAdInfo().getAdPageNo());
		} else {
			builder.append(",NULL");
		}

		if (itemDTO.getFutWeekAdInfo().getAdBlockNo() > 0) {
			builder.append("," + itemDTO.getFutWeekAdInfo().getAdBlockNo());
		} else {
			builder.append(",NULL");
		}

		if (itemDTO.getRecWeekDisplayInfo().getDisplayTypeLookup() != null
				&& itemDTO.getRecWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId() > 0) {
			builder.append("," + itemDTO.getRecWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId());
		} else {
			builder.append(",NULL");
		}

		builder.append(itemDTO.getFutWeekDisplayInfo().getDisplayWeekStartDate() != null
				? ",TO_DATE('" + itemDTO.getFutWeekDisplayInfo().getDisplayWeekStartDate() + "', 'MM/dd/yyyy')"
				: ",NULL");

		if (itemDTO.getFutWeekDisplayInfo().getDisplayTypeLookup() != null
				&& itemDTO.getFutWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId() > 0) {
			builder.append("," + itemDTO.getFutWeekDisplayInfo().getDisplayTypeLookup().getDisplayTypeId());
		} else {
			builder.append(",NULL");
		}

		builder.append("," + itemDTO.getIsTPR());
		builder.append("," + itemDTO.getIsOnSale());
		builder.append("," + itemDTO.getIsOnAd());

		builder.append(itemDTO.getRecPriceEffectiveDate() != null
				? ",TO_DATE('" + itemDTO.getRecPriceEffectiveDate() + "', 'MM/dd/yyyy')"
				: ",NULL");

		if (itemDTO.getFutureRecRetail() != null) {
			builder.append("," + itemDTO.getFutureRecRetail().multiple);
			builder.append("," + itemDTO.getFutureRecRetail().price);
		} else {
			builder.append(",NULL");
			builder.append(",NULL");
		}

		builder.append("," + itemDTO.getLigRepItemCode());
		builder.append(
				",'" + itemDTO.getRegPricePredReasons() != null ? itemDTO.getRegPricePredReasons() : "NULL" + "'");
		builder.append(",'" + itemDTO.getSalePricePredReasons() + "'");
		builder.append(");");

		return builder.toString();
	}

	public void updateCurRetailCalIdInRunHeader(Connection conn, long runId, int curRetailCalendarId)
			throws GeneralException {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_CUR_RETAIL_CAL_ID_RUN_HEADER);
			if (curRetailCalendarId > 0)
				stmt.setInt(1, curRetailCalendarId);
			else
				stmt.setNull(1, java.sql.Types.INTEGER);

			stmt.setLong(2, runId);
			stmt.executeUpdate();
		} catch (SQLException exception) {
			logger.error("Exception in updateCurRetailCalIdInRunHeader() - " + exception.toString());
			throw new GeneralException("Exception in updateCurRetailCalIdInRunHeader()- " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	private long getRecommendationId(Connection conn, long runId, ItemKey itemKey) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		long recommendationId = -1;
		try {
			stmt = conn.prepareStatement(GET_PR_RECOMMENDATION_ID);
			stmt.setLong(1, runId);
			stmt.setInt(2, itemKey.getItemCodeOrRetLirId());
			if (itemKey.getLirIndicator() == PRConstants.LIG_ITEM_INDICATOR)
				stmt.setString(3, String.valueOf(Constants.YES));
			else
				stmt.setString(3, String.valueOf(Constants.NO));

			rs = stmt.executeQuery();
			if (rs.next()) {
				recommendationId = rs.getLong("PR_RECOMMENDATION_ID");
			}
			// logger.info("Input " + runId + "\t" + itemKey.getItemCodeOrRetLirId() +
			// "RecommendationId " + recommendationId);
		} catch (SQLException exception) {
			logger.error("Error when getting recommendation id - " + exception.toString());
			throw new GeneralException("Error when getting recommendation id - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}

		try {
			stmt = conn.prepareStatement(UPDATE_PR_RECOMMENDATION_STORE);
			stmt.setLong(1, recommendationId);
			stmt.executeUpdate();
		} catch (SQLException exception) {
			logger.error("Error when updating store recommendation indicator - " + exception.toString());
			throw new GeneralException("Error when updating store recommendation indicator - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}

		return recommendationId;
	}

	public void insertRecommendationItemStore(Connection conn, HashMap<Integer, List<PRItemDTO>> storeItemList)
			throws GeneralException {
		PreparedStatement stmt = null;
//		DecimalFormat df = new DecimalFormat("#######.##");
		HashMap<ItemKey, Long> recommendationIdMap = new HashMap<ItemKey, Long>();
		ObjectMapper mapper = new ObjectMapper();
		String explainLogAsJson = "";
		try {
			stmt = conn.prepareStatement(INSERT_RECOMMENDATION_ITEM_STORE);
			int itemNoInBatch = 0;
			ItemKey itemKey = null;
			for (List<PRItemDTO> itemList : storeItemList.values()) {
//				logger.info("Item list Size - " + itemList.size());
				for (PRItemDTO item : itemList) {
					explainLogAsJson = "";
					long runId = item.getRunId();
					long recommendationId = -1;
//		        	int itemCode = item.getItemCode();
//		        	if(item.isLir()){
//		        		itemCode = item.getRetLirItemCode();		        		
//		        	}
//		        	else{
//		        		itemCode = item.getItemCode();
//		        	}

					itemKey = PRCommonUtil.getItemKey(item);

					if (recommendationIdMap.get(itemKey) != null) {
						recommendationId = recommendationIdMap.get(itemKey);
					} else {
						recommendationId = getRecommendationId(conn, runId, itemKey);
						recommendationIdMap.put(itemKey, recommendationId);
					}

					if (recommendationId == -1)
						continue;

					int counter = 0;

					stmt.setLong(++counter, recommendationId);
					stmt.setInt(++counter, item.getChildLocationId());
					stmt.setLong(++counter, item.getStrategyId());
					if (item.getPredictedMovement() != null)
						stmt.setDouble(++counter, item.getPredictedMovement());
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					if (item.getRegMPack() != null && item.getRegMPack() > 0) {
						stmt.setInt(++counter, item.getRegMPack());
						if (item.getRegMPack() > 1)
							stmt.setDouble(++counter, item.getRegMPrice());
						else
							stmt.setDouble(++counter, item.getRegPrice());
					} else {
						stmt.setNull(++counter, java.sql.Types.INTEGER);
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					}
					if (item.getListCost() != null) {
						stmt.setDouble(++counter, item.getListCost());
						stmt.setString(++counter, item.getListCostEffDate());
					} else {
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
						stmt.setString(++counter, "");
					}
					if (item.getVipCost() != null)
						stmt.setDouble(++counter, item.getVipCost());
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					if (item.getCompPrice() != null) {
						stmt.setInt(++counter, item.getCompPrice().multiple);
						stmt.setDouble(++counter, item.getCompPrice().price);
					} else {
						stmt.setNull(++counter, java.sql.Types.INTEGER);
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					}
					stmt.setInt(++counter, item.getCompTypeId());
					if (item.getCompStrId() != null) {
						stmt.setInt(++counter, item.getCompStrId().getLocationId());
					} else {
						stmt.setNull(++counter, java.sql.Types.INTEGER);
					}
//		        	stmt.setInt(++counter, item.getCompStrId().getLocationId());
					/*
					 * if(item.getRecommendedRegMultiple() != null) stmt.setInt(++counter,
					 * item.getRecommendedRegMultiple()); else stmt.setNull(++counter,
					 * java.sql.Types.INTEGER); if(item.getRecommendedRegPrice() != null)
					 * stmt.setDouble(++counter, item.getRecommendedRegPrice()); else
					 * stmt.setNull(++counter, java.sql.Types.DOUBLE);
					 */

					if (item.getRecommendedRegPrice() != null) {
						stmt.setInt(++counter, item.getRecommendedRegPrice().multiple);
						stmt.setDouble(++counter, item.getRecommendedRegPrice().price);
					} else {
						stmt.setNull(++counter, java.sql.Types.INTEGER);
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					}

					stmt.setDouble(++counter, item.getAvgMovement());
					stmt.setDouble(++counter, item.getAvgRevenue());
					stmt.setInt(++counter, item.getCostChgIndicator());
					stmt.setInt(++counter, item.getCompPriceChgIndicator());
					// String log = item.getLog().toString();

					try {
						explainLogAsJson = mapper.writeValueAsString(item.getExplainLog());
					} catch (JsonProcessingException e) {
						explainLogAsJson = "";
						logger.error("Error when converting explain log to json string - " + item.getItemCode()
								+ e.toString());
					}
					stmt.setString(++counter, explainLogAsJson);

					stmt.setInt(++counter, item.getIsPrePriced());
					stmt.setInt(++counter, item.getIsLocPriced());

					/*
					 * if(item.getRecommendedRegPrice() != null){ if(item.getRegPrice() != null){
					 * Double tRegPrice = new Double(df.format(item.getRegPrice())); Double
					 * tRecPrice = new Double(df.format(item.getRecommendedRegPrice()));
					 * if(tRegPrice.doubleValue() != tRecPrice.doubleValue()){
					 * item.setIsNewPriceRecommended(1); } }else{
					 * if(item.getRecommendedRegPrice().doubleValue() > 0)
					 * item.setIsNewPriceRecommended(1); } }
					 */

//		        	if(isNewPriceRecommended(item, df))
//		        		item.setIsNewPriceRecommended(1);

					stmt.setString(++counter, item.getIsMarkedForReview());
					stmt.setInt(++counter, item.getIsNewPriceRecommended());
					stmt.setInt(++counter, item.getIsConflict());
					if (item.getPreListCost() != null)
						stmt.setDouble(++counter, item.getPreListCost());
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					if (item.getCompPreviousPrice() != null)
						stmt.setDouble(++counter, PRCommonUtil.getUnitPrice(item.getCompPreviousPrice(), true));
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);

					stmt.setString(++counter, String.valueOf(item.getDistFlag()));

					if (item.getPreRegPrice() != null)
						stmt.setDouble(++counter, item.getPreRegPrice());
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);

					stmt.setString(++counter, item.getCompPriceCheckDate());

					// Changes to store opportunities
					stmt.setString(++counter, item.getIsOppurtunity());
					if (item.getOppurtunityPrice() != null)
						stmt.setDouble(++counter, item.getOppurtunityPrice());
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					if (item.getOppurtunityQty() != null)
						stmt.setInt(++counter, item.getOppurtunityQty());
					else
						stmt.setNull(++counter, java.sql.Types.INTEGER);
					// Changes to store opportunities - Ends
					// Change to update prediction status
					if (item.getPredictionStatus() != null)
						stmt.setInt(++counter, item.getPredictionStatus());
					else
						stmt.setNull(++counter, java.sql.Types.INTEGER);
					// Change to update prediction status - Ends

					if (item.getCurRegPricePredictedMovement() != null)
						// 12th Apr 2016, don't round predicted movement
						// stmt.setDouble(++counter,
						// Math.round(item.getCurRegPricePredictedMovement()));
						// stmt.setDouble(++counter, item.getCurRegPricePredictedMovement());

						stmt.setDouble(++counter, item.getCurRegPricePredictedMovement());
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);

					if (item.getPreVipCost() != null)
						stmt.setDouble(++counter, item.getPreVipCost());
					else
						stmt.setNull(++counter, java.sql.Types.DOUBLE);

					stmt.setInt(++counter, item.getVipCostChgIndicator());

					if (item.getItemSize() > 0) {
						stmt.setDouble(++counter, item.getItemSize());
					} else {
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					}
					stmt.setString(++counter, item.getUOMId());

					if (item.getVendorId() > 0)
						stmt.setInt(++counter, item.getVendorId());
					else
						stmt.setNull(++counter, java.sql.Types.INTEGER);

					if (item.getIsRecError())
						stmt.setString(++counter, String.valueOf(Constants.YES));
					else
						stmt.setString(++counter, String.valueOf(Constants.NO));

					stmt.setString(++counter,
							PRCommonUtil.getCommaSeperatedStringFromIntArray(item.getRecErrorCodes()));

//					if(item.isLir())
//		        		stmt.setString(++counter, String.valueOf(Constants.YES));
//		        	else
//		        		stmt.setString(++counter, String.valueOf(Constants.NO));
//		        	
//		        	stmt.setInt(++counter, item.getItemCode());

//		        	stmt.setDouble(++counter, Math.round(item.getCurRetailSalesDollar()));
//		        	stmt.setDouble(++counter, Math.round(item.getCurRetailMarginDollar()));
//		        	stmt.setDouble(++counter, Math.round(item.getRecRetailSalesDollar()));
//		        	stmt.setDouble(++counter, Math.round(item.getRecRetailMarginDollar()));

					stmt.setDouble(++counter, item.getCurRetailSalesDollar());
					stmt.setDouble(++counter, item.getCurRetailMarginDollar());
					stmt.setDouble(++counter, item.getRecRetailSalesDollar());
					stmt.setDouble(++counter, item.getRecRetailMarginDollar());

					if (item.getIsIncludeForSummaryCalculation())
						stmt.setString(++counter, String.valueOf(Constants.YES));
					else
						stmt.setString(++counter, String.valueOf(Constants.NO));
					stmt.setString(++counter, item.getCurRegPriceEffDate());

					stmt.addBatch();
					itemNoInBatch++;

					if (itemNoInBatch % PRConstants.BATCH_INSERT_COUNT_STORE_RECOMMENDATION == 0) {
						int[] count = stmt.executeBatch();
						stmt.clearBatch();
						itemNoInBatch = 0;
					}
				}
			}
			if (itemNoInBatch > 0) {
				int[] count = stmt.executeBatch();
				stmt.clearBatch();
			}
		} catch (SQLException exception) {
			logger.error("Error when inserting recommendation items - " + exception.toString());
			throw new GeneralException("Error when inserting recommendation items - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public PRStrategyDTO getStrategyDetails(Connection conn, long strategyId) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		PRStrategyDTO strategy = null;
		try {
			stmt = conn.prepareStatement(GET_STRATEGY_DETAILS);
			stmt.setLong(1, strategyId);
			rs = stmt.executeQuery();
			if (rs.next()) {
				strategy = new PRStrategyDTO();
				strategy.setStrategyId(rs.getInt("STRATEGY_ID"));
				strategy.setProductLevelId(rs.getInt("PRODUCT_LEVEL_ID"));
				strategy.setProductId(rs.getInt("PRODUCT_ID"));
				strategy.setLocationLevelId(rs.getInt("LOCATION_LEVEL_ID"));
				strategy.setLocationId(rs.getInt("LOCATION_ID"));
				strategy.setStartCalendarId(rs.getInt("START_CALENDAR_ID"));
				strategy.setEndCalendarId(rs.getInt("END_CALENDAR_ID"));
				strategy.setApplyTo(rs.getInt("APPLY_TO"));
				strategy.setPriceCheckListId(rs.getInt("APPLY_TO"));
				strategy.setStartDate(rs.getString("START_DATE"));
				strategy.setEndDate(rs.getString("END_DATE"));
				strategy.setStateId(rs.getInt("STATE_ID"));
				strategy.setDsdRecommendationFlag(rs.getString("DSD_RECOMMENDATION_FLAG").charAt(0));
			}
		} catch (SQLException exception) {
			exception.printStackTrace();
			logger.error("Error when retrieving strategy details - " + exception.toString());
			throw new GeneralException("Error when retrieving strategy details - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return strategy;
	}

	public int getDefaultRoundingTable(Connection conn) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int roundingTableId = 0;
		try {
			stmt = conn.prepareStatement(GET_DEFAULT_ROUNDING_TABLE);
			rs = stmt.executeQuery();
			if (rs.next()) {
				roundingTableId = rs.getInt("ROUNDING_TABLE_ID");
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving default rounding table - " + exception.toString());
			throw new GeneralException("Error when retrieving default rounding table - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return roundingTableId;
	}

	public TreeMap<String, PRRoundingTableDTO> getRoundingTableDetail(Connection conn, int roundingTableId)
			throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		TreeMap<String, PRRoundingTableDTO> roundingTableContent = new TreeMap<String, PRRoundingTableDTO>();
		try {
			stmt = conn.prepareStatement(GET_ROUNDING_TABLE_CONTENT);
			stmt.setInt(1, roundingTableId);
			rs = stmt.executeQuery();

			while (rs.next()) {
				PRRoundingTableDTO rtDTO = new PRRoundingTableDTO();
				rtDTO.setStartPrice(rs.getDouble("START_PRICE"));
				if (rs.getObject("END_PRICE") != null)
					rtDTO.setEndPrice(rs.getDouble("END_PRICE"));
				else
					rtDTO.setEndPrice(PRConstants.DEFAULT_MAX_PRICE);
				rtDTO.setAllowedEndDigits(rs.getString("ALLOWED_END_DIGITS"));
				rtDTO.setAllowedPrices(rs.getString("ALLOWED_PRICES"));
				rtDTO.setExcludedPrices(rs.getString("EXCLUDED_PRICES"));
				String key = rs.getString("START_PRICE") + "-"
						+ (rs.getString("END_PRICE") == null ? PRConstants.DEFAULT_MAX_PRICE_STR
								: rs.getString("END_PRICE"));
				roundingTableContent.put(key, rtDTO);
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving default rounding table detail - " + exception.toString());
			throw new GeneralException("Error when retrieving default rounding table detail - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return roundingTableContent;
	}

	public ArrayList<PRItemDTO> getRecommendation(Connection conn, int runId) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ArrayList<PRItemDTO> recommendationList = new ArrayList<PRItemDTO>();
		try {
			stmt = conn.prepareStatement(GET_RECOMMENDATION);
			stmt.setInt(1, runId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				PRItemDTO item = new PRItemDTO();
				item.setRetailerItemCode(rs.getString("RETAILER_ITEM_CODE"));
				item.setStrategyId(rs.getInt("STRATEGY_ID"));
//				item.setRecommendedRegMultiple(rs.getInt("RECOMMENDED_REG_MULTIPLE"));
//				item.setRecommendedRegPrice(rs.getDouble("RECOMMENDED_REG_PRICE"));

				item.setRecommendedRegPrice(new MultiplePrice(rs.getInt("RECOMMENDED_REG_MULTIPLE"),
						rs.getDouble("RECOMMENDED_REG_PRICE")));

				item.setRegPrice(rs.getDouble("CUR_REG_PRICE"));
				item.setRegMPack(rs.getInt("CUR_REG_MULTIPLE"));
				if (item.getRecommendedRegPrice() != null) {
					double curPrice = item.getRegPrice() / item.getRegMPack();
//					if(item.getRecommendedRegPrice() != curPrice && item.getRecommendedRegPrice() > 0)
					if (item.getRecommendedRegPrice().price != curPrice && item.getRecommendedRegPrice().price > 0)
						recommendationList.add(item);
				}
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving recommendations - " + exception.toString());
			throw new GeneralException("Error when retrieving recommendations - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return recommendationList;
	}

	public void updateRecommendationStatus(Connection conn, long runId, int percentCompleted, String message) {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_RECOMMENDATION_STATUS);
			stmt.setString(1, message);
			stmt.setInt(2, percentCompleted);
			logger.info(message + "\t" + percentCompleted);
			stmt.setLong(3, runId);
			stmt.executeUpdate();
			conn.commit();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendations - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public long isPriceExists(Connection conn, int calendarId, long minPriceRecordCnt) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		long count = 0;
		try {
			stmt = conn.prepareStatement(IS_PRICE_EXISTS);
			stmt.setInt(1, calendarId);
			stmt.setLong(2, minPriceRecordCnt);
			rs = stmt.executeQuery();
			if (rs.next()) {
				count = rs.getInt("COUNT");
			}
		} catch (SQLException exception) {
			logger.error("Error checking if price exists - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return count;
	}

	public void populatePriceGroupDetails(HashMap<ItemKey, PRItemDTO> itemDataMap,
			HashMap<String, HashMap<ItemKey, PRPriceGroupDTO>> priceGroupRelation) {
		for (PRItemDTO prItem : itemDataMap.values()) {
			boolean pgSet = false;
			int itemCode = prItem.getItemCode();
			int retLirId = prItem.getRetLirId();
			if (prItem.getRetLirId() > 0)
				retLirId = prItem.getRetLirId();
			for (HashMap<ItemKey, PRPriceGroupDTO> pg : priceGroupRelation.values()) {
				ItemKey itemKey = PRCommonUtil.getItemKey(prItem);
				// If it is a LIG
				if (retLirId > 0) {
					itemKey = PRCommonUtil.getItemKey(retLirId, true);
					if (pg.get(itemKey) != null) {
						PRPriceGroupDTO pgDTO = new PRPriceGroupDTO();
						PRPriceGroupDTO pgData = pg.get(itemKey);
						// Check if relation list is available for this LIG. If not, dont set PG data
						// It creates issue when LIG is brand lead and LIG member is dependent of Size
						// lead
						// Changes done by Pradeep on 12/12/2019.
						if (prItem.getPgData() == null || (prItem.getPgData().getRelationList() != null
								&& prItem.getPgData().getRelationList().size() == 0)) {
							pgDTO.copy(pg.get(itemKey));
							logger.debug("Relation LIG: " + retLirId + " for base LIG/Item: " + PRCommonUtil.getItemKey(prItem));
							prItem.setPgData(pgDTO);
							pgSet = true;
							break;
						} else if(prItem.getPgData() == null 
								|| (pgData.getRelationList() != null && pgData.getRelationList().size() > 0)) {
							pgDTO.copy(pg.get(itemKey));
							logger.debug("Relation LIG: " + retLirId + " for base LIG/Item: " + PRCommonUtil.getItemKey(prItem));
							prItem.setPgData(pgDTO);
							pgSet = true;
							break;
						} else {
							// NU: 21st Oct 2015, support lig member relation
							// If a item is part of lig and relation is at lig member
							itemKey = PRCommonUtil.getItemKey(prItem);
							if (pg.get(itemKey) != null) {
								prItem.setItemLevelRelation(true);
							}
						}
					} else {
						// NU: 21st Oct 2015, support lig member relation
						// If a item is part of lig and relation is at lig member
						itemKey = PRCommonUtil.getItemKey(prItem);
						if (pg.get(itemKey) != null) {
							prItem.setItemLevelRelation(true);
						}
					}
				}

				if (!pgSet) {
					itemKey = PRCommonUtil.getItemKey(itemCode, false);
					if (pg.get(itemKey) != null) {
						PRPriceGroupDTO pgDTO = new PRPriceGroupDTO();
						pgDTO.copy(pg.get(itemKey));
						logger.debug("Relation Item Code: " + itemCode + " for item: " + prItem.getItemCode());
						prItem.setPgData(pgDTO);
						pgSet = true;
						break;
					}
				}
			}
		}
	}

	/**
	 * Returns list of zones under zone list
	 * 
	 * @param conn
	 * @param zoneListId
	 * @return
	 * @throws GeneralException
	 */
	public ArrayList<Integer> getZonesUnderZoneList(Connection conn, int zoneListId) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ArrayList<Integer> zoneList = new ArrayList<Integer>();
		try {
			stmt = conn.prepareStatement(GET_ZONES_UNDER_ZONE_LIST);
			stmt.setInt(1, zoneListId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				zoneList.add(rs.getInt("CHILD_LOCATION_ID"));
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving zones under zone list - " + exception);
			throw new GeneralException("Error when retrieving zones under zone list - " + exception);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return zoneList;
	}

	/**
	 * Returns list of products under product list
	 * 
	 * @param conn
	 * @param productListId
	 * @return
	 * @throws GeneralException
	 */
	public ArrayList<ProductDTO> getProductsUnderProductList(Connection conn, int productListId)
			throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ArrayList<ProductDTO> productList = new ArrayList<ProductDTO>();
		try {
			stmt = conn.prepareStatement(GET_PRODUCTS_UNDER_PRODUCT_LIST);
			stmt.setInt(1, productListId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				ProductDTO pDTO = new ProductDTO();
				pDTO.setProductLevelId(rs.getInt("CHILD_PRODUCT_LEVEL_ID"));
				pDTO.setProductId(rs.getInt("CHILD_PRODUCT_ID"));
				productList.add(pDTO);
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving products under productList list - " + exception);
			throw new GeneralException("Error when retrieving products under productList list - " + exception);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return productList;
	}

	/**
	 * Returns product list ids that has input product id as its child
	 * 
	 * @param productLevelId
	 * @param productId
	 * @return
	 */
	public ArrayList<Long> getProductListId(Connection conn, int productLevelId, int productId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ArrayList<Long> productListId = new ArrayList<Long>();
		int counter = 0;
		try {
			stmt = conn.prepareStatement(GET_PRODUCT_LIST_ID);
			stmt.setInt(++counter, productLevelId);
			stmt.setInt(++counter, productId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				productListId.add(rs.getLong("PRODUCT_ID"));
			}
		} catch (SQLException e) {
			logger.error("Error while retrieving product list id " + e.getMessage());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return productListId;
	}

	/**
	 * Returns location list ids that has input product id as its child
	 * 
	 * @param locationLevelId
	 * @param locationId
	 * @return
	 */
	public ArrayList<Integer> getLocationListId(Connection conn, int locationLevelId, int locationId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ArrayList<Integer> locationListId = new ArrayList<Integer>();
		int counter = 0;
		try {
			stmt = conn.prepareStatement(GET_LOCATION_LIST_ID);
			stmt.setInt(++counter, locationLevelId);
			stmt.setInt(++counter, locationId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				locationListId.add(rs.getInt("LOCATION_ID"));
			}
		} catch (SQLException e) {
			logger.error("Error while retrieving location list id " + e.getMessage());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return locationListId;
	}

	public ArrayList<Integer> getStoreLocationListId(Connection conn, int locationLevelId, int locationId)
			throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ArrayList<Integer> locationListId = new ArrayList<Integer>();
		int counter = 0;
		try {
			stmt = conn.prepareStatement(GET_STORE_LOCATION_LIST_ID);
			stmt.setInt(++counter, locationLevelId);
			stmt.setInt(++counter, locationId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				locationListId.add(rs.getInt("LOCATION_ID"));
			}
		} catch (SQLException e) {
			logger.error("Error while retrieving location list id " + e.getMessage());
			throw new GeneralException("Error in getStoreLocationListId() - " + e);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return locationListId;
	}

	/**
	 * Retrieve recommended items for the input run id
	 * 
	 * @param conn
	 * @param runId
	 * @return
	 * @throws GeneralException
	 */
	public ArrayList<PRItemDTO> getRecommendationItems(Connection conn, long runId) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ArrayList<PRItemDTO> itemList = new ArrayList<PRItemDTO>();
		try {
			stmt = conn.prepareStatement(GET_RECOMMENDATION_ITEMS);
			stmt.setLong(1, runId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				PRItemDTO item = new PRItemDTO();
				item.setItemCode(rs.getInt("ITEM_CODE"));
				String lirInd = rs.getString("LIR_IND");
				if (String.valueOf(Constants.YES).equalsIgnoreCase(lirInd)) {
					item.setLir(true);
				}
				item.setRetLirId(rs.getInt("RET_LIR_ID"));
//	    		item.setRecommendedRegMultiple(rs.getInt("RECOMMENDED_REG_MULTIPLE"));
//	    		item.setRecommendedRegPrice(rs.getDouble("RECOMMENDED_REG_PRICE"));
				item.setRecommendedRegPrice(new MultiplePrice(rs.getInt("RECOMMENDED_REG_MULTIPLE"),
						rs.getDouble("RECOMMENDED_REG_PRICE")));
				item.setAvgMovement(rs.getDouble("AVG_MOVEMENT"));
				item.setPredictedMovement(rs.getDouble("PREDICTED_MOVEMENT"));
				if (rs.getObject("CUR_COMP_REG_PRICE") != null) {
					MultiplePrice multiplePrice = new MultiplePrice(rs.getInt("CUR_COMP_REG_MULTIPLE"),
							rs.getDouble("CUR_COMP_REG_PRICE"));
					item.setCompPrice(multiplePrice);
				} else {
					item.setCompPrice(null);
				}

				item.setIsNewPriceRecommended(rs.getInt("IS_PRICE_RECOMMENDED"));
				item.setIsConflict(rs.getInt("IS_CONFLICT"));
				item.setRegMPack(rs.getInt("CUR_REG_MULTIPLE"));
				item.setRegPrice(rs.getDouble("CUR_REG_PRICE"));

				if (rs.getObject("OVERRIDE_REG_MULTIPLE") != null)
					item.setOverrideRegMultiple(rs.getInt("OVERRIDE_REG_MULTIPLE"));

				if (rs.getObject("OVERRIDE_REG_PRICE") != null)
					item.setOverrideRegPrice(rs.getDouble("OVERRIDE_REG_PRICE"));

//	    		if(rs.getObject("CUR_REG_PRICE") != null){
//	    			MultiplePrice multiplePrice = new MultiplePrice(rs.getInt("CUR_REG_MULTIPLE"), rs.getDouble("CUR_REG_PRICE"));
//	    			item.setCurRegPrice(multiplePrice);
//	    		}else{
//	    			item.setCurRegPrice(null);
//	    		}

				if (rs.getString("IS_REC_ERROR") != null) {
					String isRecError = rs.getString("IS_REC_ERROR");
					if (String.valueOf(Constants.YES).equalsIgnoreCase(isRecError))
						item.setIsRecError(true);
					else
						item.setIsRecError(false);
				} else {
					item.setIsRecError(false);
				}

				if (rs.getString("IS_MARKED_FOR_REVIEW") != null) {
					item.setIsMarkedForReview(rs.getString("IS_MARKED_FOR_REVIEW"));
				}

				if (rs.getString("PRICE_CHECK_LIST_ID") != null) {
					item.setPriceCheckListId(rs.getInt("PRICE_CHECK_LIST_ID"));
				}

				if (rs.getString("REC_REG_PRED_REASONS") != null) {
					item.setRegPricePredReasons(rs.getString("REC_REG_PRED_REASONS"));
				}

				if (rs.getString("REC_SALE_PRED_REASONS") != null) {
					item.setSalePricePredReasons(rs.getString("REC_SALE_PRED_REASONS"));
				}

				int compStrId = rs.getInt("COMP_STR_ID");

				if (compStrId > 0) {
					LocationKey locationKey = new LocationKey(Constants.STORE_LEVEL_ID, compStrId);
					item.setCompStrId(locationKey);
				}

				itemList.add(item);
			}
		} catch (SQLException e) {
			logger.error("Error while retrieving recommendation list " + e.getMessage());
			throw new GeneralException("Error in getRecommendationItems() - " + e);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return itemList;
	}

	/**
	 * Updates future PI and value in dashboard table
	 * 
	 * @param conn
	 * @param locationLevelId
	 * @param locationId
	 * @param productLevelId
	 * @param productId
	 * @param futurePI
	 * @throws GeneralException
	 */
	public void updateDashboardData(Connection conn, DashboardDTO dashboardDTO) throws GeneralException {
		PreparedStatement stmt = null;
		DecimalFormat df = new DecimalFormat("#######.##");
		try {

			String UPDATE_DASHBOARD = "UPDATE PR_DASHBOARD SET FUTURE_PI = ?, VALUE = ?, NO_RECOMMENDED = ?, TOT_CONFLICT = ?,"
					+ " STRATEGY_ID = ?, DIST_TOT_CONFLICT = ?, KVI_FUTURE_PI = ?, KVI_VALUE = ?, KVI_NO_RECOMMENDED = ?, "
					+ " KVI_TOT_CONFLICT = ?, KVI_STRATEGY_ID = ?, DIST_KVI_TOT_CONFLICT = ?, NO_OVERRIDDEN = ?, KVI_NO_OVERRIDDEN = ?, "
					+ " NO_MANAGER_REVIEW = ?, KVI_NO_MANAGER_REVIEW = ?, RECOMMENDATION_RUN_ID = ?, "
					+ " CURRENT_PI = ?, KVI_CURRENT_PI = ?, "
					+ " TOT_ERROR_REC = ?, DIST_ERROR_REC = ?, KVI_TOT_ERROR_REC = ?, DIST_KVI_ERROR_REC = ? "
					+ " WHERE LOCATION_LEVEL_ID = ? AND LOCATION_ID = ? AND PRODUCT_LEVEL_ID = ? AND PRODUCT_ID = ?";

			stmt = conn.prepareStatement(UPDATE_DASHBOARD);
			int counter = 0;
			if (dashboardDTO.getFuturePI() != null)
				stmt.setDouble(++counter, new Double(df.format(dashboardDTO.getFuturePI())));
			else
				stmt.setNull(++counter, Types.DOUBLE);
			if (dashboardDTO.getValue() != null)
				stmt.setDouble(++counter, new Double(df.format(dashboardDTO.getValue())));
			else
				stmt.setNull(++counter, Types.DOUBLE);
			stmt.setInt(++counter, dashboardDTO.getNoOfRecommendation());
			stmt.setInt(++counter, dashboardDTO.getTotConflict());
			if (dashboardDTO.getStrategyId() != null)
				stmt.setInt(++counter, dashboardDTO.getStrategyId());
			else
				stmt.setNull(++counter, Types.INTEGER);
			stmt.setInt(++counter, dashboardDTO.getLigTotConflict());
			if (dashboardDTO.getKviFuturePI() != null)
				stmt.setDouble(++counter, new Double(df.format(dashboardDTO.getKviFuturePI())));
			else
				stmt.setNull(++counter, Types.DOUBLE);
			if (dashboardDTO.getKviValue() != null)
				stmt.setDouble(++counter, new Double(df.format(dashboardDTO.getKviValue())));
			else
				stmt.setNull(++counter, Types.DOUBLE);
			stmt.setInt(++counter, dashboardDTO.getKviNoOfRecommendation());
			stmt.setInt(++counter, dashboardDTO.getKviTotConflict());
			if (dashboardDTO.getKviStrategyId() != null)
				stmt.setInt(++counter, dashboardDTO.getKviStrategyId());
			else
				stmt.setNull(++counter, Types.INTEGER);
			stmt.setInt(++counter, dashboardDTO.getLigKviTotConflict());

			stmt.setInt(++counter, dashboardDTO.getNoOfOverridden());
			stmt.setInt(++counter, dashboardDTO.getNoOfKVIOverridden());
			stmt.setInt(++counter, dashboardDTO.getNoOfManagerReview());
			stmt.setInt(++counter, dashboardDTO.getNoOfKVIManagerReview());
			stmt.setLong(++counter, dashboardDTO.getRecommendationRunId());

			if (dashboardDTO.getCurrentPI() != null)
				stmt.setDouble(++counter, new Double(df.format(dashboardDTO.getCurrentPI())));
			else
				stmt.setNull(++counter, Types.DOUBLE);

			if (dashboardDTO.getKviCurrentPI() != null)
				stmt.setDouble(++counter, new Double(df.format(dashboardDTO.getKviCurrentPI())));
			else
				stmt.setNull(++counter, Types.DOUBLE);

			stmt.setInt(++counter, dashboardDTO.getTotErrorItem());
			stmt.setInt(++counter, dashboardDTO.getLigTotErrorItem());
			stmt.setInt(++counter, dashboardDTO.getKviTotErrorItem());
			stmt.setInt(++counter, dashboardDTO.getLigKviTotErrorItem());

			/*
			 * logger.debug("FUTURE_PI = " + (dashboardDTO.getFuturePI() != null ?
			 * df.format(dashboardDTO.getFuturePI()) : "") + ", VALUE = " +
			 * (dashboardDTO.getValue() != null ? df.format(dashboardDTO.getValue()) : "") +
			 * ", NO_RECOMMENDED = " + dashboardDTO.getNoOfRecommendation() +
			 * ", TOT_CONFLICT = " + dashboardDTO.getTotConflict() + ", STRATEGY_ID =  " +
			 * (dashboardDTO.getStrategyId() != null ? dashboardDTO.getStrategyId() : "") +
			 * ", DIST_TOT_CONFLICT =  " + dashboardDTO.getLigTotConflict() +
			 * "KVI_FUTURE_PI =  " + (dashboardDTO.getKviFuturePI() != null ?
			 * df.format(dashboardDTO.getKviFuturePI()) : "") + ", KVI_VALUE =  " +
			 * (dashboardDTO.getKviValue() != null ? df.format(dashboardDTO.getKviValue()) :
			 * "") + ", KVI_NO_RECOMMENDED =  " + dashboardDTO.getKviNoOfRecommendation() +
			 * ", KVI_TOT_CONFLICT =  " + dashboardDTO.getKviTotConflict() +
			 * ", KVI_STRATEGY_ID =  " + (dashboardDTO.getKviStrategyId() != null ?
			 * dashboardDTO.getKviStrategyId() : "") + ", DIST_KVI_TOT_CONFLICT =  " +
			 * dashboardDTO.getLigKviTotConflict() + ", NO_OVERRIDDEN =  " +
			 * dashboardDTO.getNoOfOverridden() + ", NO_MANAGER_REVIEW =  " +
			 * dashboardDTO.getNoOfManagerReview() + ", RECOMMENDATION_RUN_ID =  " +
			 * dashboardDTO.getRecommendationRunId() + ", CURRENT_PI =  " +
			 * (dashboardDTO.getCurrentPI() != null ? df.format(dashboardDTO.getCurrentPI())
			 * : "") + ", KVI_CURRENT_PI =  " + (dashboardDTO.getKviCurrentPI() != null ?
			 * df.format(dashboardDTO.getKviCurrentPI()) : "") + ", TOT_ERROR_REC =  " +
			 * dashboardDTO.getTotErrorItem() + ", DIST_ERROR_REC =  " +
			 * dashboardDTO.getLigTotErrorItem() + ", KVI_TOT_ERROR_REC =  " +
			 * dashboardDTO.getKviTotErrorItem() + ", DIST_KVI_ERROR_REC =  " +
			 * dashboardDTO.getLigKviTotErrorItem());
			 */

			stmt.setInt(++counter, dashboardDTO.getLocationLevelId());
			stmt.setInt(++counter, dashboardDTO.getLocationId());
			stmt.setInt(++counter, dashboardDTO.getProductLevelId());
			stmt.setInt(++counter, dashboardDTO.getProductId());

			int count = stmt.executeUpdate();
			logger.info("Update count in dashboard table " + count);
		} catch (SQLException e) {
			logger.error("Error while updating future pi " + e.getMessage());
			throw new GeneralException("Error while updating future pi - " + e.getMessage());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	/**
	 * Retrieves all item list that contains the items under input product
	 * 
	 * @param conn
	 * @param itemCode
	 * @return
	 */
//	public HashMap<Integer, ArrayList<Integer>> getItemListIdMap(Connection conn, int locationLevelId, int locationId, 
//			int productLevelId, int productId){
//		PreparedStatement stmt = null;
//		ResultSet rs = null;
//		HashMap<Integer, ArrayList<Integer>> itemListIdMap = new HashMap<Integer, ArrayList<Integer>>();
//		int counter = 0;
//	    try{
//	    	stmt = conn.prepareStatement(GET_ITEM_LIST_ID);
//	    	stmt.setInt(++counter, locationLevelId);
//	    	stmt.setInt(++counter, locationId);
//	    	stmt.setInt(++counter, productLevelId);
//	    	stmt.setInt(++counter, productId);
//	    	rs = stmt.executeQuery();
//	    	while(rs.next()){
//	    		int itemCode = rs.getInt("ITEM_CODE");
//	    		if(itemListIdMap.get(itemCode) != null){
//	    			ArrayList<Integer> tList = itemListIdMap.get(itemCode);
//	    			tList.add(rs.getInt("PRICE_CHECK_LIST_ID"));
//	    			itemListIdMap.put(itemCode, tList);
//	    		}else{
//	    			ArrayList<Integer> tList = new ArrayList<Integer>();
//	    			tList.add(rs.getInt("PRICE_CHECK_LIST_ID"));
//	    			itemListIdMap.put(itemCode, tList);
//	    		}
//	    	}
//	    }catch (SQLException e){
//			logger.error("Error while retrieving item list id map" + e.getMessage());
//		}finally{
//			PristineDBUtil.close(rs);
//			PristineDBUtil.close(stmt);
//		}
//	    return itemListIdMap;
//	}

	/**
	 * Retrieves all item list and its type that contains the items under input
	 * product
	 * 
	 * @param conn
	 * @param itemCode
	 * @return
	 */
	public HashMap<ItemKey, List<PriceCheckListDTO>> getPriceCheckListInfo(Connection conn, int locationLevelId,
			int locationId, int productLevelId, int productId,String reccStartWeekDate) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<ItemKey, List<PriceCheckListDTO>> priceCheckListMap = new HashMap<ItemKey, List<PriceCheckListDTO>>();
		int counter = 0;
		ItemKey itemKey;
		executionTimeLog = new ExecutionTimeLog(PRConstants.GET_PRICE_CHECK_LIST_INFO);
		try {
			stmt = conn.prepareStatement(GET_PRICE_CHECK_LIST_INFO);
			// stmt.setInt(++counter, locationLevelId);
			// stmt.setInt(++counter, locationId);
			stmt.setString(++counter, reccStartWeekDate);
			stmt.setInt(++counter, productLevelId);
			stmt.setInt(++counter, productId);
			rs = stmt.executeQuery();
			logger.debug("GET_PRICE_CHECK_LIST_INFO:" + GET_PRICE_CHECK_LIST_INFO + "Counters,1:" + reccStartWeekDate +" ,2. "+ productLevelId
				+ ",3:" + productId);

			while (rs.next()) {
				int itemCode = rs.getInt("ITEM_CODE");
				// String lirInd = rs.getString("LIR_IND");
				int retLirId = rs.getInt("RET_LIR_ID");

				itemKey = PRCommonUtil.getItemKey(itemCode, false);
				if (retLirId > 0) {
					itemKey = PRCommonUtil.getItemKey(retLirId, true);
				} else {
					itemKey = PRCommonUtil.getItemKey(itemCode, false);
				}

				List<PriceCheckListDTO> tList = null;
				if (priceCheckListMap.get(itemKey) != null) {
					tList = priceCheckListMap.get(itemKey);
				} else {
					tList = new ArrayList<PriceCheckListDTO>();
				}
				PriceCheckListDTO pDTO = new PriceCheckListDTO();
				pDTO.setPriceCheckListId(rs.getInt("PRICE_CHECK_LIST_ID"));
				pDTO.setPriceCheckListTypeId(rs.getInt("PRICE_CHECK_LIST_TYPE_ID"));
				pDTO.setLocationLevelId(rs.getInt("LOCATION_LEVEL_ID"));
				pDTO.setLocationId(rs.getInt("LOCATION_ID"));
				pDTO.setMinRetail(rs.getDouble("MIN_PRICE"));
				pDTO.setMaxRetail(rs.getDouble("MAX_PRICE"));
				pDTO.setLockedRetail(rs.getDouble("LOCKED_RETAIL"));
				pDTO.setEndDate(rs.getString("END_DATE"));
				pDTO.setCreateDate(rs.getString("CREATE_DATETIME"));
				pDTO.setUpdateDate(rs.getString("UPDATE_DATETIME"));
				pDTO.setCheckListTypeName(rs.getString("CHECKLIST_NAME").toUpperCase());
				pDTO.setItemCode(itemCode);
				// 09-Jun-2017 : Code added to Precedence of Item List
				if (rs.getObject("PRECEDENCE") != null) {
					pDTO.setPrecedence(rs.getInt("PRECEDENCE"));
				} else {
					pDTO.setPrecedence(null);
				}

				tList.add(pDTO);
				priceCheckListMap.put(itemKey, tList);
			}
		} catch (SQLException e) {
			logger.error("Error while retrieving price check list info " + e.getMessage());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		executionTimeLog.setEndTime();
		executionTimeLogs.add(executionTimeLog);
		return priceCheckListMap;
	}

	private String getQueryCondition(int productLevelId, int productId) {
		StringBuffer subQuery = new StringBuffer("");
		if (productLevelId > 1) {
			subQuery = new StringBuffer("start with product_level_id = ? ");
			if (productId > 0) {
				subQuery.append(" and product_id = ? ");
			}
			subQuery.append(
					"connect by  prior child_product_id = product_id  and  prior child_product_level_id = product_level_id");
		} else if (productLevelId == 1) {
			subQuery = new StringBuffer("where child_product_level_id = 1 and child_product_id = ?");
		}

		return subQuery.toString();
	}

	private String getQueryCondition(int productLevelId, String productIdList) {
		StringBuffer subQuery = new StringBuffer("");
		if (productLevelId > 1) {
			subQuery = new StringBuffer("start with product_level_id = ? ");
			subQuery.append(" and product_id IN ( ").append(productIdList).append(") ");
			subQuery.append(
					"connect by  prior child_product_id = product_id  and  prior child_product_level_id = product_level_id");
		} else if (productLevelId == 1) {
			subQuery = new StringBuffer("where child_product_level_id = 1 and child_product_id = ?");
		}

		return subQuery.toString();
	}

	/**
	 * Returns map containing store list id as key and list of store is as its value
	 * 
	 * @param conn
	 * @param zoneListId
	 * @return
	 * @throws GeneralException
	 */
	public HashMap<Integer, ArrayList<Integer>> getStoresUnderStoreListForZone(Connection conn, int priceZoneId)
			throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<Integer, ArrayList<Integer>> storeListMap = new HashMap<Integer, ArrayList<Integer>>();
		try {
			stmt = conn.prepareStatement(GET_STORES_UNDER_STORE_LIST_FOR_ZONE);
			stmt.setInt(1, priceZoneId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				int storeListId = rs.getInt("LOCATION_ID");
				int storeId = rs.getInt("CHILD_LOCATION_ID");
				if (storeListMap.get(storeListId) != null) {
					ArrayList<Integer> tList = storeListMap.get(storeListId);
					tList.add(storeId);
					storeListMap.put(storeListId, tList);
				} else {
					ArrayList<Integer> tList = new ArrayList<Integer>();
					tList.add(storeId);
					storeListMap.put(storeListId, tList);
				}
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving stores under store list for zone - " + exception);
			throw new GeneralException("Error when retrieving stores under store list for zone - " + exception);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return storeListMap;
	}

	public Integer getPriceZoneIdForStore(Connection conn, int compStrId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		Integer priceZoneId = -1;
		try {
			stmt = conn.prepareStatement(GET_ZONE_ID_FOR_STORE);
			stmt.setInt(1, compStrId);
			rs = stmt.executeQuery();
			if (rs.next()) {
				priceZoneId = rs.getInt("PRICE_ZONE_ID");
			}
		} catch (SQLException exception) {
			logger.error("Error when retrieving zone id for store - " + exception);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return priceZoneId;
	}

	public HashMap<Integer, HashMap<Integer, CompetitiveDataDTO>> getLatestCompPrice(Connection conn,
			HashMap<Integer, String> competitors, int productLevelId, int productId, String weekStartDate,
			int maxDataLookupRange) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<Integer, HashMap<Integer, CompetitiveDataDTO>> compDataMap = new HashMap<Integer, HashMap<Integer, CompetitiveDataDTO>>();
		int counter = 0;
		try {
			if (competitors.size() > 0) {
				Object[] values = competitors.keySet().toArray();

				String query = new String(GET_COMP_DATA);
				String subQuery = getQueryCondition(productLevelId, productId);
				query = query.replaceAll("%QUERY_CONDITION%", subQuery);

				stmt = conn.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));

				if (productLevelId > 1) {
					stmt.setInt(++counter, productLevelId);
					if (productId > 0) {
						stmt.setLong(++counter, productId);
					}
				} else if (productLevelId == 1) {
					stmt.setLong(++counter, productId);
				}

				stmt.setString(++counter, weekStartDate);
				stmt.setString(++counter, weekStartDate);
				stmt.setInt(++counter, maxDataLookupRange);
				PristineDBUtil.setValues(stmt, ++counter, values);

				if (competitors.keySet().size() > 0) {
					StringBuilder sb = new StringBuilder();
					for (Integer comp : competitors.keySet()) {
						sb.append(comp).append(",");
					}
//					logger.debug("Query Fetching Comp Data for Multiple Competitor: " + query);
//					logger.debug("Counters:" + productLevelId + "-" + productId + "-" + weekStartDate + "-"
//							+ weekStartDate + "-" + maxDataLookupRange + "-" + sb.toString());
				}

				stmt.setFetchSize(100000);
				rs = stmt.executeQuery();

				while (rs.next()) {
					CompetitiveDataDTO compDataDTO = new CompetitiveDataDTO();
					compDataDTO.itemcode = rs.getInt("ITEM_CODE");
					if (compDataDTO.itemcode > 0) {
						compDataDTO.compStrId = rs.getInt("COMP_STR_ID");
						compDataDTO.weekStartDate = rs.getString("START_DATE");
						compDataDTO.regPrice = rs.getFloat("REG_UNIT_PRICE");
						compDataDTO.regMPack = rs.getInt("REG_M_PACK");
						compDataDTO.regMPrice = rs.getInt("REG_M_PRICE");
						compDataDTO.lirId = rs.getInt("RET_LIR_ID");
						compDataDTO.retailerItemCode = rs.getString("RETAILER_ITEM_CODE");
						compDataDTO.effRegRetailStartDate = rs.getString("EFF_REG_START_DATE");
						// If there is no check assume it is checked on week
						// start date
						if (rs.getString("CHECK_DATETIME") != null)
							compDataDTO.checkDate = rs.getString("CHECK_DATETIME");
						else
							compDataDTO.checkDate = rs.getString("START_DATE");

						HashMap<Integer, CompetitiveDataDTO> compMap = new HashMap<>();
						if (compDataMap.get(compDataDTO.compStrId) != null) {
							compMap = compDataMap.get(compDataDTO.compStrId);
						}

						if (compMap.get(compDataDTO.itemcode) == null) {
							compMap.put(compDataDTO.itemcode, compDataDTO);
						} 
						//Fix done by Karishma on 05/24 
						//if the item is already added in map then compare the check date and set row with the latest price 	
						else {
							CompetitiveDataDTO compMapTemp = compMap.get(compDataDTO.itemcode);
							if (DateUtil.toDate(compDataDTO.checkDate)
									.compareTo(DateUtil.toDate(compMapTemp.checkDate)) > 0) {
								compMap.put(compDataDTO.itemcode, compDataDTO);
							}
						}

						compDataMap.put(compDataDTO.compStrId, compMap);
					}
				}
			}

		} catch (SQLException exception) {
			logger.error("Error in getCompData() - " + exception);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}

		return compDataMap;
	}

	public List<PRProductGroupProperty> getProductGroupProperties(Connection conn, List<ProductDTO> productList)
			throws OfferManagementException {
		List<PRProductGroupProperty> productGroupProperties = new ArrayList<PRProductGroupProperty>();
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			String query = new String(GET_PRD_GRP_PROPERTY);
			String products = "";
			int prdCnt = 1;

			for (ProductDTO productDTO : productList) {
				products = products + "(PRODUCT_LEVEL_ID = " + productDTO.getProductLevelId() + " AND PRODUCT_ID = "
						+ productDTO.getProductId() + ")";
				if (prdCnt < productList.size()) {
					products = products + " OR ";
				}
				prdCnt = prdCnt + 1;
			}

			query = query.replaceAll("%PRODUCTS%", products);
			stmt = conn.prepareStatement(query);
			stmt.setFetchSize(100000);
			rs = stmt.executeQuery();
			while (rs.next()) {
				PRProductGroupProperty productGroupProperty = new PRProductGroupProperty();

				productGroupProperty.setProductLevelId(rs.getInt("PRODUCT_LEVEL_ID"));
				productGroupProperty.setProductId(rs.getInt("PRODUCT_ID"));

//		        if(rs.getString("IS_ORDER_SELL_CODE").charAt(0) == Constants.YES)
//		        	productGroupProperty.setIsOrderSellCode(true);
//		        else
//		        	productGroupProperty.setIsOrderSellCode(false);

				if (rs.getString("IS_PERISHABLE").charAt(0) == Constants.YES)
					productGroupProperty.setIsPerishable(true);
				else
					productGroupProperty.setIsPerishable(false);

				if (rs.getString("USE_PREDICTION").charAt(0) == Constants.YES)
					productGroupProperty.setIsUsePrediction(true);
				else
					productGroupProperty.setIsUsePrediction(false);

				productGroupProperties.add(productGroupProperty);
			}

		} catch (Exception ex) {
			throw new OfferManagementException("Error in getProductGroupProperties() - " + ex,
					RecommendationErrorCode.DB_PRODUCT_GROUP_PROPERTY);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return productGroupProperties;
	}

	/*
	 * Dinesh::10-APR-18, Commented below method, Order and Sell code old tables are
	 * not available anymore
	 */
	/*
	 * // public List<PROrderCode> getOrderAndSellCodeOld(Connection conn, int
	 * productLevelId, int productId) throws Exception{ // // PreparedStatement stmt
	 * = null; // ResultSet rs = null; // List<PROrderCode> orderCodes = new
	 * ArrayList<PROrderCode>(); // String query; // int vCounter = 0; //
	 * HashMap<String, PROrderCode> orderCodeMap = new HashMap<String,
	 * PROrderCode>(); // // try { // query = new String(GET_ORDER_SELL_CODE_OLD);
	 * // query = query.replaceAll("%QUERY_CONDITION%",
	 * getQueryCondition(productLevelId, productId)); // stmt =
	 * conn.prepareStatement(query); // // if (productLevelId > 1) { //
	 * stmt.setInt(++vCounter, productLevelId); // if (productId > 0) { //
	 * stmt.setLong(++vCounter, productId); // } // } else if (productLevelId == 1)
	 * { // stmt.setLong(++vCounter, productId); // } // // rs =
	 * stmt.executeQuery(); // while (rs.next()) { // String orderCode =
	 * rs.getString("ORDER_CODE"); // PROrderCode orderCodeObj; // PRSellCode
	 * sellCode = new PRSellCode(); // if(orderCodeMap.get(orderCode) != null){ //
	 * orderCodeObj = orderCodeMap.get(orderCode); // }else{ // orderCodeObj = new
	 * PROrderCode(); // } // // sellCode.setSellCode(rs.getString("SELL_CODE")); //
	 * sellCode.setItemCode(rs.getInt("ITEM_CODE")); // /*if (rs.getObject("YIELD")
	 * != null) { // sellCode.setYield(rs.getDouble("YIELD")); // }else{ //
	 * sellCode.setYield(null); // }
	 */
//				sellCode.setYield(rs.getDouble("YIELD"));
//				orderCodeObj.setOrderCode(orderCode);
//				orderCodeObj.getSellCodes().add(sellCode);
//				orderCodeMap.put(orderCode, orderCodeObj);
//			}
//		} catch (Exception ex) {
//			logger.error("Error in getOrderAndSellCode() -- " + ex.toString(), ex);
//			throw new Exception();
//		} finally {
//			PristineDBUtil.close(rs);
//			PristineDBUtil.close(stmt);
//		}
//		
//		for(Map.Entry<String, PROrderCode> entry : orderCodeMap.entrySet()){
//			orderCodes.add(entry.getValue());
//		}
//		
//		return orderCodes;
//	}
//
//	public List<PROrderCode> getOrderAndSellCode(Connection conn, int productLevelId, int productId) throws Exception{
//		
//		PreparedStatement stmt = null;
//		ResultSet rs = null;
//		List<PROrderCode> orderCodes = new ArrayList<PROrderCode>();
//		String query;
//		int vCounter = 0;
//		HashMap<String, PROrderCode> orderCodeMap = new HashMap<String, PROrderCode>();
//		
//		try {
//			query = new String(GET_ORDER_SELL_CODE);
//			query = query.replaceAll("%QUERY_CONDITION%", getQueryCondition(productLevelId, productId));
//			stmt = conn.prepareStatement(query);
//
//			if (productLevelId > 1) {
//				stmt.setInt(++vCounter, productLevelId);
//				if (productId > 0) {
//					stmt.setLong(++vCounter, productId);
//				}
//			} else if (productLevelId == 1) {
//				stmt.setLong(++vCounter, productId);
//			}
//			
//			if (productLevelId > 1) {
//				stmt.setInt(++vCounter, productLevelId);
//				if (productId > 0) {
//					stmt.setLong(++vCounter, productId);
//				}
//			} else if (productLevelId == 1) {
//				stmt.setLong(++vCounter, productId);
//			}
//			if (productLevelId > 1) {
//				stmt.setInt(++vCounter, productLevelId);
//				if (productId > 0) {
//					stmt.setLong(++vCounter, productId);
//				}
//			} else if (productLevelId == 1) {
//				stmt.setLong(++vCounter, productId);
//			}
//
//			rs = stmt.executeQuery();
//			while (rs.next()) {
//				String orderCode = rs.getString("ORDER_CODE"); 
//				PROrderCode orderCodeObj;
//				PRSellCode sellCode = new PRSellCode();
//				if(orderCodeMap.get(orderCode) != null){
//					orderCodeObj = orderCodeMap.get(orderCode);
//				}else{
//					orderCodeObj = new PROrderCode();					
//				}
//				
//				sellCode.setSellCode(rs.getString("SELL_CODE"));
//				sellCode.setItemCode(rs.getInt("ITEM_CODE"));				
//				/*if (rs.getObject("YIELD") != null) {
//					sellCode.setYield(rs.getDouble("YIELD"));
//				}else{
//					sellCode.setYield(null);
//				}*/
//				sellCode.setYield(rs.getDouble("YIELD"));
//				orderCodeObj.setOrderCode(orderCode);
//				orderCodeObj.getSellCodes().add(sellCode);
//				orderCodeMap.put(orderCode, orderCodeObj);
//			}
//		} catch (Exception ex) {
//			logger.error("Error in getOrderAndSellCode() -- " + ex.toString(), ex);
//			throw new Exception();
//		} finally {
//			PristineDBUtil.close(rs);
//			PristineDBUtil.close(stmt);
//		}
//		
//		for(Map.Entry<String, PROrderCode> entry : orderCodeMap.entrySet()){
//			orderCodes.add(entry.getValue());
//		}
//		
//		return orderCodes;
//	}

	public void insertOrderCodeRecommendation(Connection conn, long runId, List<PROrderCode> orderCodeList)
			throws Exception {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(INSERT_ORDER_CODE_RECOMMENDATION);
			int itemNoInBatch = 0;
			for (PROrderCode orderCode : orderCodeList) {
				// Ignore if order code recommendation is 0
				if (orderCode.getRecommendedRegPrice() > 0) {
					int counter = 0;

					stmt.setLong(++counter, runId);
					stmt.setInt(++counter, orderCode.getLocationLevelId());
					stmt.setInt(++counter, orderCode.getLocationId());
					stmt.setInt(++counter, orderCode.getOrderItemCode());
					stmt.setInt(++counter, orderCode.getFreshRelationHeaderId());

					if (orderCode.getRecommendedRegPrice() <= 0) {
						stmt.setNull(++counter, java.sql.Types.INTEGER);
						stmt.setNull(++counter, java.sql.Types.DOUBLE);
					} else {
						stmt.setInt(++counter, orderCode.getRecommendedRegMultiple());
						stmt.setDouble(++counter, orderCode.getRecommendedRegPrice());
					}

					stmt.addBatch();
					itemNoInBatch++;
				}

				if (itemNoInBatch % Constants.BATCH_UPDATE_COUNT == 0) {
					int[] count = stmt.executeBatch();
					stmt.clearBatch();
					itemNoInBatch = 0;
				}
			}
			if (itemNoInBatch > 0) {
				int[] count = stmt.executeBatch();
				stmt.clearBatch();
			}
		} catch (SQLException ex) {
			logger.error("Error in insertOrderCodeRecommendation() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public PRRecommendationRunHeader getRecommendationRunHeader(Connection conn, long runId) throws Exception {
		PRRecommendationRunHeader recommendationRunHeader = new PRRecommendationRunHeader();
		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {
			String query = new String(GET_RECOMMENDATION_RUN_HEADER);
			stmt = conn.prepareStatement(query);
			stmt.setLong(1, runId);
			rs = stmt.executeQuery();
			if (rs.next()) {
				recommendationRunHeader.setRunId(rs.getLong("RUN_ID"));
				recommendationRunHeader.setProductLevelId(rs.getInt("PRODUCT_LEVEL_ID"));
				recommendationRunHeader.setProductId(rs.getInt("PRODUCT_ID"));
				recommendationRunHeader.setLocationLevelId(rs.getInt("LOCATION_LEVEL_ID"));
				recommendationRunHeader.setLocationId(rs.getInt("LOCATION_ID"));
				recommendationRunHeader.setCalendarId(rs.getInt("CALENDAR_ID"));
				recommendationRunHeader.setCurRetailCalendarId(rs.getInt("CUR_RETAIL_CALENDAR_ID"));
				recommendationRunHeader.setStartRunTime(rs.getString("START_RUN_TIME"));
				recommendationRunHeader.setStartDate(rs.getString("START_DATE"));
				recommendationRunHeader.setEndDate(rs.getString("END_DATE"));
			}
		} catch (Exception ex) {
			logger.error("Error in getRecommendationRunHeader() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return recommendationRunHeader;
	}

	public HashMap<PredictionEngineKey, PredictionEngineValue> getAllRecommendationItem(Connection conn,
			List<PredictionInputDTO> predictionInputDTOs) throws Exception {
//		logger.debug("Inside getAllRecommendationItem()");

		HashMap<PredictionEngineKey, PredictionEngineValue> predictionMap = new HashMap<PredictionEngineKey, PredictionEngineValue>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
//		PredictionEngineOutput predictionEngineOutput =  new PredictionEngineOutput();
		String queryCondition = "";
		int locationLevelId;
		int locationId;
		int itemCode;

		try {

			String query = new String(GET_ALL_RECOMMENDATION_DATA);
			// Check recommendation run id is there
			for (PredictionInputDTO predictionInputDTO : predictionInputDTOs) {
				if (predictionInputDTO.recommendationRunId > 0) {
					queryCondition = queryCondition + "," + predictionInputDTO.recommendationRunId;
				}
			}

			queryCondition = queryCondition != "" ? queryCondition.substring(1) : queryCondition;

//			if(locationLevelId > 0 && locationId > 0){
//				query = query.replaceAll("%QUERY_CONDITION%", "AND CHILD_LOCATION_LEVEL_ID = " + locationLevelId 
//						+ " AND CHILD_LOCATION_ID = " + locationId);
//			}
			if (queryCondition != "") {
				query = query.replaceAll("%QUERY_CONDITION%", queryCondition);
//				logger.debug("getAllRecommendationItem() Query" + query);
				stmt = conn.prepareStatement(query);
				rs = stmt.executeQuery();
				while (rs.next()) {
					locationLevelId = rs.getInt("CHILD_LOCATION_LEVEL_ID");
					locationId = rs.getInt("CHILD_LOCATION_ID");
					itemCode = rs.getInt("ITEM_CODE");
					// PredictionEngineKey predictionEngineKey = new
					// PredictionEngineKey(locationLevelId, locationId, Double.valueOf(itemCode),
					// 0);
					PredictionEngineKey predictionEngineKey = new PredictionEngineKey(locationLevelId, locationId,
							itemCode, 0, 0, 0, 0, 0, 0, 0, 0);
					PredictionEngineValue predictionEngineValue = new PredictionEngineValue(
							rs.getDouble("AVG_MOVEMENT"), PredictionStatus.SUCCESS, "", "", 0, 0, 0);
					predictionMap.put(predictionEngineKey, predictionEngineValue);
				}
			}
		} catch (Exception ex) {
			logger.error("Error in getAllRecommendationItem() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return predictionMap;
	}

	public HashMap<Integer, Integer> getStateOfStores(Connection conn, int zoneId) throws Exception {
		logger.debug("Inside getStateOfStores()");
		HashMap<Integer, Integer> stateOfStores = new HashMap<Integer, Integer>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			String query = new String(GET_STATE_OF_STORES);
			stmt = conn.prepareStatement(query);
			stmt.setLong(1, zoneId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				stateOfStores.put(rs.getInt("COMP_STR_ID"), rs.getInt("STATE_ID"));
			}

		} catch (Exception ex) {
			logger.error("Error in getStateOfStores() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return stateOfStores;
	}

	public void insertExecutionTimeLog(Connection conn, PRRecommendationRunHeader recommendationRunHeader,
			List<ExecutionTimeLog> executionTimeLogs) {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(INSERT_EXECUTION_TIME_LOG);
			int itemNoInBatch = 0;
			for (ExecutionTimeLog executionTimeLog : executionTimeLogs) {
				int counter = 0;

				stmt.setLong(++counter, recommendationRunHeader.getRunId());
				stmt.setInt(++counter, recommendationRunHeader.getCalendarId());
				stmt.setInt(++counter, recommendationRunHeader.getLocationLevelId());
				stmt.setInt(++counter, recommendationRunHeader.getLocationId());
				stmt.setInt(++counter, recommendationRunHeader.getProductLevelId());
				stmt.setInt(++counter, recommendationRunHeader.getProductId());
				stmt.setInt(++counter, executionTimeLog.getExecutionOrder());
				stmt.setString(++counter, executionTimeLog.getFunctionalityName());
				stmt.setInt(++counter, executionTimeLog.getPricePoints());

				if (executionTimeLog.getStartTime() != null)
					stmt.setTimestamp(++counter, new Timestamp(executionTimeLog.getStartTime().getTime()));
				else
					stmt.setNull(++counter, Types.DATE);

				if (executionTimeLog.getEndTime() != null)
					stmt.setTimestamp(++counter, new Timestamp(executionTimeLog.getEndTime().getTime()));
				else
					stmt.setNull(++counter, Types.DATE);

				stmt.setString(++counter, executionTimeLog.getTotalTime());
				stmt.setLong(++counter, executionTimeLog.getTotalTimeSeconds());

				stmt.addBatch();
				itemNoInBatch++;

				if (itemNoInBatch % Constants.BATCH_UPDATE_COUNT == 0) {
					int[] count = stmt.executeBatch();
					stmt.clearBatch();
					itemNoInBatch = 0;
				}
			}
			if (itemNoInBatch > 0) {
				int[] count = stmt.executeBatch();
				stmt.clearBatch();
			}
		} catch (SQLException ex) {
			logger.error("Error in insertExecutionTimeLog() -- " + ex.toString(), ex);
			// throw new Exception();
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public HashMap<Long, Integer> getStoreRecommendationCount(Connection conn, List<Long> runIds)
			throws GeneralException {
		logger.debug("Inside getStoreRecommendationCount()");
		HashMap<Long, Integer> runAndItsStoreCnt = new HashMap<Long, Integer>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			String runs = "";
			for (Long runId : runIds) {
				runs = runs + "," + runId;
			}
			runs = runs.substring(1);
			String query = new String(GET_STORE_REC_COUNT);
			query = query.replaceAll("%RUN_IDS%", runs);
			stmt = conn.prepareStatement(query);
			rs = stmt.executeQuery();
			while (rs.next()) {
				if (rs.getInt("STORE_REC_CNT") > 0) {
					runAndItsStoreCnt.put(rs.getLong("RUN_ID"), rs.getInt("STORE_REC_CNT"));
				}
			}

		} catch (Exception ex) {
			logger.error("Error in getStoreRecommendationCount() -- " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return runAndItsStoreCnt;
	}

	public HashMap<Long, Long> getCategoryLevelStrategyId(Connection conn, List<Long> runIds) throws GeneralException {
		logger.debug("Inside getCategoryLevelStrategyId()");
		HashMap<Long, Long> runAndItsCatLevelStrategyId = new HashMap<Long, Long>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			String runs = "";
			for (Long runId : runIds) {
				runs = runs + "," + runId;
			}
			runs = runs.substring(1);
			String query = new String(GET_CATEGORY_LEVEL_STRATEGY);
			query = query.replaceAll("%RUN_IDS%", runs);
			stmt = conn.prepareStatement(query);
			rs = stmt.executeQuery();
			while (rs.next()) {
				if (rs.getObject("STRATEGY_ID") != null) {
					runAndItsCatLevelStrategyId.put(rs.getLong("RUN_ID"), rs.getLong("STRATEGY_ID"));
				}
			}
		} catch (Exception ex) {
			logger.error("Error in getCategoryLevelStrategyId() -- " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}

		return runAndItsCatLevelStrategyId;
	}

//	public HashMap<Long, PRStrategyDTO> getCategoryLevelPriceIndex(Connection conn, List<Long> runIds) throws GeneralException {
//		logger.debug("Inside getPriceIndexValue()");
//		HashMap<Long, PRStrategyDTO> runAndItsPriceIndexValue = new HashMap<Long, PRStrategyDTO>();
//		PreparedStatement stmt = null;
//		ResultSet rs = null;
//		try {
//			String runs = "";
//			for (Long runId : runIds) {
//				runs = runs + "," + runId;
//			}
//			runs = runs.substring(1);
//			String query = new String(GET_PI_STRATEGY);
//			query = query.replaceAll("%RUN_IDS%", runs);
//			stmt = conn.prepareStatement(query);
//			stmt.setInt(1, GuidelineTypeLookup.PRICE_INDEX.getGuidelineTypeId());
//			rs = stmt.executeQuery();
//			while (rs.next()) {
//				if (rs.getObject("STRATEGY_ID") != null) {
//					if (rs.getObject("PI_MIN_VALUE") == null && rs.getObject("PI_MAX_VALUE") == null) {
//					} else {
//						//ignore item level Price Index Guideline
//						if (rs.getString("PI_IS_ITEM_LEVEL") != null && rs.getString("PI_IS_ITEM_LEVEL").charAt(0) == Constants.NO) {
//							PRStrategyDTO strategyDTO = new PRStrategyDTO();
//							PRGuidelinesDTO guidelinesDTO = new PRGuidelinesDTO();
//							PRGuidelinePI guidelinePI = new PRGuidelinePI();
//							List<PRGuidelinePI> guidelinePIs = new ArrayList<PRGuidelinePI>();
//							strategyDTO.setStrategyId(rs.getLong("STRATEGY_ID"));
//
//							if (rs.getObject("PI_MIN_VALUE") == null)
//								guidelinePI.setMinValue(Constants.DEFAULT_NA);
//							else
//								guidelinePI.setMinValue(rs.getDouble("PI_MIN_VALUE"));
//
//							if (rs.getObject("PI_MAX_VALUE") == null)
//								guidelinePI.setMaxValue(Constants.DEFAULT_NA);
//							else
//								guidelinePI.setMaxValue(rs.getDouble("PI_MAX_VALUE"));
//
//							guidelinePIs.add(guidelinePI);
//							guidelinesDTO.setPiGuideline(guidelinePIs);
//							strategyDTO.setGuidelines(guidelinesDTO);
//							runAndItsPriceIndexValue.put(rs.getLong("RUN_ID"), strategyDTO);
//						}
//					}
//				}
//			}
//
//		} catch (Exception ex) {
//			logger.error("Error in getPriceIndexValue() -- " + ex.toString(), ex);
//			throw new GeneralException(ex.toString());
//		} finally {
//			PristineDBUtil.close(rs);
//			PristineDBUtil.close(stmt);
//		}
//		return runAndItsPriceIndexValue;
//	}

	public HashMap<Long, List<PRItemDTO>> getRecItemsOfRunIds(Connection conn, List<Long> runIds)
			throws GeneralException {
		logger.debug("Inside getRecItemsOfRunIds()");
		HashMap<Long, List<PRItemDTO>> runAndItsItem = new HashMap<Long, List<PRItemDTO>>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ObjectMapper mapper = new ObjectMapper();
		PRStrategyDTO strategyDTO;
		try {
			String runs = "";
			for (Long runId : runIds) {
				runs = runs + "," + runId;
			}
			runs = runs.substring(1);
			String query = new String(GET_REC_ITEMS_OF_RUNS);
			query = query.replaceAll("%RUN_IDS%", runs);
			stmt = conn.prepareStatement(query);
			rs = stmt.executeQuery();
			while (rs.next()) {
				List<PRItemDTO> itemsOfRun;
				PRItemDTO itemDTO = new PRItemDTO();

				Long runId = rs.getLong("RUN_ID");
				String lirInd = rs.getString("LIR_IND");
				String isSubstitute = rs.getString("IS_SUBSTITUTE");
				if (runAndItsItem.get(runId) == null)
					itemsOfRun = new ArrayList<PRItemDTO>();
				else
					itemsOfRun = runAndItsItem.get(runId);

				itemDTO.setRunId(runId);
				itemDTO.setRecommendationId(rs.getLong("PR_RECOMMENDATION_ID"));
				itemDTO.setItemCode(rs.getInt("ITEM_CODE"));
				itemDTO.setStrategyId(rs.getLong("STRATEGY_ID"));
				itemDTO.setCostChgIndicator(rs.getInt("COST_CHG_IND"));
				if (rs.getObject("CUR_LIST_COST") != null)
					itemDTO.setListCost(rs.getDouble("CUR_LIST_COST"));
				if (rs.getObject("CUR_VIP_COST") != null)
					itemDTO.setVipCost(rs.getDouble("CUR_VIP_COST"));
				if (rs.getObject("RET_LIR_ID") != null)
					itemDTO.setRetLirId(rs.getInt("RET_LIR_ID"));
				if (rs.getObject("PRICE_CHECK_LIST_ID") != null)
					itemDTO.setPriceCheckListId(rs.getInt("PRICE_CHECK_LIST_ID"));
				// itemDTO.setRecommendedRegMultiple(rs.getInt("RECOMMENDED_REG_MULTIPLE"));
				// if(rs.getObject("RECOMMENDED_REG_PRICE") != null)
				// itemDTO.setRecommendedRegPrice(rs.getDouble("RECOMMENDED_REG_PRICE"));
				if (rs.getObject("RECOMMENDED_REG_PRICE") != null)
					itemDTO.setRecommendedRegPrice(new MultiplePrice(rs.getInt("RECOMMENDED_REG_MULTIPLE"),
							rs.getDouble("RECOMMENDED_REG_PRICE")));
				itemDTO.setRecRegPriceBeforeReRecommedation(new MultiplePrice(rs.getInt("RECOMMENDED_REG_MULTIPLE"),
						rs.getDouble("RECOMMENDED_REG_PRICE")));
				if (rs.getObject("OVERRIDE_REG_PRICE") != null)
					itemDTO.setOverrideRegPrice(rs.getDouble("OVERRIDE_REG_PRICE"));
				int priceAdjustedFlag = rs.getInt("IS_REC_PRICE_ADJUSTED");
				if (priceAdjustedFlag == 1)
					itemDTO.setIsPriceAdjusted(true);
				else
					itemDTO.setIsPriceAdjusted(false);
				// if (rs.getObject("REC_PRICE_BEFORE_ADJUST") != null)
				// itemDTO.setRecPriceBeforeAdjustment(rs.getDouble("REC_PRICE_BEFORE_ADJUST"));
				itemDTO.setCurRegPricePredictedMovement(rs.getDouble("CUR_REG_PRICE_PREDICTED_MOV"));
				if (rs.getObject("REC_PRICE_BEFORE_ADJUST") != null)
					itemDTO.setRecPriceBeforeAdjustment(new MultiplePrice(PRConstants.DEFAULT_REG_MULTIPLE,
							rs.getDouble("REC_PRICE_BEFORE_ADJUST")));
				if (rs.getObject("CUR_COMP_REG_PRICE") != null) {
					MultiplePrice multiplePrice = new MultiplePrice(rs.getInt("CUR_COMP_REG_MULTIPLE"),
							rs.getDouble("CUR_COMP_REG_PRICE"));
					itemDTO.setCompPrice(multiplePrice);
				} else {
					itemDTO.setCompPrice(null);
				}
				if (String.valueOf(Constants.YES).equalsIgnoreCase(lirInd)) {
					itemDTO.setLir(true);
				}
				itemDTO.setIsConflict(rs.getInt("IS_CONFLICT"));
				itemDTO.setExplainLog(mapper.readValue(rs.getString("LOG"), PRExplainLog.class));
				// itemDTO.setChildLocationLevelId(rs.getInt("CHILD_LOCATION_LEVEL_ID"));
				// itemDTO.setChildLocationId(rs.getInt("CHILD_LOCATION_ID"));
				// itemDTO.setStartCalendarId(rs.getInt("CALENDAR_ID"));
				// itemDTO.setEndCalendarId(rs.getInt("CALENDAR_ID"));
				// itemDTO.setPredictionStatus(rs.getInt("PREDICTION_STATUS"));
				if (rs.getObject("PREDICTION_STATUS") != null)
					itemDTO.setPredictionStatus(rs.getInt("PREDICTION_STATUS"));
				else
					itemDTO.setPredictionStatus(null);

				if (rs.getObject("PREDICTED_MOVEMENT") != null)
					itemDTO.setPredictedMovement(rs.getDouble("PREDICTED_MOVEMENT"));

				if (rs.getObject("OPPORTUNITY_PRICE") != null)
					itemDTO.setOppurtunityPrice(rs.getDouble("OPPORTUNITY_PRICE"));

				if (rs.getObject("OPPORTUNITY_QUANTITY") != null)
					itemDTO.setOppurtunityQty(rs.getInt("OPPORTUNITY_QUANTITY"));

				if (rs.getObject("IS_OPPORTUNITY") != null)
					itemDTO.setIsOppurtunity(rs.getString("IS_OPPORTUNITY"));

				itemDTO.setAvgMovement(rs.getDouble("AVG_MOVEMENT"));

				itemDTO.setIsPrePriced(rs.getInt("IS_PRE_PRICED"));

				if (String.valueOf(Constants.YES).equalsIgnoreCase(isSubstitute)) {
					itemDTO.setIsPartOfSubstituteGroup(true);
				}
				itemDTO.setIsLocPriced(rs.getInt("IS_LOCKED_PRICE"));

				itemDTO.setRegMPack(rs.getInt("CUR_REG_MULTIPLE"));
				if (itemDTO.getRegMPack() > 1)
					itemDTO.setRegMPrice(rs.getDouble("CUR_REG_PRICE"));
				else
					itemDTO.setRegPrice(rs.getDouble("CUR_REG_PRICE"));

				itemDTO.setRegPricePredReasons(rs.getString("REC_REG_PRED_REASONS"));
				itemDTO.setSalePricePredReasons(rs.getString("REC_SALE_PRED_REASONS"));

				strategyDTO = new PRStrategyDTO();
				strategyDTO.setLocationLevelId(rs.getInt("STRATEGY_LOCATION_LEVEL_ID"));
				strategyDTO.setLocationId(rs.getInt("STRATEGY_LOCATION_ID"));
				strategyDTO.setProductLevelId(rs.getInt("STRATEGY_PRODUCT_LEVEL_ID"));
				strategyDTO.setProductId(rs.getInt("STRATEGY_PRODUCT_ID"));
				strategyDTO.setApplyTo(rs.getInt("STRATEGY_APPLY_TO"));
				strategyDTO.setVendorId(rs.getInt("STRATEGY_VENDOR_ID"));
				strategyDTO.setStateId(rs.getInt("STRATEGY_STATE_ID"));

				// Added overridden Reg price and qty info
				itemDTO.setStrategyDTO(strategyDTO);
				if (rs.getObject("OVERRIDE_REG_PRICE") != null) {
					MultiplePrice overriddenPrice = new MultiplePrice(rs.getInt("OVERRIDE_REG_MULTIPLE"),
							rs.getDouble("OVERRIDE_REG_PRICE"));
					itemDTO.setOverriddenRegularPrice(overriddenPrice);
				} else {
					itemDTO.setOverriddenRegularPrice(null);
				}
				// Added UPC info
				itemDTO.setUpc(rs.getString("UPC"));

				// Sale Price info
				PRItemSaleInfoDTO saleInfoDTO = new PRItemSaleInfoDTO();
				if (rs.getInt("REC_WEEK_SALE_MULTIPLE") > 0 && rs.getDouble("REC_WEEK_SALE_PRICE") > 0) {
					saleInfoDTO.setSalePrice(PRCommonUtil.getMultiplePrice(rs.getInt("REC_WEEK_SALE_MULTIPLE"),
							rs.getInt("REC_WEEK_SALE_MULTIPLE") > 1 ? 0 : rs.getDouble("REC_WEEK_SALE_PRICE"),
							rs.getInt("REC_WEEK_SALE_MULTIPLE") > 1 ? rs.getDouble("REC_WEEK_SALE_PRICE") : 0));
					saleInfoDTO.setSaleStartDate(rs.getString("REC_WEEK_SALE_START_DATE"));
					saleInfoDTO.setSaleEndDate(rs.getString("REC_WEEK_SALE_END_DATE"));
					saleInfoDTO.setPromoTypeId(rs.getInt("REC_WEEK_PROMO_TYPE_ID"));
					itemDTO.setRecWeekSaleInfo(saleInfoDTO);
				}
				// Ad info
				itemDTO.setIsOnAd(rs.getInt("IS_AD"));
				PRItemAdInfoDTO adInfoDTO = new PRItemAdInfoDTO();
				adInfoDTO.setAdPageNo(rs.getInt("REC_WEEK_AD_PAGE_NO"));
				adInfoDTO.setAdBlockNo(rs.getInt("REC_WEEK_AD_BLOCK_NO"));
				itemDTO.setRecWeekAdInfo(adInfoDTO);
				itemDTO.setUserOverrideFlag(rs.getInt("IS_USER_OVERRIDE"));
				int compStrId = rs.getInt("COMP_STR_ID");
				if (rs.getObject("CUR_COMP_REG_PRICE") != null) {
					MultiplePrice multiplePrice = new MultiplePrice(rs.getInt("CUR_COMP_REG_MULTIPLE"),
							rs.getDouble("CUR_COMP_REG_PRICE"));
					itemDTO.setCompPrice(multiplePrice);
				} else {
					itemDTO.setCompPrice(null);
				}
				if (compStrId > 0 && rs.getObject("CUR_COMP_REG_PRICE") != null) {
					LocationKey locationKey = new LocationKey(Constants.STORE_LEVEL_ID, compStrId);
					MultiplePrice multiplePrice = new MultiplePrice(rs.getInt("CUR_COMP_REG_MULTIPLE"),
							rs.getDouble("CUR_COMP_REG_PRICE"));
					itemDTO.setCompStrId(locationKey);
					HashMap<LocationKey, MultiplePrice> compPrice = new HashMap<LocationKey, MultiplePrice>();
					compPrice.put(locationKey, multiplePrice);
					itemDTO.setAllCompPrice(compPrice);
				}
				if (rs.getObject("PRED_MOV_WO_SUBS_EFFECT") != null) {
					itemDTO.setCurRegPredMovWOSubsEffect(rs.getDouble("PRED_MOV_WO_SUBS_EFFECT"));
				}

				// itemDTO.setOverrideRemoved(rs.getInt("IS_OVERRIDE_REMOVED"));
				itemDTO.setPriceZoneId(rs.getInt("ACTUAL_ZONE_ID"));
				itemDTO.setPriceZoneNo(rs.getString("ZONE_NUM"));
				itemsOfRun.add(itemDTO);
				runAndItsItem.put(runId, itemsOfRun);
			}

		} catch (Exception ex) {
			logger.error("Error in getRecItemsOfRunIds() -- " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return runAndItsItem;
	}

	public List<PRItemDTO> getPriceGroupItems(Connection conn, Object... values) throws GeneralException {
		logger.debug("Inside getPriceGroupItems()");
		List<PRItemDTO> priceGroupItems = new ArrayList<PRItemDTO>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			String retLirIdAndItemCodes = "";
//			for (Integer retLirIdOrItemCode : distinctRetLirIdAndItemCode) {
//				retLirIdAndItemCodes = retLirIdAndItemCodes + "," + retLirIdOrItemCode;
//			}

			for (Object itemCode : values) {
				retLirIdAndItemCodes = retLirIdAndItemCodes + "," + (Integer) itemCode;
			}

//			retLirIdAndItemCodes = retLirIdAndItemCodes.substring(1);
			String query = new String(GET_PRICE_GROUP_ITEMS);
//			query = query.replaceAll("%ITEM_CODES%", retLirIdAndItemCodes);
//			stmt = conn.prepareStatement(query);
//			logger.debug("GET_PRICE_GROUP_ITEMS:" + GET_PRICE_GROUP_ITEMS + ",itemCodes:" + retLirIdAndItemCodes);
			stmt = conn.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));

			int counter = 0;
			PristineDBUtil.setValues(stmt, ++counter, values);

			rs = stmt.executeQuery();
			while (rs.next()) {
				PRItemDTO itemDTO = new PRItemDTO();
				String lirInd = rs.getString("LIR_IND");
				itemDTO.setItemCode(rs.getInt("LIR_ID_OR_ITEM_CODE"));
				if (String.valueOf(Constants.YES).equalsIgnoreCase(lirInd)) {
					itemDTO.setLir(true);
				}
				priceGroupItems.add(itemDTO);
			}

		} catch (Exception ex) {
			logger.error("Error in getPriceGroupItems() -- " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return priceGroupItems;
	}

	public void updateRecTableAfterPriceAdjust(Connection conn, List<PRItemDTO> items) throws GeneralException {
		PreparedStatement stmt = null;
		ObjectMapper mapper = new ObjectMapper();
		String explainLogAsJson = "";
		try {
			stmt = conn.prepareStatement(UPDATE_PRICE_ADJUST);
			int itemNoInBatch = 0;
			for (PRItemDTO item : items) {
				int counter = 0;

				// RECOMMENDED_REG_PRICE
//				stmt.setDouble(++counter, item.getRecommendedRegPrice());
				stmt.setDouble(++counter, item.getRecommendedRegPrice().price);
				// IS_REC_PRICE_ADJUSTED
				if (item.getIsPriceAdjusted())
					stmt.setInt(++counter, 1);
				else
					stmt.setInt(++counter, 0);
				// REC_PRICE_BEFORE_ADJUST
				if (item.getRecPriceBeforeAdjustment() != null)
//					stmt.setDouble(++counter, item.getRecPriceBeforeAdjustment());
					stmt.setDouble(++counter, item.getRecPriceBeforeAdjustment().price);
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				// IS_CONFLICT
				stmt.setInt(++counter, item.getIsConflict());
				// LOG
				try {
					explainLogAsJson = mapper.writeValueAsString(item.getExplainLog());
				} catch (JsonProcessingException e) {
					explainLogAsJson = "";
					logger.error(
							"Error when converting explain log to json string - " + item.getItemCode() + e.toString());
					throw new GeneralException(e.toString());
				}
				stmt.setString(++counter, explainLogAsJson);
				if (item.getPredictionStatus() != null)
					stmt.setInt(++counter, item.getPredictionStatus());
				else
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				if (item.getPredictedMovement() != null)
					stmt.setDouble(++counter, item.getPredictedMovement());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);
				// OVERRIDE_PRED_UPDATE_STATUS
				// stmt.setInt(++counter, item.getPredictionUpdateStatus());

				stmt.setString(++counter, item.getIsOppurtunity());
				if (item.getOppurtunityQty() != null)
					stmt.setInt(++counter, item.getOppurtunityQty());
				else
					stmt.setNull(++counter, java.sql.Types.INTEGER);
				if (item.getOppurtunityPrice() != null)
					stmt.setDouble(++counter, item.getOppurtunityPrice());
				else
					stmt.setNull(++counter, java.sql.Types.DOUBLE);

				stmt.setInt(++counter, item.getIsNewPriceRecommended());

				stmt.setDouble(++counter, item.getRecRetailSalesDollar());
				stmt.setDouble(++counter, item.getRecRetailMarginDollar());

				// PR_RECOMMENDATION_RUN_ID
				stmt.setLong(++counter, item.getRecommendationId());

				stmt.addBatch();
				itemNoInBatch++;

				if (itemNoInBatch % Constants.BATCH_UPDATE_COUNT == 0) {
					int[] count = stmt.executeBatch();
					stmt.clearBatch();
					itemNoInBatch = 0;
				}
			}
			if (itemNoInBatch > 0) {
				int[] count = stmt.executeBatch();
				stmt.clearBatch();
			}
		} catch (SQLException ex) {
			logger.error("Error in updateRecTableAfterPriceAdjust() -- " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public HashMap<Long, List<PRItemDTO>> getPriceAdjustedItems(Connection conn, List<Long> runIds)
			throws GeneralException {
		logger.debug("Inside getPriceAdjustedItems()");
		HashMap<Long, List<PRItemDTO>> runAndItsItem = new HashMap<Long, List<PRItemDTO>>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ObjectMapper mapper = new ObjectMapper();
		try {
			String runs = "";
			for (Long runId : runIds) {
				runs = runs + "," + runId;
			}
			runs = runs.substring(1);
			String query = new String(GET_PRICE_ADJUSTED_ITEMS);
			query = query.replaceAll("%RUN_IDS%", runs);
			stmt = conn.prepareStatement(query);
			rs = stmt.executeQuery();
			while (rs.next()) {
				List<PRItemDTO> itemsOfRun;
				PRItemDTO itemDTO = new PRItemDTO();

				Long runId = rs.getLong("RUN_ID");
				String lirInd = rs.getString("LIR_IND");

				if (runAndItsItem.get(runId) == null)
					itemsOfRun = new ArrayList<PRItemDTO>();
				else
					itemsOfRun = runAndItsItem.get(runId);

				itemDTO.setRunId(runId);
				itemDTO.setRecommendationId(rs.getLong("PR_RECOMMENDATION_ID"));
				itemDTO.setItemCode(rs.getInt("ITEM_CODE"));
				itemDTO.setStrategyId(rs.getLong("STRATEGY_ID"));
				if (rs.getObject("RET_LIR_ID") != null)
					itemDTO.setRetLirId(rs.getInt("RET_LIR_ID"));
				if (String.valueOf(Constants.YES).equalsIgnoreCase(lirInd)) {
					itemDTO.setLir(true);
				}
//				itemDTO.setRecommendedRegMultiple(rs.getInt("RECOMMENDED_REG_MULTIPLE"));
//				if (rs.getObject("RECOMMENDED_REG_PRICE") != null)
//					itemDTO.setRecommendedRegPrice(rs.getDouble("RECOMMENDED_REG_PRICE"));

				if (rs.getObject("RECOMMENDED_REG_PRICE") != null)
					itemDTO.setRecommendedRegPrice(new MultiplePrice(rs.getInt("RECOMMENDED_REG_MULTIPLE"),
							rs.getDouble("RECOMMENDED_REG_PRICE")));

				if (rs.getObject("OVERRIDE_REG_PRICE") != null)
					itemDTO.setOverrideRegPrice(rs.getDouble("OVERRIDE_REG_PRICE"));
//				if (rs.getObject("REC_PRICE_BEFORE_ADJUST") != null)
//					itemDTO.setRecPriceBeforeAdjustment(rs.getDouble("REC_PRICE_BEFORE_ADJUST"));
				if (rs.getObject("REC_PRICE_BEFORE_ADJUST") != null)
					itemDTO.setRecPriceBeforeAdjustment(new MultiplePrice(PRConstants.DEFAULT_REG_MULTIPLE,
							rs.getDouble("REC_PRICE_BEFORE_ADJUST")));
				itemDTO.setIsConflict(rs.getInt("IS_CONFLICT"));
				itemDTO.setExplainLog(mapper.readValue(rs.getString("LOG"), PRExplainLog.class));
				// itemDTO.setChildLocationLevelId(rs.getInt("CHILD_LOCATION_LEVEL_ID"));
				// itemDTO.setChildLocationId(rs.getInt("CHILD_LOCATION_ID"));
				// itemDTO.setStartCalendarId(rs.getInt("CALENDAR_ID"));
				// itemDTO.setEndCalendarId(rs.getInt("CALENDAR_ID"));
				itemDTO.setPredictionStatus(rs.getInt("PREDICTION_STATUS"));
				if (rs.getObject("PREDICTED_MOVEMENT") != null) {
					itemDTO.setPredictedMovement(rs.getDouble("PREDICTED_MOVEMENT"));
				}

				if (rs.getObject("REC_REG_PRED_REASONS") != null) {
					itemDTO.setRegPricePredReasons(rs.getString("REC_REG_PRED_REASONS"));
				}

				if (rs.getObject("REC_SALE_PRED_REASONS") != null) {
					itemDTO.setSalePricePredReasons(rs.getString("REC_SALE_PRED_REASONS"));
				}

				itemsOfRun.add(itemDTO);
				runAndItsItem.put(runId, itemsOfRun);
			}

		} catch (Exception ex) {
			logger.error("Error in getPriceAdjustedItems() -- " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return runAndItsItem;
	}

	/**
	 * Populates price group info for items in itemDataMapStore
	 * 
	 * @param itemDataMapStore
	 * @param priceGroupRelation
	 */
	public void populatePriceGroupDetailsForStore(HashMap<Integer, HashMap<ItemKey, PRItemDTO>> itemDataMapStore,
			HashMap<String, HashMap<ItemKey, PRPriceGroupDTO>> priceGroupRelation) {
		if (itemDataMapStore != null && itemDataMapStore.size() > 0) {
			for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : itemDataMapStore.entrySet()) {
				populatePriceGroupDetails(entry.getValue(), priceGroupRelation);
			}
		}
	}

	// 6th June 2016 - bug fix, as hashmap doesn't maintain the element order,
	// zone with higher no of store is not taken always. changed to linkedhashmap
	public LinkedHashMap<Integer, Integer> getZoneStoreCount(Connection conn, List<Integer> zoneIds) throws Exception {
		LinkedHashMap<Integer, Integer> zoneAndStoreCount = new LinkedHashMap<Integer, Integer>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		String zones = "";
		executionTimeLog = new ExecutionTimeLog(PRConstants.GET_STORE_COUNT_OF_ZONE);

		try {
			zones = PRCommonUtil.getCommaSeperatedStringFromIntArray(zoneIds);
			String query = new String(GET_STORE_COUNT_OF_ZONE);
			query = query.replaceAll("%ZONE_IDS%", zones);
			stmt = conn.prepareStatement(query);
			rs = stmt.executeQuery();
			while (rs.next()) {
				zoneAndStoreCount.put(rs.getInt("PRICE_ZONE_ID"), rs.getInt("NO_OF_STORES"));
			}

		} catch (Exception ex) {
			logger.error("Error in getZoneStoreCount() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		executionTimeLog.setEndTime();
		executionTimeLogs.add(executionTimeLog);
		return zoneAndStoreCount;
	}

	// 6th June 2016 - bug fix, as hashmap doesn't maintain the element order,
	// zone with higher no of store is not taken always. changed to linkedhashmap
	public LinkedHashMap<Integer, Integer> getZoneStoreCountGlobalZone(Connection conn, List<Integer> zoneIds)
			throws Exception {
		LinkedHashMap<Integer, Integer> zoneAndStoreCount = new LinkedHashMap<Integer, Integer>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		String zones = "";
		executionTimeLog = new ExecutionTimeLog(PRConstants.GET_STORE_COUNT_OF_ZONE);

		try {
			zones = PRCommonUtil.getCommaSeperatedStringFromIntArray(zoneIds);
			String query = new String(GET_STORE_COUNT_OF_ZONE_GLOBAL);
			query = query.replaceAll("%ZONE_IDS%", zones);
			stmt = conn.prepareStatement(query);
			rs = stmt.executeQuery();
			while (rs.next()) {
				zoneAndStoreCount.put(rs.getInt("PRICE_ZONE_ID"), rs.getInt("NO_OF_STORES"));
			}

		} catch (Exception ex) {
			logger.error("Error in getZoneStoreCount() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		executionTimeLog.setEndTime();
		executionTimeLogs.add(executionTimeLog);
		return zoneAndStoreCount;
	}

	public List<String> getPriceAndStrategyZoneNos(Connection conn, int productLevelId, int productId,
			int locationLevelId, int locationId) throws Exception {
		List<String> distinctStrategyZoneIds = new ArrayList<String>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			int counter = 0;
			String query = new String(GET_PRICE_AND_STRATEGY_ZONES_NO);
			stmt = conn.prepareStatement(query);
			stmt.setLong(++counter, productLevelId);
			stmt.setLong(++counter, productId);
			stmt.setLong(++counter, locationLevelId);
			stmt.setLong(++counter, locationId);
			// stmt.setLong(++counter, locationId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				distinctStrategyZoneIds.add(rs.getString("ZONE_NUM"));
			}

		} catch (Exception ex) {
			logger.error("Error in getStrategyZoneNos() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return distinctStrategyZoneIds;
	}

	public List<String> getPriceZoneNos(Connection conn, int productLevelId, int productId, int locationLevelId,
			int locationId) throws Exception {
		List<String> distinctStrategyZoneIds = new ArrayList<String>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			int counter = 0;
			String query = new String(GET_PRICE_ZONES_NO);
			stmt = conn.prepareStatement(query);
			stmt.setLong(++counter, productLevelId);
			stmt.setLong(++counter, productId);
			stmt.setLong(++counter, locationLevelId);
			stmt.setLong(++counter, locationId);
			// stmt.setLong(++counter, locationId);
			rs = stmt.executeQuery();
			while (rs.next()) {
				distinctStrategyZoneIds.add(rs.getString("ZONE_NUM"));
			}

		} catch (Exception ex) {
			logger.error("Error in getStrategyZoneNos() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return distinctStrategyZoneIds;
	}

	public List<Integer> getPriceZoneStores(Connection conn, int productLevelId, int productId, int locationLevelId,
			int locationId) throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		List<Integer> stores = new ArrayList<Integer>();
		executionTimeLog = new ExecutionTimeLog(PRConstants.GET_STORES_OF_PRICE_ZONE);
		try {
			int counter = 0;
			String sql = null;
			sql = GET_STORES_OF_PRICE_ZONE;

//			logger.debug("Query " + sql);

			stmt = conn.prepareStatement(sql);
			stmt.setLong(++counter, productLevelId);
			stmt.setLong(++counter, productId);
			stmt.setLong(++counter, locationLevelId);
			stmt.setLong(++counter, locationId);
			stmt.setFetchSize(200000);
			rs = stmt.executeQuery();

			while (rs.next()) {
				int storeId = rs.getInt("STORE_ID");
				stores.add(storeId);
			}
		} catch (Exception exception) {
			throw new GeneralException("Error in getPriceZoneStores() - " + exception);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		executionTimeLog.setEndTime();
		executionTimeLogs.add(executionTimeLog);
		return stores;
	}

	public boolean isPriceZone(Connection conn, int productLevelId, int productId, int locationLevelId, int locationId)
			throws GeneralException {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		boolean isPriceZone = true;
		executionTimeLog = new ExecutionTimeLog(PRConstants.GET_IS_PRICE_ZONE);
		try {
			int counter = 0;
			String sql = null;
			sql = GET_IS_PRICE_ZONE;

//			logger.debug("Query " + sql);

			stmt = conn.prepareStatement(sql);
			stmt.setLong(++counter, productLevelId);
			stmt.setLong(++counter, productId);
			stmt.setLong(++counter, locationLevelId);
			stmt.setLong(++counter, locationId);
			rs = stmt.executeQuery();

			if (rs.next()) {
				isPriceZone = true;
			} else {
				isPriceZone = false;
			}
		} catch (Exception exception) {
			throw new GeneralException("Error in isPriceZone() - " + exception);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		executionTimeLog.setEndTime();
		executionTimeLogs.add(executionTimeLog);
		return isPriceZone;
	}

	public long getLatestRecommendationRunId(Connection conn, int locationLevelId, int locationId, int productLevelId,
			int productId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		long recRunId = 0;
		try {
			stmt = conn.prepareStatement(GET_LATEST_RUN_ID);
			stmt.setInt(1, locationLevelId);
			stmt.setInt(2, locationId);
			stmt.setInt(3, productLevelId);
			stmt.setInt(4, productId);
			rs = stmt.executeQuery();
			if (rs.next()) {
				recRunId = rs.getLong("RUN_ID");
			}
		} catch (SQLException exception) {
			logger.error("Error in getLatestRecommendationRunId() - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return recRunId;
	}

	/**
	 * Retrieves all the non-lig and lig member which has latest check date
	 * 
	 * @param compPriceData
	 * @return latestCheckDatePrice
	 * @throws OfferManagementException
	 */
	public HashMap<Integer, CompetitiveDataDTO> getLatestPriceData(Collection<CompetitiveDataDTO> compPriceData)
			throws Exception {
		HashMap<Integer, CompetitiveDataDTO> latestCheckDatePrice = new HashMap<Integer, CompetitiveDataDTO>();
		HashMap<Integer, List<CompetitiveDataDTO>> groupByLirId = new HashMap<Integer, List<CompetitiveDataDTO>>();
		SimpleDateFormat sdf = new SimpleDateFormat(Constants.APP_DATE_FORMAT);
		PricingEngineService pricingEngineService = new PricingEngineService();
		// groping all the lig using lirid
		try {
			for (CompetitiveDataDTO competitiveDataDTO : compPriceData) {
				// lir id greater than zero then grouping them according to the
				// value
				if (competitiveDataDTO.lirId > 0) {
					List<CompetitiveDataDTO> tList = new ArrayList<CompetitiveDataDTO>();
					if (groupByLirId.get(competitiveDataDTO.lirId) != null) {
						tList = groupByLirId.get(competitiveDataDTO.lirId);
					}
					tList.add(competitiveDataDTO);
					groupByLirId.put(competitiveDataDTO.lirId, tList);
				} else {
					latestCheckDatePrice.put(competitiveDataDTO.itemcode, competitiveDataDTO);
				}
			}

			// Sorting checkdate using lirid in the loop
			for (Map.Entry<Integer, List<CompetitiveDataDTO>> entry : groupByLirId.entrySet()) {
				List<CompetitiveDataDTO> lirValues = entry.getValue();
				CompetitiveDataDTO competitiveDataDTO = null;
				@SuppressWarnings("unused")
				Date latestLirIdCheckDate = null;
				pricingEngineService.sortByCheckDate(lirValues);
				// if the lirId value is greater than zero then handling the
				// loop to iterate latest value
				for (int i = 0; i < lirValues.size(); i++) {
					if (lirValues.get(i).checkDate != null) {
						competitiveDataDTO = lirValues.get(i);
						if (i == 0) {
							// First Value which contains Max Date and PrePrice
							latestLirIdCheckDate = sdf.parse(lirValues.get(i).checkDate);
							latestCheckDatePrice.put(competitiveDataDTO.itemcode, competitiveDataDTO);
						}
						// Remaining Values are changed accordingly
						else {
							Date currentLirIdCheckDate = sdf.parse(competitiveDataDTO.checkDate);
							Date weekStrtDt=sdf.parse(DateUtil.getWeekStartDate(sdf.parse(lirValues.get(i).checkDate), 0));
							Date weekEndDt=sdf.parse(DateUtil.getWeekEndDate(sdf.parse(lirValues.get(i).checkDate), Constants.APP_DATE_FORMAT));
							
							//int compare = latestLirIdCheckDate.compareTo(currentLirIdCheckDate);
							
							if (currentLirIdCheckDate.compareTo(weekStrtDt) >= 0) {
								if (currentLirIdCheckDate.compareTo(weekEndDt) <= 0) {
									latestCheckDatePrice.put(competitiveDataDTO.itemcode, competitiveDataDTO);
								}
							}
						}
					}
				}
			}

		} catch (Exception ex) {
			logger.error("Error while executing PricingEngineDAO.getLatestPriceData() ");
			throw new Exception(ex.toString());
		}

		return latestCheckDatePrice;
	}

	public HashMap<ProductKey, List<MultiplePrice>> getExistingRegPricePointsForZone(Connection conn,
			List<Integer> priceZoneStores, String startDate, int noOfWeeksBehind, List<PRItemDTO> itemList)
			throws GeneralException {
		List<Integer> itemCodeList = new ArrayList<Integer>();
		HashMap<ProductKey, List<MultiplePrice>> distinctRegPrices = new HashMap<ProductKey, List<MultiplePrice>>();
		int limitcount = 0;

		Set<Integer> itemCodes = new HashSet<Integer>();
		for (PRItemDTO prItemDTO : itemList) {
			if (!prItemDTO.isLir())
				itemCodes.add(prItemDTO.getItemCode());
		}

		for (Integer itemCode : itemCodes) {
			itemCodeList.add(itemCode);
			limitcount++;
			if (limitcount > 0 && (limitcount % commitCount == 0)) {
				Object[] values = itemCodeList.toArray();
				retrieveExistingRegPricePointsForZone(conn, priceZoneStores, startDate, noOfWeeksBehind * 7,
						distinctRegPrices, values);
				itemCodeList.clear();
			}
		}
		if (itemCodeList.size() > 0) {
			Object[] values = itemCodeList.toArray();
			retrieveExistingRegPricePointsForZone(conn, priceZoneStores, startDate, noOfWeeksBehind * 7,
					distinctRegPrices, values);
			itemCodeList.clear();
		}

		return distinctRegPrices;
	}

	private void retrieveExistingRegPricePointsForZone(Connection connection, List<Integer> priceZoneStores,
			String weekStartDate, int maxDataLookupRange, HashMap<ProductKey, List<MultiplePrice>> distinctRegPrices,
			Object... values) throws GeneralException {
		long startTime = System.currentTimeMillis();
		PreparedStatement statement = null;
		ResultSet resultSet = null;

		try {
			String query = new String(GET_EXISTING_REG_PRICE_FOR_ZONE);
			String storeIds = PRCommonUtil.getCommaSeperatedStringFromIntArray(priceZoneStores);
			query = query.replaceAll("%PRICE_ZONE_STORES%", storeIds);
//			logger.debug("Distinct Reg Price Query " + query);
			String items = "";
			for (Object itemCode : values) {
				items = items + "," + (Integer) itemCode;
			}
//			logger.debug("Parameters: 1-" + weekStartDate + ",2-" + weekStartDate + ",3-" + maxDataLookupRange + ",4-"
//					+ Constants.STORE_LEVEL_ID + ",5-" + Constants.ITEMLEVELID + ",6-" + items);
			statement = connection
					.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));

			int counter = 0;
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekStartDate);
			statement.setInt(++counter, maxDataLookupRange);
			statement.setInt(++counter, Constants.STORE_LEVEL_ID);
			statement.setInt(++counter, Constants.ITEMLEVELID);
			PristineDBUtil.setValues(statement, ++counter, values);
			statement.setFetchSize(100000);
			resultSet = statement.executeQuery();
			long endTimeTemp = System.currentTimeMillis();
//			logger.debug("Time taken by statement.executeQuery() " + (endTimeTemp - startTime));
//			logger.debug("Distinct Reg Price Query executed");

			while (resultSet.next()) {
				ProductKey productKey = new ProductKey(Constants.ITEMLEVELID, resultSet.getInt("PRODUCT_ID"));
				List<MultiplePrice> tempList = new ArrayList<MultiplePrice>();
				if (distinctRegPrices.get(productKey) != null) {
					tempList = distinctRegPrices.get(productKey);
				}
				String regPrice = resultSet.getString("REG_PRICE");
				MultiplePrice multiplePrice = new MultiplePrice(Integer.valueOf(regPrice.split("/")[0]),
						Double.valueOf(regPrice.split("/")[1]));
				tempList.add(multiplePrice);

				distinctRegPrices.put(productKey, tempList);
			}
		} catch (SQLException e) {
			logger.error("Error while executing retrieveDistinctRegPriceForZone " + e);
			throw new GeneralException("Error while executing retrieveDistinctRegPriceForZone " + e);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}
		long endTime = System.currentTimeMillis();
		logger.debug("Time taken to retrieve distinct reg price " + (endTime - startTime));
	}

	public HashMap<ProductKey, Long> getLastXWeeksMovForZone(Connection conn, List<Integer> priceZoneStores,
			String startDate, int noOfWeeksBehind, HashMap<ItemKey, PRItemDTO> inputMap,
			HashMap<Integer, List<PRItemDTO>> retLirMap, int zoneId) throws GeneralException {

		// Below code is refactored to avoid connection in setting up objects
		// Gets data from DB
		HashMap<ProductKey, Long> lastXWeeksMov = getLastXWeeksMov(conn, priceZoneStores, startDate, noOfWeeksBehind,
				inputMap, zoneId);

		// Sets last X weeks movement in input map
		setLastXWeeksMov(inputMap, retLirMap, lastXWeeksMov);

		return lastXWeeksMov;
	}

	/**
	 * 
	 * @param inputMap
	 * @param retLirMap
	 * @param lastXWeeksMov
	 */
	public void setLastXWeeksMov(HashMap<ItemKey, PRItemDTO> inputMap, HashMap<Integer, List<PRItemDTO>> retLirMap,
			HashMap<ProductKey, Long> lastXWeeksMov) {
		// Update to item
		for (Map.Entry<ProductKey, Long> entry : lastXWeeksMov.entrySet()) {
			ItemKey itemKey = new ItemKey(entry.getKey().getProductId(), PRConstants.NON_LIG_ITEM_INDICATOR);
			PRItemDTO itemDTO = inputMap.get(itemKey);
			itemDTO.setLastXWeeksMov(entry.getValue());
			/*
			 * if (inputMap.get(itemKey).getRetLirId() == 0) {
			 * itemDTO.setFamilyXWeeksMov(itemDTO.getAvgMovement()); }
			 */
		}

		// Update lig as well
		for (Map.Entry<Integer, List<PRItemDTO>> inEntry : retLirMap.entrySet()) {
			long ligMov = 0;
			double ligAvgMov = 0;
			// Loop each lig member
			for (PRItemDTO itemDTO : inEntry.getValue()) {
				ItemKey ligMemberKey = PRCommonUtil.getItemKey(itemDTO.getItemCode(), false);
				ligMov = ligMov + inputMap.get(ligMemberKey).getLastXWeeksMov();
				ligAvgMov = ligAvgMov + inputMap.get(ligMemberKey).getAvgMovement();
			}

			ItemKey retLirItemKey = PRCommonUtil.getItemKey(inEntry.getKey(), true);
			inputMap.get(retLirItemKey).setLastXWeeksMov(ligMov);

			/*
			 * for (PRItemDTO itemDTO : inEntry.getValue()) {
			 * itemDTO.setFamilyXWeeksMov(ligAvgMov); }
			 */
		}
	}

	/**
	 * 
	 * @param conn
	 * @param priceZoneStores
	 * @param startDate
	 * @param noOfWeeksBehind
	 * @param inputMap
	 * @param retLirMap
	 * @param zoneId
	 * @return last X weeks mov
	 * @throws GeneralException
	 */
	public HashMap<ProductKey, Long> getLastXWeeksMov(Connection conn, List<Integer> priceZoneStores, String startDate,
			int noOfWeeksBehind, HashMap<ItemKey, PRItemDTO> inputMap, int zoneId) throws GeneralException {
		List<Integer> itemCodeList = new ArrayList<Integer>();
		HashMap<ProductKey, Long> lastXWeeksMov = new HashMap<ProductKey, Long>();
		int limitcount = 0;

		Set<Integer> itemList = new HashSet<Integer>();
		for (PRItemDTO prItemDTO : inputMap.values()) {
			if (!prItemDTO.isLir())
				itemList.add(prItemDTO.getItemCode());
		}

		for (Integer itemCode : itemList) {
			itemCodeList.add(itemCode);
			limitcount++;
			if (limitcount > 0 && (limitcount % commitCount == 0)) {
				Object[] values = itemCodeList.toArray();
				retrieveLastXWeeksMovForZone(conn, priceZoneStores, startDate, noOfWeeksBehind * 7, lastXWeeksMov,
						zoneId, values);
				itemCodeList.clear();
			}
		}
		if (itemCodeList.size() > 0) {
			Object[] values = itemCodeList.toArray();
			retrieveLastXWeeksMovForZone(conn, priceZoneStores, startDate, noOfWeeksBehind * 7, lastXWeeksMov, zoneId,
					values);
			itemCodeList.clear();
		}

		return lastXWeeksMov;

	}

	private void retrieveLastXWeeksMovForZone(Connection connection, List<Integer> priceZoneStores,
			String weekStartDate, int maxDataLookupRange, HashMap<ProductKey, Long> lastXWeeksMov, int zoneId,
			Object... values) throws GeneralException {
		long startTime = System.currentTimeMillis();
		PreparedStatement statement = null;
		ResultSet resultSet = null;

		try {
			String imsSource = PropertyManager.getProperty("IMS_SOURCE", "STORE");
			String storeIds = PRCommonUtil.getCommaSeperatedStringFromIntArray(priceZoneStores);

			int locationLevelId = Constants.STORE_LEVEL_ID;
			String locationIds = storeIds;
			String tableName = "SYN_ITEM_METRIC_SUMMARY_WEEKLY";

			if (imsSource.equals("ZONE")) {
				locationLevelId = Constants.ZONE_LEVEL_ID;
				locationIds = String.valueOf(zoneId);
				tableName = "IMS_WEEKLY_ZONE";
			}

			String query = new String(GET_LAST_X_MONTHS_MOV_FOR_ZONE);

			query = query.replaceAll("%TABLE_NAME%", tableName);
			query = query.replaceAll("%LOCATION_IDS%", locationIds);
//			logger.debug("Query - GET_LAST_X_MONTHS_MOV_FOR_ZONE " + query);
			String items = "";
			for (Object itemCode : values) {
				items = items + "," + (Integer) itemCode;
			}
//			logger.debug("Parameters: 1-" + weekStartDate + ",2-" + weekStartDate + ",3-" + maxDataLookupRange + ",4-"
//					+ locationLevelId + ",5-" + Constants.ITEMLEVELID + ",6-" + items);
			statement = connection
					.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));

			int counter = 0;
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekStartDate);
			statement.setInt(++counter, maxDataLookupRange);
//			statement.setInt(++counter, Constants.STORE_LEVEL_ID);
			statement.setInt(++counter, locationLevelId);
			statement.setInt(++counter, Constants.ITEMLEVELID);
			PristineDBUtil.setValues(statement, ++counter, values);
			statement.setFetchSize(100000);
			resultSet = statement.executeQuery();
			long endTimeTemp = System.currentTimeMillis();
//			logger.debug("Time taken by statement.executeQuery() " + (endTimeTemp - startTime));
//			logger.debug("Query executed");

			while (resultSet.next()) {
				ProductKey productKey = new ProductKey(Constants.ITEMLEVELID, resultSet.getInt("PRODUCT_ID"));
				Long mov = resultSet.getLong("TOT_MOVEMENT");
				lastXWeeksMov.put(productKey, mov);
			}
		} catch (SQLException e) {
			logger.error("Error while executing retrieveLastXMonthMovForZone " + e);
			throw new GeneralException("Error while executing retrieveLastXMonthMovForZone " + e);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}
		long endTime = System.currentTimeMillis();
		logger.debug("Time taken to retrieve retrieveLastXMonthMovForZone " + (endTime - startTime));
	}

	public HashMap<Long, List<PRItemDTO>> getRecommendationItems(Connection conn, List<Long> runIds)
			throws GeneralException {
		logger.debug("Inside getRecommendationItems()");
		HashMap<Long, List<PRItemDTO>> runAndItsItem = new HashMap<Long, List<PRItemDTO>>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		ObjectMapper mapper = new ObjectMapper();
		PRStrategyDTO strategyDTO;
		try {
			String runs = "";
			for (Long runId : runIds) {
				runs = runs + "," + runId;
			}
			runs = runs.substring(1);
			String query = new String(GET_RECOMMENDATIONS_ITEMS_OF_RUNS);
			query = query.replaceAll("%RUN_IDS%", runs);
			stmt = conn.prepareStatement(query);
			rs = stmt.executeQuery();
			while (rs.next()) {
				List<PRItemDTO> itemsOfRun = new ArrayList<PRItemDTO>();
				PRItemDTO itemDTO = new PRItemDTO();

				Long runId = rs.getLong("RUN_ID");
				String lirInd = rs.getString("LIR_IND");
				String isSubstitute = rs.getString("IS_SUBSTITUTE");

				itemDTO.setRunId(runId);
				itemDTO.setRecommendationId(rs.getLong("PR_RECOMMENDATION_ID"));
				itemDTO.setItemCode(rs.getInt("ITEM_CODE"));
				itemDTO.setStrategyId(rs.getLong("STRATEGY_ID"));
				itemDTO.setCostChgIndicator(rs.getInt("COST_CHG_IND"));
				if (rs.getObject("CUR_LIST_COST") != null)
					itemDTO.setListCost(rs.getDouble("CUR_LIST_COST"));
				if (rs.getObject("CUR_VIP_COST") != null)
					itemDTO.setVipCost(rs.getDouble("CUR_VIP_COST"));
				if (rs.getObject("RET_LIR_ID") != null)
					itemDTO.setRetLirId(rs.getInt("RET_LIR_ID"));
				if (rs.getObject("PRICE_CHECK_LIST_ID") != null)
					itemDTO.setPriceCheckListId(rs.getInt("PRICE_CHECK_LIST_ID"));
//				itemDTO.setRecommendedRegMultiple(rs.getInt("RECOMMENDED_REG_MULTIPLE"));
//				if (rs.getObject("RECOMMENDED_REG_PRICE") != null)
//					itemDTO.setRecommendedRegPrice(rs.getDouble("RECOMMENDED_REG_PRICE"));

				if (rs.getObject("RECOMMENDED_REG_PRICE") != null)
					itemDTO.setRecommendedRegPrice(new MultiplePrice(rs.getInt("RECOMMENDED_REG_MULTIPLE"),
							rs.getDouble("RECOMMENDED_REG_PRICE")));

				if (rs.getObject("OVERRIDE_REG_PRICE") != null)
					itemDTO.setOverrideRegPrice(rs.getDouble("OVERRIDE_REG_PRICE"));
				int priceAdjustedFlag = rs.getInt("IS_REC_PRICE_ADJUSTED");
				if (priceAdjustedFlag == 1)
					itemDTO.setIsPriceAdjusted(true);
				else
					itemDTO.setIsPriceAdjusted(false);
//				if (rs.getObject("REC_PRICE_BEFORE_ADJUST") != null)
//					itemDTO.setRecPriceBeforeAdjustment(rs.getDouble("REC_PRICE_BEFORE_ADJUST"));
				if (rs.getObject("REC_PRICE_BEFORE_ADJUST") != null)
					itemDTO.setRecPriceBeforeAdjustment(new MultiplePrice(PRConstants.DEFAULT_REG_MULTIPLE,
							rs.getDouble("REC_PRICE_BEFORE_ADJUST")));
				if (rs.getObject("CUR_COMP_REG_PRICE") != null) {
					MultiplePrice multiplePrice = new MultiplePrice(rs.getInt("CUR_COMP_REG_MULTIPLE"),
							rs.getDouble("CUR_COMP_REG_PRICE"));
					itemDTO.setCompPrice(multiplePrice);
				} else {
					itemDTO.setCompPrice(null);
				}
				if (String.valueOf(Constants.YES).equalsIgnoreCase(lirInd)) {
					itemDTO.setLir(true);
				}
				itemDTO.setIsConflict(rs.getInt("IS_CONFLICT"));
				itemDTO.setExplainLog(mapper.readValue(rs.getString("LOG"), PRExplainLog.class));

				if (rs.getObject("PREDICTION_STATUS") != null)
					itemDTO.setPredictionStatus(rs.getInt("PREDICTION_STATUS"));

				if (rs.getObject("PREDICTED_MOVEMENT") != null)
					itemDTO.setPredictedMovement(rs.getDouble("PREDICTED_MOVEMENT"));

				if (rs.getObject("OPPORTUNITY_PRICE") != null)
					itemDTO.setOppurtunityPrice(rs.getDouble("OPPORTUNITY_PRICE"));

				if (rs.getObject("OPPORTUNITY_QUANTITY") != null)
					itemDTO.setOppurtunityQty(rs.getInt("OPPORTUNITY_QUANTITY"));

				if (rs.getObject("IS_OPPORTUNITY") != null)
					itemDTO.setIsOppurtunity(rs.getString("IS_OPPORTUNITY"));

				itemDTO.setAvgMovement(rs.getDouble("AVG_MOVEMENT"));

				itemDTO.setIsPrePriced(rs.getInt("IS_PRE_PRICED"));

				if (String.valueOf(Constants.YES).equalsIgnoreCase(isSubstitute)) {
					itemDTO.setIsPartOfSubstituteGroup(true);
				}
				itemDTO.setIsLocPriced(rs.getInt("IS_LOCKED_PRICE"));

				itemDTO.setRegMPack(rs.getInt("CUR_REG_MULTIPLE"));
				if (itemDTO.getRegMPack() > 1)
					itemDTO.setRegMPrice(rs.getDouble("CUR_REG_PRICE"));
				else
					itemDTO.setRegPrice(rs.getDouble("CUR_REG_PRICE"));

				if (rs.getObject("REC_REG_PRED_REASONS") != null) {
					itemDTO.setRegPricePredReasons(rs.getString("REC_REG_PRED_REASONS"));
				}

				if (rs.getObject("REC_SALE_PRED_REASONS") != null) {
					itemDTO.setSalePricePredReasons(rs.getString("REC_SALE_PRED_REASONS"));
				}

				strategyDTO = new PRStrategyDTO();
				strategyDTO.setLocationLevelId(rs.getInt("STRATEGY_LOCATION_LEVEL_ID"));
				strategyDTO.setLocationId(rs.getInt("STRATEGY_LOCATION_ID"));
				strategyDTO.setProductLevelId(rs.getInt("STRATEGY_PRODUCT_LEVEL_ID"));
				strategyDTO.setProductId(rs.getInt("STRATEGY_PRODUCT_ID"));
				strategyDTO.setApplyTo(rs.getInt("STRATEGY_APPLY_TO"));
				strategyDTO.setVendorId(rs.getInt("STRATEGY_VENDOR_ID"));
				strategyDTO.setStateId(rs.getInt("STRATEGY_STATE_ID"));
				itemDTO.setStrategyDTO(strategyDTO);

				if (runAndItsItem.get(runId) != null)
					itemsOfRun = runAndItsItem.get(runId);

				itemsOfRun.add(itemDTO);
				runAndItsItem.put(runId, itemsOfRun);
			}
		} catch (Exception ex) {
			logger.error("Error in getRecommendationItems() -- " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return runAndItsItem;
	}

	public HashMap<Integer, List<PRItemSaleInfoDTO>> getSaleDetails(Connection conn, int productLevelId, int productId,
			int chainId, int zoneId, String weekStartDate, int noOfWeekSaleData, List<Integer> stores,
			boolean isGlobalZone) throws GeneralException {
		return getSaleDetails(conn, productLevelId, productId, chainId, Constants.ZONE_LEVEL_ID, zoneId, weekStartDate,
				noOfWeekSaleData, stores, isGlobalZone);
	}

	public HashMap<Integer, List<PRItemSaleInfoDTO>> getSaleDetails(Connection conn, int productLevelId, int productId,
			int chainId, int locationLevelId, int locationId, String weekStartDate, int noOfWeekSaleData,
			List<Integer> stores, boolean isGlobalZone) throws GeneralException {
		HashMap<Integer, List<PRItemSaleInfoDTO>> saleDetails = new HashMap<Integer, List<PRItemSaleInfoDTO>>();
		HashMap<Integer, HashMap<String, PRItemSaleInfoDTO>> tempMap = new HashMap<Integer, HashMap<String, PRItemSaleInfoDTO>>();
		int itemCode = 0;
		PRItemSaleInfoDTO saleInfoDTO = new PRItemSaleInfoDTO();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int counter = 0;
		try {

			String query = new String(GET_SALE_PRICE);
			String subQuery = getItemsInCategoryQuery(productLevelId, productId);
			query = query.replaceAll("%ITEMS_IN_CATEGORY%", subQuery);
			// Taking promoId's from property file
			String promoIds = (PropertyManager.getProperty("REC_SUPPORTED_PROMO_TYPES"));
			query = query.replaceAll("%PROMO_ID%", promoIds);

			subQuery = getPromoLocationsQuery(chainId, locationLevelId, locationId, stores, isGlobalZone);
			query = query.replaceAll("%PROMO_LOCATIONS%", subQuery);
			String calType = PropertyManager.getProperty("RETAIL_CALENDAR_TYPE", Constants.RETAIL_CALENDAR_BUSINESS);
			if (calType.equals(Constants.RETAIL_CALENDAR_PROMO)) {
				query = query.replaceAll("%RETAIL_CALENDAR_TAB_NAME%", "RETAIL_CALENDAR_PROMO");
			} else {
				query = query.replaceAll("%RETAIL_CALENDAR_TAB_NAME%", "RETAIL_CALENDAR");
			}

			stmt = conn.prepareStatement(query);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

//			logger.debug("GET_SALE_PRICE:" + query);
//			logger.debug("Parameters: 1,2,4,5-" + weekStartDate + ",3,6-" + noOfWeekSaleData * 7);

			stmt.setFetchSize(100000);
			rs = stmt.executeQuery();

			while (rs.next()) {

				saleInfoDTO = new PRItemSaleInfoDTO();
				itemCode = rs.getInt("ITEM_CODE");
				String SaleStartDate = "";
				String SaleEndDate = "";
				MultiplePrice salePrice ;
				
				if (rs.getInt("MUSTBUY_QTY") > 0 && rs.getDouble("MUSTBUY_AMT") > 0) {
					saleInfoDTO.setSalePrice(PRCommonUtil.getMultiplePrice(rs.getInt("SALE_QTY"),
							rs.getDouble("SALE_PRICE"), rs.getDouble("SALE_M_PRICE")));

				} else {
					saleInfoDTO.setSalePrice(PRCommonUtil.getMultiplePrice(rs.getInt("SALE_QTY"),
							rs.getDouble("SALE_PRICE"), rs.getDouble("SALE_M_PRICE")));
				}
				//handling 1 ype of Bundle promo
				if (rs.getInt("PROMO_TYPE_ID") == 11 && rs.getDouble("SALE_PRICE") == 0
						&& rs.getString("OFFER_UNIT_TYPE").equalsIgnoreCase("O") && rs.getDouble("OFFER_VALUE") != 0) {

					saleInfoDTO.setSalePrice(PRCommonUtil.getMultiplePrice(rs.getInt("MIN_QTY_REQUIRED"),
							rs.getDouble("OFFER_VALUE"), rs.getDouble("SALE_M_PRICE")));
				}

				if (rs.getString("ACTUAL_PROMO_START_DATE") != null
						&& !rs.getString("ACTUAL_PROMO_START_DATE").isEmpty()) {
					saleInfoDTO.setSaleStartDate(rs.getString("ACTUAL_PROMO_START_DATE"));
					SaleStartDate=rs.getString("ACTUAL_PROMO_START_DATE");

				} else {
					saleInfoDTO.setSaleStartDate(rs.getString("PROMO_ACTUAL_START_DATE"));
					SaleStartDate=rs.getString("PROMO_ACTUAL_START_DATE");
				}
				if (rs.getString("ACTUAL_PROMO_END_DATE") != null && !rs.getString("ACTUAL_PROMO_END_DATE").isEmpty()) {
					saleInfoDTO.setSaleEndDate(rs.getString("ACTUAL_PROMO_END_DATE"));
					SaleEndDate=rs.getString("ACTUAL_PROMO_END_DATE");

				} else {
					saleInfoDTO.setSaleEndDate(rs.getString("PROMO_ACTUAL_END_DATE"));
					SaleEndDate=rs.getString("PROMO_ACTUAL_END_DATE");
				}
				if (rs.getString("PROMO_WEEK_START_DATE") != null && !rs.getString("PROMO_WEEK_START_DATE").isEmpty()) {
					saleInfoDTO.setSaleWeekStartDate(rs.getString("PROMO_WEEK_START_DATE"));
				}

				// MIN_QTY_REQUIRED, POD.OFFER_UNIT_TYPE,
				// POD.OFFER_VALUE,PROMO_PRIORITY,CONSTRAINT
				saleInfoDTO.setMinQtyReqd(rs.getInt("MIN_QTY_REQUIRED"));
				saleInfoDTO.setOfferUnitType(rs.getString("OFFER_UNIT_TYPE"));
				saleInfoDTO.setOfferValue(rs.getDouble("OFFER_VALUE"));
				saleInfoDTO.setConstraint(rs.getInt("CONSTRAINT"));
				saleInfoDTO.setPromoPriority(rs.getInt("PROMO_PRIORITY"));
				saleInfoDTO.setPromoTypeId(rs.getInt("PROMO_TYPE_ID"));

				if (rs.getInt("PROMO_TYPE_ID") == 11 && rs.getDouble("SALE_PRICE") == 0
						&& rs.getString("OFFER_UNIT_TYPE").equalsIgnoreCase("O") && rs.getDouble("OFFER_VALUE") != 0) {

					saleInfoDTO.setSalePrice(PRCommonUtil.getMultiplePrice(rs.getInt("MIN_QTY_REQUIRED"),
							rs.getDouble("OFFER_VALUE"), rs.getDouble("SALE_M_PRICE")));
				}
				
				if (rs.getInt("MUSTBUY_QTY") > 0 && rs.getDouble("MUSTBUY_AMT") > 0) {
					salePrice = PRCommonUtil.getMultiplePrice(rs.getInt("MUSTBUY_QTY"), rs.getDouble("MUSTBUY_AMT"),
							rs.getDouble("MUSTBUY_AMT"));
				} else {

					salePrice = PRCommonUtil.getMultiplePrice(rs.getInt("SALE_QTY"), rs.getDouble("SALE_PRICE"),
							rs.getDouble("SALE_M_PRICE"));
					
					// Handling 1 Type of Bundle promo
					if (rs.getInt("PROMO_TYPE_ID") == 11 && rs.getDouble("SALE_PRICE") == 0
							&& rs.getString("OFFER_UNIT_TYPE").equalsIgnoreCase("O")
							&& rs.getDouble("OFFER_VALUE") != 0) {

						salePrice = (PRCommonUtil.getMultiplePrice(rs.getInt("MIN_QTY_REQUIRED"),
								rs.getDouble("OFFER_VALUE"), rs.getDouble("SALE_M_PRICE")));
						
//						logger.info(" saleprice for :"+ itemCode + "is: "+ salePrice.price + "qty:"+ salePrice.multiple );
					}
					
				}

				int promoPriority = rs.getInt("PROMO_PRIORITY");
				String SaleWeekStartDate = (rs.getString("PROMO_WEEK_START_DATE"));
				int MinQtyReqd = (rs.getInt("MIN_QTY_REQUIRED"));
				String OfferUnitType = (rs.getString("OFFER_UNIT_TYPE"));
				Double OfferValue = (rs.getDouble("OFFER_VALUE"));
				int Constraint = (rs.getInt("CONSTRAINT"));
				//PromoTypeLookup SalePromoTypeLookup = (PromoTypeLookup.get(rs.getInt("PROMO_TYPE_ID")));
				int promoTypeId = rs.getInt("PROMO_TYPE_ID");
				String key = rs.getString("PROMO_ACTUAL_START_DATE") + ";" + rs.getString("PROMO_ACTUAL_END_DATE");

				HashMap<String, PRItemSaleInfoDTO> temp = new HashMap<String, PRItemSaleInfoDTO>();

				// If a promotion has multiple entries for same startDate End date consider the
				// promotion having maximum priority
				if (tempMap.get(itemCode) != null) {
					temp = tempMap.get(itemCode);
					if (temp.containsKey(key)) {
						PRItemSaleInfoDTO PRItemSaleInfoDTO = temp.get(key);
						if (promoPriority > PRItemSaleInfoDTO.getPromoPriority()) {
							PRItemSaleInfoDTO.setPromoPriority(promoPriority);
							PRItemSaleInfoDTO.setMinQtyReqd(MinQtyReqd);
							PRItemSaleInfoDTO.setSaleStartDate(SaleStartDate);
							PRItemSaleInfoDTO.setSaleEndDate(SaleEndDate);
							PRItemSaleInfoDTO.setSaleWeekStartDate(SaleWeekStartDate);
							PRItemSaleInfoDTO.setOfferUnitType(OfferUnitType);
							PRItemSaleInfoDTO.setOfferValue(OfferValue);
							PRItemSaleInfoDTO.setConstraint(Constraint);
							PRItemSaleInfoDTO.setPromoTypeId(promoTypeId);
							PRItemSaleInfoDTO.setSalePrice(salePrice);

						}

					} else {
						temp.put(key, saleInfoDTO);
					}

				} else {
					temp.put(key, saleInfoDTO);
				}

				tempMap.put(itemCode, temp);
			}
		} catch (Exception ex) {
			logger.error("Error in getSaleDetails() - " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}

		// Adding the promos Item wise in final Map
		tempMap.forEach((item, saleList) -> {

			HashMap<String, PRItemSaleInfoDTO> promoList = new HashMap<String, PRItemSaleInfoDTO>();
			List<PRItemSaleInfoDTO> saleValues = new ArrayList<>();
			promoList = saleList;

			promoList.forEach((key, saleDTO) -> {
				saleValues.add(saleDTO);

			});

			saleDetails.put(item, saleValues);

		});

		return saleDetails;
	}

	public HashMap<Integer, List<PRItemSaleInfoDTO>> getSaleDetails(Connection conn, int productLevelId,
			String productIdList, int chainId, int locationLevelId, int locationId, String weekStartDate,
			int noOfWeekSaleData, List<Integer> stores) throws GeneralException {
		HashMap<Integer, List<PRItemSaleInfoDTO>> saleDetails = new HashMap<Integer, List<PRItemSaleInfoDTO>>();
		List<PRItemSaleInfoDTO> items = new ArrayList<PRItemSaleInfoDTO>();
		int itemCode = 0;
		PRItemSaleInfoDTO saleInfoDTO = new PRItemSaleInfoDTO();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int counter = 0;
		try {

			String query = new String(GET_SALE_PRICE);
			String subQuery = getItemsInCategoryQuery(productLevelId, productIdList);
			query = query.replaceAll("%ITEMS_IN_CATEGORY%", subQuery);

			subQuery = getPromoLocationsQuery(chainId, locationLevelId, locationId, stores, false);
			query = query.replaceAll("%PROMO_LOCATIONS%", subQuery);

			stmt = conn.prepareStatement(query);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

//			logger.debug("GET_SALE_PRICE:" + query);
//			logger.debug("Parameters: 1,2,4,5-" + weekStartDate + ",3,6-" + noOfWeekSaleData * 7);

			stmt.setFetchSize(100000);
			rs = stmt.executeQuery();

			while (rs.next()) {
				items = new ArrayList<PRItemSaleInfoDTO>();
				saleInfoDTO = new PRItemSaleInfoDTO();
				itemCode = rs.getInt("ITEM_CODE");
				saleInfoDTO.setSalePrice(PRCommonUtil.getMultiplePrice(rs.getInt("SALE_QTY"),
						rs.getDouble("SALE_PRICE"), rs.getDouble("SALE_M_PRICE")));
				saleInfoDTO.setSaleStartDate(rs.getString("PROMO_ACTUAL_START_DATE"));
				saleInfoDTO.setSaleEndDate(rs.getString("PROMO_ACTUAL_END_DATE"));
				saleInfoDTO.setSaleWeekStartDate(rs.getString("PROMO_WEEK_START_DATE"));
				saleInfoDTO.setPromoTypeId(rs.getInt("PROMO_TYPE_ID"));

				if (saleDetails.get(itemCode) != null) {
					items = saleDetails.get(itemCode);
				}
				items.add(saleInfoDTO);
				saleDetails.put(itemCode, items);
			}
		} catch (Exception ex) {
			logger.error("Error in getSaleDetails() - " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return saleDetails;
	}

	public HashMap<Integer, List<PRItemAdInfoDTO>> getAdDetails(Connection conn, int productLevelId, int productId,
			int chainId, int zoneId, String weekStartDate, int noOfWeekSaleData, List<Integer> stores,
			boolean isGobalZone) throws GeneralException {
		return getAdDetails(conn, productLevelId, productId, chainId, Constants.ZONE_LEVEL_ID, zoneId, weekStartDate,
				noOfWeekSaleData, stores, isGobalZone);
	}

	public HashMap<Integer, List<PRItemAdInfoDTO>> getAdDetails(Connection conn, int productLevelId, int productId,
			int chainId, int locationLevelId, int locationId, String weekStartDate, int noOfWeekSaleData,
			List<Integer> stores, boolean isGobalZone) throws GeneralException {
		HashMap<Integer, List<PRItemAdInfoDTO>> adDetails = new HashMap<Integer, List<PRItemAdInfoDTO>>();
		List<PRItemAdInfoDTO> items = new ArrayList<PRItemAdInfoDTO>();
		int itemCode = 0;
		PRItemAdInfoDTO adInfoDTO = new PRItemAdInfoDTO();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int counter = 0;
		try {

			String query = new String(GET_AD_DETAILS);
			String subQuery = getItemsInCategoryQuery(productLevelId, productId);
			query = query.replaceAll("%ITEMS_IN_CATEGORY%", subQuery);

			subQuery = getPromoLocationsQuery(chainId, locationLevelId, locationId, stores, isGobalZone);
			query = query.replaceAll("%PROMO_LOCATIONS%", subQuery);
			
			String promoIds = (PropertyManager.getProperty("REC_SUPPORTED_PROMO_TYPES"));
			query = query.replaceAll("%PROMO_ID%", promoIds);

			String calType = PropertyManager.getProperty("RETAIL_CALENDAR_TYPE", Constants.RETAIL_CALENDAR_BUSINESS);
			if (calType.equals(Constants.RETAIL_CALENDAR_PROMO)) {
				query = query.replaceAll("%RETAIL_CALENDAR_TAB_NAME%", "RETAIL_CALENDAR_PROMO");
			} else {
				query = query.replaceAll("%RETAIL_CALENDAR_TAB_NAME%", "RETAIL_CALENDAR");
			}

			stmt = conn.prepareStatement(query);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

//			logger.debug("GET_AD_DETAILS:" + query);
//			logger.debug("Parameters: 1,2-" + weekStartDate + ",3-" + noOfWeekSaleData * 7);

			stmt.setFetchSize(100000);
			rs = stmt.executeQuery();

			while (rs.next()) {
				items = new ArrayList<PRItemAdInfoDTO>();
				adInfoDTO = new PRItemAdInfoDTO();
				itemCode = rs.getInt("ITEM_CODE");
				adInfoDTO.setAdPageNo(rs.getInt("PAGE_NUMBER"));
				adInfoDTO.setAdBlockNo(rs.getInt("BLOCK_NUMBER"));
				adInfoDTO.setWeeklyAdStartDate(rs.getString("AD_DATE"));

				if (adDetails.get(itemCode) != null) {
					items = adDetails.get(itemCode);
				}
				items.add(adInfoDTO);
				adDetails.put(itemCode, items);
			}
		} catch (Exception ex) {
			logger.error("Error in getAdDetails() - " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return adDetails;
	}

	public HashMap<Integer, List<PRItemAdInfoDTO>> getAdDetails(Connection conn, int productLevelId,
			String productIdList, int chainId, int locationLevelId, int locationId, String weekStartDate,
			int noOfWeekSaleData, List<Integer> stores) throws GeneralException {
		HashMap<Integer, List<PRItemAdInfoDTO>> adDetails = new HashMap<Integer, List<PRItemAdInfoDTO>>();
		List<PRItemAdInfoDTO> items = new ArrayList<PRItemAdInfoDTO>();
		int itemCode = 0;
		PRItemAdInfoDTO adInfoDTO = new PRItemAdInfoDTO();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int counter = 0;
		try {

			String query = new String(GET_AD_DETAILS);
			String subQuery = getItemsInCategoryQuery(productLevelId, productIdList);
			query = query.replaceAll("%ITEMS_IN_CATEGORY%", subQuery);

			subQuery = getPromoLocationsQuery(chainId, locationLevelId, locationId, stores, false);
			query = query.replaceAll("%PROMO_LOCATIONS%", subQuery);

			stmt = conn.prepareStatement(query);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

//			logger.debug("GET_AD_DETAILS:" + query);
//			logger.debug("Parameters: 1,2-" + weekStartDate + ",3-" + noOfWeekSaleData * 7);

			stmt.setFetchSize(100000);
			rs = stmt.executeQuery();

			while (rs.next()) {
				items = new ArrayList<PRItemAdInfoDTO>();
				adInfoDTO = new PRItemAdInfoDTO();
				itemCode = rs.getInt("ITEM_CODE");
				adInfoDTO.setAdPageNo(rs.getInt("PAGE_NUMBER"));
				adInfoDTO.setAdBlockNo(rs.getInt("BLOCK_NUMBER"));
				adInfoDTO.setWeeklyAdStartDate(rs.getString("AD_DATE"));

				if (adDetails.get(itemCode) != null) {
					items = adDetails.get(itemCode);
				}
				items.add(adInfoDTO);
				adDetails.put(itemCode, items);
			}
		} catch (Exception ex) {
			logger.error("Error in getAdDetails() - " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return adDetails;
	}

	public HashMap<Integer, List<PRItemDisplayInfoDTO>> getDisplayDetails(Connection conn, int productLevelId,
			int productId, int chainId, int zoneId, String weekStartDate, int noOfWeekSaleData, List<Integer> stores,
			boolean isGobalZone) throws GeneralException {
		return getDisplayDetails(conn, productLevelId, productId, chainId, Constants.ZONE_LEVEL_ID, zoneId,
				weekStartDate, noOfWeekSaleData, stores, isGobalZone);
	}

	public HashMap<Integer, List<PRItemDisplayInfoDTO>> getDisplayDetails(Connection conn, int productLevelId,
			int productId, int chainId, int locationLevelId, int locationId, String weekStartDate, int noOfWeekSaleData,
			List<Integer> stores, boolean isGobalZone) throws GeneralException {
		HashMap<Integer, List<PRItemDisplayInfoDTO>> displayDetails = new HashMap<Integer, List<PRItemDisplayInfoDTO>>();
		List<PRItemDisplayInfoDTO> items = new ArrayList<PRItemDisplayInfoDTO>();
		int itemCode = 0;
		PRItemDisplayInfoDTO displayInfoDTO = new PRItemDisplayInfoDTO();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int counter = 0;
		try {

			String query = new String(GET_DISPLAY_DETAILS);
			String subQuery = getItemsInCategoryQuery(productLevelId, productId);
			query = query.replaceAll("%ITEMS_IN_CATEGORY%", subQuery);

			subQuery = getPromoLocationsQuery(chainId, locationLevelId, locationId, stores, isGobalZone);
			query = query.replaceAll("%PROMO_LOCATIONS%", subQuery);

			String promoIds = (PropertyManager.getProperty("REC_SUPPORTED_PROMO_TYPES"));
			query = query.replaceAll("%PROMO_ID%", promoIds);
			
			stmt = conn.prepareStatement(query);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

//			logger.debug("GET_DISPLAY_DETAILS:" + query);
//			logger.debug("Parameters: 1,2-" + weekStartDate + ",3-" + noOfWeekSaleData * 7);

			stmt.setFetchSize(100000);
			rs = stmt.executeQuery();

			while (rs.next()) {
				items = new ArrayList<PRItemDisplayInfoDTO>();
				displayInfoDTO = new PRItemDisplayInfoDTO();
				itemCode = rs.getInt("ITEM_CODE");
				displayInfoDTO.setDisplayTypeLookup(DisplayTypeLookup.get(rs.getInt("DISPLAY_TYPE_ID")));
				displayInfoDTO.setDisplayWeekStartDate(rs.getString("WEEK_START_DATE"));

				if (displayDetails.get(itemCode) != null) {
					items = displayDetails.get(itemCode);
				}
				items.add(displayInfoDTO);
				displayDetails.put(itemCode, items);
			}
		} catch (Exception ex) {
			logger.error("Error in getDisplayDetails() - " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return displayDetails;
	}

	public HashMap<Integer, List<PRItemDisplayInfoDTO>> getDisplayDetails(Connection conn, int productLevelId,
			String productIdList, int chainId, int locationLevelId, int locationId, String weekStartDate,
			int noOfWeekSaleData, List<Integer> stores) throws GeneralException {
		HashMap<Integer, List<PRItemDisplayInfoDTO>> displayDetails = new HashMap<Integer, List<PRItemDisplayInfoDTO>>();
		List<PRItemDisplayInfoDTO> items = new ArrayList<PRItemDisplayInfoDTO>();
		int itemCode = 0;
		PRItemDisplayInfoDTO displayInfoDTO = new PRItemDisplayInfoDTO();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int counter = 0;
		try {

			String query = new String(GET_DISPLAY_DETAILS);
			String subQuery = getItemsInCategoryQuery(productLevelId, productIdList);
			query = query.replaceAll("%ITEMS_IN_CATEGORY%", subQuery);

			subQuery = getPromoLocationsQuery(chainId, locationLevelId, locationId, stores, false);
			query = query.replaceAll("%PROMO_LOCATIONS%", subQuery);

			stmt = conn.prepareStatement(query);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, noOfWeekSaleData * 7);

//			logger.debug("GET_DISPLAY_DETAILS:" + query);
//			logger.debug("Parameters: 1,2-" + weekStartDate + ",3-" + noOfWeekSaleData * 7);

			stmt.setFetchSize(100000);
			rs = stmt.executeQuery();

			while (rs.next()) {
				items = new ArrayList<PRItemDisplayInfoDTO>();
				displayInfoDTO = new PRItemDisplayInfoDTO();
				itemCode = rs.getInt("ITEM_CODE");
				displayInfoDTO.setDisplayTypeLookup(DisplayTypeLookup.get(rs.getInt("DISPLAY_TYPE_ID")));
				displayInfoDTO.setDisplayWeekStartDate(rs.getString("WEEK_START_DATE"));

				if (displayDetails.get(itemCode) != null) {
					items = displayDetails.get(itemCode);
				}
				items.add(displayInfoDTO);
				displayDetails.put(itemCode, items);
			}
		} catch (Exception ex) {
			logger.error("Error in getDisplayDetails() - " + ex.toString(), ex);
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return displayDetails;
	}

	private String getItemsInCategoryQuery(int productLevelId, int productId) {
		StringBuffer subQuery = new StringBuffer("");
		subQuery.append("SELECT CHILD_PRODUCT_ID FROM ");
		subQuery.append("(SELECT CHILD_PRODUCT_ID, CHILD_PRODUCT_LEVEL_ID FROM PRODUCT_GROUP_RELATION_REC PGR ");

		if (productLevelId > 1) {
			subQuery.append("START WITH PRODUCT_LEVEL_ID =").append(productLevelId);
			if (productId > 0) {
				subQuery.append(" AND PRODUCT_ID = ").append(productId);
			}
			subQuery.append(
					" CONNECT BY PRIOR CHILD_PRODUCT_ID = PRODUCT_ID  AND PRIOR CHILD_PRODUCT_LEVEL_ID = PRODUCT_LEVEL_ID");
		} else if (productLevelId == 1) {
			subQuery.append("WHERE CHILD_PRODUCT_LEVEL_ID = 1 and CHILD_PRODUCT_ID = ? ").append(productId);
		}
		subQuery.append(")");
		subQuery.append("WHERE CHILD_PRODUCT_LEVEL_ID = ").append(Constants.ITEMLEVELID);
		return subQuery.toString();
	}

	public String getItemsInCategoryQuery(int productLevelId, String productIdList) {
		StringBuffer subQuery = new StringBuffer("");
		subQuery.append("SELECT CHILD_PRODUCT_ID FROM ");
		subQuery.append("(SELECT CHILD_PRODUCT_ID, CHILD_PRODUCT_LEVEL_ID FROM PRODUCT_GROUP_RELATION_REC PGR ");

		if (productLevelId > 1) {
			subQuery.append("START WITH PRODUCT_LEVEL_ID =").append(productLevelId);
			subQuery.append(" AND PRODUCT_ID IN ( ").append(productIdList);
			subQuery.append(") ");
			subQuery.append(
					" CONNECT BY PRIOR CHILD_PRODUCT_ID = PRODUCT_ID  AND PRIOR CHILD_PRODUCT_LEVEL_ID = PRODUCT_LEVEL_ID");
		} else if (productLevelId == 1) {
			subQuery.append("WHERE CHILD_PRODUCT_LEVEL_ID = 1 and CHILD_PRODUCT_ID IN (").append(productIdList)
					.append(") ");
		}
		subQuery.append(")");
		subQuery.append("WHERE CHILD_PRODUCT_LEVEL_ID = ").append(Constants.ITEMLEVELID);
		return subQuery.toString();
	}

	public String getPromoLocationsQuery(int chainId, int locationLevelId, int locationId,
			List<Integer> priceZoneStores, boolean isGlobalZone) {
		StringBuffer subQuery = new StringBuffer("");
		// String storeIds =
		// PRCommonUtil.getCommaSeperatedStringFromIntArray(priceZoneStores);

		int defaultPromoDivisionId = Integer.parseInt(PropertyManager.getProperty("PROMO_DEFUALT_DIVISION_ID", "0"));
		int defaultLocationLevelId = Integer
				.parseInt(PropertyManager.getProperty("PROMO_DEFUALT_LOCATION_LEVEL_ID", "0"));
		int defaultLocationId = Integer.parseInt(PropertyManager.getProperty("PROMO_DEFUALT_LOCATION_ID", "0"));

		// NU::15th July 2017, modified to get promotion for store lists

		// Chain level
		subQuery.append("(LOCATION_LEVEL_ID=").append(Constants.CHAIN_LEVEL_ID).append(" AND LOCATION_ID=")
				.append(chainId).append(")");

		// Zone level
		if (locationLevelId == Constants.ZONE_LEVEL_ID) {
			subQuery.append("OR (LOCATION_LEVEL_ID=").append(Constants.ZONE_LEVEL_ID).append(" AND LOCATION_ID=")
					.append(locationId).append(")");

			if (defaultLocationLevelId > 0) {
				subQuery.append("OR (LOCATION_LEVEL_ID=").append(defaultLocationLevelId).append(" AND LOCATION_ID=")
						.append(defaultLocationId).append(")");
			}
			// NU:: 31st Jan 2017, as GE doesn't have zone id defined in the competitor
			// store, above query will not work
			// so stores are passed as input itself

			// Store list level
			subQuery.append("OR (LOCATION_LEVEL_ID=").append(Constants.STORE_LIST_LEVEL_ID)
					.append(" AND LOCATION_ID IN(");
			subQuery.append("SELECT DISTINCT(LOCATION_ID) FROM LOCATION_GROUP_RELATION WHERE LOCATION_LEVEL_ID=")
					.append(Constants.STORE_LIST_LEVEL_ID);
			subQuery.append("AND CHILD_LOCATION_LEVEL_ID=").append(Constants.STORE_LEVEL_ID)
					.append(" AND CHILD_LOCATION_ID IN (");
			// subQuery.append(storeIds).append(")");
			subQuery.append("SELECT COMP_STR_ID FROM COMPETITOR_STORE WHERE PRICE_ZONE_ID=").append(locationId)
					.append(")");
			subQuery.append("))");

			subQuery.append("OR (LOCATION_LEVEL_ID=").append(Constants.DIVISION_LEVEL_ID)
					.append(" AND LOCATION_ID IN(");
			if (defaultPromoDivisionId > 0) {
				subQuery.append(defaultPromoDivisionId);
				subQuery.append("))");
			} else {
				subQuery.append(" SELECT DISTINCT DIVISION_ID FROM COMPETITOR_STORE WHERE PRICE_ZONE_ID = ")
						.append(locationId);
				subQuery.append("))");
			}

		} else if (locationLevelId == Constants.STORE_LIST_LEVEL_ID) {
			subQuery.append("OR (LOCATION_LEVEL_ID=").append(Constants.STORE_LIST_LEVEL_ID).append(" AND LOCATION_ID=")
					.append(locationId).append(")");

			subQuery.append("OR (LOCATION_LEVEL_ID =").append(Constants.ZONE_LEVEL_ID).append(" AND LOCATION_ID IN(");
			subQuery.append(
					"(SELECT PRICE_ZONE_ID FROM COMPETITOR_STORE WHERE COMP_STR_ID IN (SELECT CHILD_LOCATION_ID ");
			subQuery.append(" FROM LOCATION_GROUP_RELATION WHERE LOCATION_LEVEL_ID = ")
					.append(Constants.STORE_LIST_LEVEL_ID);
			subQuery.append(" AND LOCATION_ID = ").append(locationId).append("AND CHILD_LOCATION_LEVEL_ID = ")
					.append(Constants.STORE_LEVEL_ID).append("))))");
		}

		// any store in the zone
		if (isGlobalZone) {
			subQuery.append("OR (LOCATION_LEVEL_ID = ").append(Constants.STORE_LEVEL_ID);
			subQuery.append("AND LOCATION_ID IN (SELECT COMP_STR_ID FROM COMPETITOR_STORE WHERE PRICE_ZONE_ID_3=")
					.append(locationId).append("))");
		} else {
			subQuery.append("OR (LOCATION_LEVEL_ID = ").append(Constants.STORE_LEVEL_ID);
			subQuery.append("AND LOCATION_ID IN (SELECT COMP_STR_ID FROM COMPETITOR_STORE WHERE PRICE_ZONE_ID=")
					.append(locationId).append("))");
		}

		// subQuery.append("AND LOCATION_ID IN (").append(storeIds).append("))");

		return subQuery.toString();
	}

	public long getLatestRecommendationRunId(Connection conn, int locationLevelId, int locationId, int productLevelId,
			int productId, int weekCalendarId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		long recRunId = 0;
		try {
			stmt = conn.prepareStatement(GET_LATEST_RUN_ID_FOR_WEEK);
			stmt.setInt(1, weekCalendarId);
			stmt.setInt(2, locationLevelId);
			stmt.setInt(3, locationId);
			stmt.setInt(4, productLevelId);
			stmt.setInt(5, productId);
			rs = stmt.executeQuery();
			if (rs.next()) {
				recRunId = rs.getLong("RUN_ID");
			}
		} catch (SQLException exception) {
			logger.error("Error in getLatestRecommendationRunId() - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return recRunId;
	}

	public HashMap<String, List<RecommendationRuleMapDTO>> getRecommendationRules(Connection conn) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<String, List<RecommendationRuleMapDTO>> recommendationRuleMap = new HashMap<String, List<RecommendationRuleMapDTO>>();
		RecommendationRuleMapDTO recommendationRuleMapDTO = null;
		List<RecommendationRuleMapDTO> recommendationRules = null;
		try {
			stmt = conn.prepareStatement(GET_REC_RULES);
			rs = stmt.executeQuery();
			while (rs.next()) {
				recommendationRules = new ArrayList<RecommendationRuleMapDTO>();
				recommendationRuleMapDTO = new RecommendationRuleMapDTO();

				String ruleCode = rs.getString("RULE_CODE");
				boolean isEnabled = rs.getInt("ENABLED") > 0 ? true : false;

				recommendationRuleMapDTO.setRuleCode(ruleCode);
				recommendationRuleMapDTO.setEnabled(isEnabled);
				recommendationRuleMapDTO.setObjectiveTypeId(rs.getInt("OBJECTIVE_TYPE_ID"));

				if (recommendationRuleMap.get(ruleCode) != null) {
					recommendationRules = recommendationRuleMap.get(ruleCode);
				}

				recommendationRules.add(recommendationRuleMapDTO);
				recommendationRuleMap.put(ruleCode, recommendationRules);
			}
		} catch (SQLException exception) {
			logger.error("Error in getRecommendationRules() - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return recommendationRuleMap;
	}

	public int getLeadAndDependentZone(Connection conn, int zoneId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int leadZoneId = 0;
		try {
			stmt = conn.prepareStatement(GET_LEAD_DEPENDENT_ZONE);
			stmt.setInt(1, zoneId);
			rs = stmt.executeQuery();
			if (rs.next()) {
				leadZoneId = rs.getInt("USE_STRATEGY_OF_LEAD_ZONE");
			}
		} catch (SQLException exception) {
			logger.error("Error in getLeadAndDependentZone() - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return leadZoneId;
	}

	public String updateReRecommendationDetails(Connection conn, List<PRItemDTO> itemListForInsert)
			throws GeneralException {
		Set<Integer> userOverride = new HashSet<Integer>();
		Set<Integer> sysOverride = new HashSet<Integer>();
		PreparedStatement stmt = null;
		try {
			ObjectMapper mapper = new ObjectMapper();
			stmt = conn.prepareStatement(UPDATE_RE_RECOMMENDATION_DETAILS);
			// TODO:: add override pred status
			String explainLogAsJson = "";
			for (PRItemDTO prItemDTO : itemListForInsert) {
				int counter = 0;
				if ((prItemDTO.isSystemOverrideFlag() || prItemDTO.getUserOverrideFlag() == 1)
						&& prItemDTO.getOverrideRemoved() == 0) {
					explainLogAsJson = "";
//					int counter = 0;
					// Update System Override price only if it is different from actual rec reg
					// price
					if (prItemDTO.isSystemOverrideFlag()) {
						if (prItemDTO.getRecRegPriceBeforeReRecommedation().price
								.equals(prItemDTO.getRecommendedRegPrice().price)
								&& prItemDTO.getRecRegPriceBeforeReRecommedation().multiple
										.equals(prItemDTO.getRecommendedRegPrice().multiple)) {
							stmt.setNull(++counter, Types.NULL);
							stmt.setNull(++counter, Types.NULL);
							stmt.setNull(++counter, Types.NULL);
							stmt.setNull(++counter, Types.NULL);
							stmt.setNull(++counter, Types.NULL);
							stmt.setInt(++counter, 0);
						} else {
							sysOverride.add((Integer) (prItemDTO.getRetLirId() > 0 ? prItemDTO.getRetLirId()
									: prItemDTO.getItemCode()));
							if (prItemDTO.getRecommendedRegPrice() != null) {
								stmt.setInt(++counter,
										prItemDTO.getRecommendedRegPrice() != null
												? prItemDTO.getRecommendedRegPrice().multiple
												: 0);
								stmt.setDouble(++counter,
										prItemDTO.getRecommendedRegPrice() != null
												? prItemDTO.getRecommendedRegPrice().price
												: 0);
								stmt.setDouble(++counter, prItemDTO.getRecRetailSalesDollar());
								stmt.setDouble(++counter, prItemDTO.getRecRetailMarginDollar());
							} else {
								stmt.setNull(++counter, java.sql.Types.INTEGER);
								stmt.setNull(++counter, java.sql.Types.DOUBLE);
								stmt.setNull(++counter, Types.NULL);
								stmt.setNull(++counter, Types.NULL);
							}

							if (prItemDTO.getPredictedMovement() != null)
								stmt.setDouble(++counter, prItemDTO.getPredictedMovement());
							else
								stmt.setNull(++counter, java.sql.Types.DOUBLE);
							stmt.setInt(++counter, prItemDTO.isSystemOverrideFlag() ? 1 : 0);
						}
					} else {
						userOverride.add((Integer) (prItemDTO.getRetLirId() > 0 ? prItemDTO.getRetLirId()
								: prItemDTO.getItemCode()));
						if (prItemDTO.getRecommendedRegPrice() != null) {
							stmt.setInt(++counter,
									prItemDTO.getRecommendedRegPrice() != null
											? prItemDTO.getRecommendedRegPrice().multiple
											: 0);
							stmt.setDouble(++counter,
									prItemDTO.getRecommendedRegPrice() != null
											? prItemDTO.getRecommendedRegPrice().price
											: 0);
							stmt.setDouble(++counter, prItemDTO.getRecRetailSalesDollar());
							stmt.setDouble(++counter, prItemDTO.getRecRetailMarginDollar());
						} else {
							stmt.setNull(++counter, java.sql.Types.INTEGER);
							stmt.setNull(++counter, java.sql.Types.DOUBLE);
							stmt.setNull(++counter, Types.NULL);
							stmt.setNull(++counter, Types.NULL);
						}

						if (prItemDTO.getPredictedMovement() != null)
							stmt.setDouble(++counter, prItemDTO.getPredictedMovement());
						else
							stmt.setNull(++counter, java.sql.Types.DOUBLE);

						stmt.setInt(++counter, prItemDTO.isSystemOverrideFlag() ? 1 : 0);
					}
					// 18th Jan 2018, no need to update
//					stmt.setInt(++counter, prItemDTO.getIsNewPriceRecommended());
					stmt.setDouble(++counter,
							prItemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg() != null
									? prItemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg()
									: Types.NULL);
					stmt.setInt(++counter, 0);

					if (prItemDTO.getPredictionStatus() != null)
						stmt.setInt(++counter, prItemDTO.getPredictionStatus());
					else
						stmt.setNull(++counter, java.sql.Types.INTEGER);

					stmt.setInt(++counter,
							prItemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg() != null
									? prItemDTO.getRecWeekSaleInfo().getSalePredStatusAtRecReg().getStatusCode()
									: 0);
					stmt.setInt(++counter, prItemDTO.getUserOverrideFlag());
					// stmt.setInt(++counter, prItemDTO.getOverrideRemoved());
					if (prItemDTO.isSystemOverrideFlag()) {
						try {
							explainLogAsJson = mapper.writeValueAsString(prItemDTO.getExplainLog());
							stmt.setString(++counter, explainLogAsJson);
						} catch (JsonProcessingException e) {
							explainLogAsJson = "";
							logger.error(
									"Error when converting explain log to json string - " + prItemDTO.getItemCode(), e);
						}
					} else {
						stmt.setNull(++counter, Types.NULL);
					}

				} else {
//					int counter = 0;
					stmt.setNull(++counter, Types.NULL);
					stmt.setNull(++counter, Types.NULL);
					stmt.setNull(++counter, Types.NULL);
					stmt.setNull(++counter, Types.NULL);
					stmt.setNull(++counter, Types.NULL);
					stmt.setInt(++counter, 0);
					// 18th Jan 2018, no need to update
//					stmt.setInt(++counter, prItemDTO.getIsNewPriceRecommended());
					stmt.setDouble(++counter,
							prItemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg() != null
									? prItemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg()
									: Types.NULL);
					stmt.setInt(++counter, 0);
					if (prItemDTO.getPredictionStatus() != null)
						stmt.setInt(++counter, prItemDTO.getPredictionStatus());
					else
						stmt.setNull(++counter, java.sql.Types.INTEGER);
					stmt.setInt(++counter,
							prItemDTO.getRecWeekSaleInfo().getSalePredMovAtCurReg() != null
									? prItemDTO.getRecWeekSaleInfo().getSalePredStatusAtRecReg().getStatusCode()
									: 0);
					stmt.setInt(++counter, 0);
					stmt.setNull(++counter, Types.NULL);
				}
				stmt.setLong(++counter, prItemDTO.getRunId());
				stmt.setInt(++counter, prItemDTO.getItemCode());
				stmt.setString(++counter,
						prItemDTO.isLir() ? String.valueOf(Constants.YES) : String.valueOf(Constants.NO));
				stmt.addBatch();
			}
			int[] count = stmt.executeBatch();
			stmt.clearBatch();
		} catch (SQLException e) {
			logger.error("Error in updateReRecommendationDetails() - ", e);
			throw new GeneralException("Error in updateReRecommendationDetails() - " + e);
		} finally {
			PristineDBUtil.close(stmt);
		}
		return "(# of User Override:" + userOverride.size() + " # of System Override:" + sysOverride.size() + ")";
	}

	public void updateSubPredMovForRerecommendedItems(Connection conn, HashMap<ItemKey, PRItemDTO> itemDataMap)
			throws GeneralException {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_SUBS_PRED_MOV_FOR_RE_RECOMMENDATION_ITEMS);
			for (Map.Entry<ItemKey, PRItemDTO> entry : itemDataMap.entrySet()) {
				PRItemDTO prItemDTO = entry.getValue();
//				logger.debug("Existing Reg Pred Mov: " + prItemDTO.getCurRegPredMovWOSubsEffect()
//						+ " And New Reg Pred Mov: " + prItemDTO.getPredMovWOSubsEffect());
				if (prItemDTO.getCurRegPredMovWOSubsEffect() != null && prItemDTO.getPredMovWOSubsEffect() != null
						&& prItemDTO.getPredMovWOSubsEffect() > 0
						&& prItemDTO.getCurRegPredMovWOSubsEffect() != prItemDTO.getPredMovWOSubsEffect()) {
					int counter = 0;
					stmt.setDouble(++counter, prItemDTO.getPredMovWOSubsEffect());
					stmt.setLong(++counter, prItemDTO.getRunId());
					stmt.setInt(++counter, prItemDTO.getItemCode());
					stmt.setString(++counter,
							prItemDTO.isLir() ? String.valueOf(Constants.YES) : String.valueOf(Constants.NO));
					stmt.addBatch();
				}
			}
			int[] count = stmt.executeBatch();
			stmt.clearBatch();
		} catch (SQLException e) {
			logger.error("Error in updateReRecommendationDetails() - ", e);
			throw new GeneralException("Error in updateReRecommendationDetails() - " + e);
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public void updateOverridePredStatusInRunHeader(Connection conn, long runId) throws GeneralException {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_OVERRIDE_PRED_STATUS_IN_RUN_HEADER);
			stmt.setInt(1, 0);
			stmt.setLong(2, runId);
			stmt.executeUpdate();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendation run header - " + exception.toString());
			throw new GeneralException("Error when updating recommendation run header - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public List<PROrderCode> getOrderAndSellCode(Connection conn, int productLevelId, int productId,
			RetailCalendarDTO curCalDTO, int locationId) throws Exception {

		PreparedStatement stmt = null;
		ResultSet rs = null;
		List<PROrderCode> orderCodes = new ArrayList<PROrderCode>();
		String query;
		int vCounter = 0;
		HashMap<Integer, PROrderCode> orderCodeMap = new HashMap<Integer, PROrderCode>();

		try {
			query = new String(GET_ORDER_SELL_CODE_V2);
//			logger.debug("Order and sell code: " + query);
//			logger.debug("Par" + curCalDTO.getEndDate() + " ,2:" + Constants.ZONE_LEVEL_ID + " ,3:"
//					+ Constants.ZONE_LEVEL_ID + " ,4:" + Constants.CHAIN_LEVEL_ID + " ,5:" + productId + " ,6:"
//					+ productLevelId + " ,7,8:" + locationId + " ,9:" + curCalDTO.getStartDate() + " ,10:"
//					+ curCalDTO.getEndDate());
			stmt = conn.prepareStatement(query);

			stmt.setString(++vCounter, curCalDTO.getEndDate());
			stmt.setInt(++vCounter, Constants.ZONE_LEVEL_ID);
			stmt.setInt(++vCounter, Constants.DIVISION_LEVEL_ID);
			stmt.setInt(++vCounter, Constants.CHAIN_LEVEL_ID);
			stmt.setLong(++vCounter, productId);
			stmt.setInt(++vCounter, productLevelId);
			stmt.setInt(++vCounter, locationId);
			stmt.setInt(++vCounter, locationId);
			stmt.setString(++vCounter, curCalDTO.getStartDate());
			stmt.setString(++vCounter, curCalDTO.getEndDate());

			rs = stmt.executeQuery();
			while (rs.next()) {
				int orderItemCode = rs.getInt("ORDER_ITEM_CODE");
				PROrderCode orderCodeObj;
				PRSellCode sellCode = new PRSellCode();
				if (orderCodeMap.get(orderItemCode) != null) {
					orderCodeObj = orderCodeMap.get(orderItemCode);
				} else {
					orderCodeObj = new PROrderCode();
				}

				// sellCode.setSellCode(rs.getString("SELL_CODE"));
				sellCode.setItemCode(rs.getInt("SELL_ITEM_CODE"));
				sellCode.setYield(rs.getDouble("YIELD"));
				orderCodeObj.setFreshRelationHeaderId(rs.getInt("FRESH_RELATION_HEADER_ID"));
				orderCodeObj.setOrderItemCode(orderItemCode);
				orderCodeObj.getSellCodes().add(sellCode);
				orderCodeMap.put(orderItemCode, orderCodeObj);
			}
		} catch (Exception ex) {
			logger.error("Error in getOrderAndSellCode() -- " + ex.toString(), ex);
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}

		for (Map.Entry<Integer, PROrderCode> entry : orderCodeMap.entrySet()) {
			orderCodes.add(entry.getValue());
		}

		return orderCodes;
	}

	/**
	 * 
	 * @param conn
	 * @param locationLevelId
	 * @param locationId
	 * @param productLevelId
	 * @param productId
	 * @param weekStartDate
	 * @param weeksBehindForOverride
	 * @return overriden items from past recommendations
	 * @throws GeneralException
	 */
	public HashMap<ItemKey, PRItemDTO> getPastRecommendationOverrideDetails(Connection conn, int locationLevelId,
			int locationId, int productLevelId, int productId, String weekStartDate, int weeksBehindForOverride)
			throws GeneralException {

		HashMap<ItemKey, PRItemDTO> overrideItemDataMap = new HashMap<>();
		List<Long> pastRunIds = getPastRunId(conn, locationLevelId, locationId, productLevelId, productId,
				weekStartDate, weeksBehindForOverride);

		if (pastRunIds.size() > 0) {
			overrideItemDataMap = getPastRecommendationOverrideDetails(conn, pastRunIds);
		}
		return overrideItemDataMap;
	}

	private static final String GET_PAST_REC_OVERRIDDEN_ITEMS = "SELECT PRR.LIR_ID_OR_ITEM_CODE, PRR.LIR_IND, "
			+ " PRR.RUN_ID, PRR.OVERRIDE_REG_MULTIPLE, PRR.OVERRIDE_REG_PRICE, TO_CHAR(RC.START_DATE, '"
			+ Constants.DB_DATE_FORMAT + "') AS START_DATE FROM PR_RECOMMENDATION PRR "
			+ " LEFT JOIN PR_RECOMMENDATION_RUN_HEADER PRH ON PRH.RUN_ID = PRR.RUN_ID "
			+ "	LEFT JOIN RETAIL_CALENDAR RC ON PRH.CALENDAR_ID = RC.CALENDAR_ID "
			+ " WHERE PRH.RUN_ID IN (%s) AND PRR.OVERRIDE_REG_PRICE > 0 ORDER BY RC.START_DATE DESC";

	/**
	 * 
	 * @param conn
	 * @param runId
	 * @return overriden items from past recommendations
	 * @throws GeneralException
	 */
	private HashMap<ItemKey, PRItemDTO> getPastRecommendationOverrideDetails(Connection conn, List<Long> pastRunIds)
			throws GeneralException {
		HashMap<ItemKey, PRItemDTO> overrideItemDataMap = new HashMap<>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			Object[] values = pastRunIds.toArray();

			stmt = conn.prepareStatement(
					String.format(GET_PAST_REC_OVERRIDDEN_ITEMS, PristineDBUtil.preparePlaceHolders(values.length)));
			PristineDBUtil.setValues(stmt, 1, values);
			rs = stmt.executeQuery();
			while (rs.next()) {
				PRItemDTO prItemDTO = new PRItemDTO();
				prItemDTO.setItemCode(rs.getInt("LIR_ID_OR_ITEM_CODE"));
				String lirInd = rs.getString("LIR_IND");
				if (lirInd.equals("Y")) {
					prItemDTO.setLir(true);
					prItemDTO.setRetLirId(prItemDTO.getItemCode());
				} else {
					prItemDTO.setLir(false);
				}

				int overrideQty = rs.getInt("OVERRIDE_REG_MULTIPLE");
				double overridePrice = rs.getDouble("OVERRIDE_REG_PRICE");
				MultiplePrice overrideMultiPrice = new MultiplePrice(overrideQty, overridePrice);
				prItemDTO.setOverriddenRegularPrice(overrideMultiPrice);
				prItemDTO.setPastOverrideDate(rs.getString("START_DATE"));
				prItemDTO.setRunId(rs.getLong("RUN_ID"));
				ItemKey itemKey = PRCommonUtil.getItemKey(prItemDTO);

				if (!overrideItemDataMap.containsKey(itemKey)) {
					overrideItemDataMap.put(itemKey, prItemDTO);
				}
			}
		} catch (SQLException sqlE) {
			throw new GeneralException("Error--getPastRecommendationOverrideDetails()", sqlE);
		}
		return overrideItemDataMap;
	}

	private static final String GET_X_WEEKS_BEHIND_RUN_ID = "SELECT RUN_ID FROM PR_RECOMMENDATION_RUN_HEADER PRH "
			+ " LEFT JOIN RETAIL_CALENDAR RC ON RC.CALENDAR_ID = PRH.CALENDAR_ID WHERE "
			+ " PRH.LOCATION_LEVEL_ID = ? AND PRH.LOCATION_ID = ? AND PRH.PRODUCT_LEVEL_ID = ? AND PRH.PRODUCT_ID = ? "
			+ " AND RC.START_DATE <= TO_DATE(?, '" + Constants.DB_DATE_FORMAT + "') AND RC.START_DATE >= (TO_DATE(?, '"
			+ Constants.DB_DATE_FORMAT + "') - (? + 1) * 7)  AND PRH.STATUS IN (" + PRConstants.STATUS_APPROVED + ", "
			+ PRConstants.STATUS_EXPORTED + ")";

	/**
	 * 
	 * @param conn
	 * @param locationLevelId
	 * @param locationId
	 * @param productLevelId
	 * @param productId
	 * @param weekStartDate
	 * @param weeksBehindForOverride
	 * @return run id
	 * @throws GeneralException
	 */
	private List<Long> getPastRunId(Connection conn, int locationLevelId, int locationId, int productLevelId,
			int productId, String weekStartDate, int weeksBehindForOverride) throws GeneralException {
		List<Long> pastRunIds = new ArrayList<>();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {

			stmt = conn.prepareStatement(GET_X_WEEKS_BEHIND_RUN_ID);
			int counter = 0;
			stmt.setInt(++counter, locationLevelId);
			stmt.setInt(++counter, locationId);
			stmt.setInt(++counter, productLevelId);
			stmt.setInt(++counter, productId);
			stmt.setString(++counter, weekStartDate);
			stmt.setString(++counter, weekStartDate);
			stmt.setInt(++counter, weeksBehindForOverride);

			rs = stmt.executeQuery();
			while (rs.next()) {
				long runId = rs.getLong("RUN_ID");
				pastRunIds.add(runId);
			}
		} catch (SQLException e) {
			throw new GeneralException("Error--getPastRunId()", e);
		}
		return pastRunIds;
	}

	/**
	 * 
	 * @param connection
	 * @param chainId
	 * @param inputDTO
	 * @param calDTO
	 * @param resetCalDTO
	 * @param noOfWeeksInFuture
	 * @param inputDataMap
	 * @param itemDataMapStore
	 * @param itemDataMapStoreNotInCache
	 * @param fetchZoneData
	 * @param priceAndStrategyZoneNos
	 * @param priceZoneStores
	 * @throws GeneralException
	 */
	public void getFuturePriceData(Connection connection, Integer chainId, PRStrategyDTO inputDTO,
			RetailCalendarDTO calDTO, RetailCalendarDTO resetCalDTO, int noOfWeeksInFuture,
			HashMap<ItemKey, PRItemDTO> inputDataMap, HashMap<Integer, HashMap<ItemKey, PRItemDTO>> itemDataMapStore,
			HashMap<Integer, HashMap<ItemKey, PRItemDTO>> itemDataMapStoreNotInCache, boolean fetchZoneData,
			List<String> priceAndStrategyZoneNos, List<Integer> priceZoneStores) throws GeneralException {

		RetailPriceCostKey chainKey = new RetailPriceCostKey(Constants.CHAIN_LEVEL_TYPE_ID, chainId);
		RetailPriceCostKey zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, inputDTO.getLocationId());

		RetailCalendarDAO calendarDAO = new RetailCalendarDAO();
		RetailPriceServiceOptimized priceService = new RetailPriceServiceOptimized(connection);
		boolean fetchStoreData = false;

		if (itemDataMapStore != null && itemDataMapStore.size() > 0)
			fetchStoreData = true;

		if (fetchZoneData || fetchStoreData) {
			List<RetailCalendarDTO> retailCalendarList = calendarDAO.getFutureCalendarList(connection,
					calDTO.getCalendarId(), noOfWeeksInFuture);
			Set<Integer> itemCodeSet = new HashSet<Integer>();
			for (PRItemDTO item : inputDataMap.values()) {
				if (!item.isLir())
					itemCodeSet.add(item.getItemCode());
			}

			retailCalendarList.sort((RetailCalendarDTO s1, RetailCalendarDTO s2) -> s1.getStartDateAsDate()
					.compareTo(s2.getStartDateAsDate()));

//			logger.debug("Loading current week Price");
			for (RetailCalendarDTO curCalDTO : retailCalendarList) {
//				logger.debug(
//						"Running for calendar id " + curCalDTO.getCalendarId() + " for items " + itemCodeSet.size());
				if (itemCodeSet.size() > 0) {
					HashMap<Integer, HashMap<RetailPriceCostKey, RetailPriceDTO>> priceDataMap = priceService
							.getRetailPrice(curCalDTO.getCalendarId(), chainId, priceAndStrategyZoneNos,
									priceZoneStores, fetchStoreData, itemCodeSet);
					// Populate price data for zone
					if (fetchZoneData) {
						for (Map.Entry<ItemKey, PRItemDTO> entry : inputDataMap.entrySet()) {
							int itemCode = entry.getKey().getItemCodeOrRetLirId();
							PRItemDTO item = entry.getValue();
							zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
							// logger.debug("Price -- Actual Zone Id: " + item.getPriceZoneId());
							if (priceDataMap.get(itemCode) != null) {
								HashMap<RetailPriceCostKey, RetailPriceDTO> costMap = priceDataMap.get(itemCode);
								RetailPriceDTO priceDTO = priceService.findPriceForZone(costMap, zoneKey, chainKey);
								populateFuturePrice(item, priceDTO, calDTO);
								if (itemCodeSet.contains(itemCode))
									itemCodeSet.remove(itemCode);
							}
						}
					}

					// Populate price data for store
					if (fetchStoreData) {
						for (Map.Entry<Integer, HashMap<ItemKey, PRItemDTO>> entry : itemDataMapStoreNotInCache
								.entrySet()) {
							RetailPriceCostKey storeKey = new RetailPriceCostKey(Constants.STORE_LEVEL_TYPE_ID,
									entry.getKey());
							for (Map.Entry<ItemKey, PRItemDTO> inEntry : entry.getValue().entrySet()) {
								int itemCode = inEntry.getKey().getItemCodeOrRetLirId();
								// PRItemDTO item = itemDataMapStore.get(entry.getKey()).get(itemCode);
								PRItemDTO item = itemDataMapStore.get(entry.getKey()).get(inEntry.getKey());
								// Look for store's zone if not present at store level (price and strategy zone
								// changes)
								zoneKey = new RetailPriceCostKey(Constants.ZONE_LEVEL_TYPE_ID, item.getPriceZoneId());
								if (priceDataMap.get(itemCode) != null) {
									HashMap<RetailPriceCostKey, RetailPriceDTO> costMap = priceDataMap.get(itemCode);
									RetailPriceDTO priceDTO = priceService.findPriceForStore(costMap, storeKey, zoneKey,
											chainKey);
									populateFuturePrice(item, priceDTO, calDTO);
									if (itemCodeSet.contains(itemCode))
										itemCodeSet.remove(itemCode);
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * 
	 * @param item
	 * @param priceDTO
	 */
	private void populateFuturePrice(PRItemDTO item, RetailPriceDTO priceDTO, RetailCalendarDTO calDTO) {

		LocalDate currentWeek = LocalDate.parse(calDTO.getStartDate(), PRCommonUtil.getDateFormatter());
		if (priceDTO.getRegEffectiveDate() != null) {
			LocalDate effectiveDate = LocalDate.parse(priceDTO.getRegEffectiveDate(), PRCommonUtil.getDateFormatter());
			if (effectiveDate.isAfter(currentWeek)) {
				double price = priceDTO.getRegQty() > 1 ? (priceDTO.getRegMPrice() / priceDTO.getRegQty())
						: priceDTO.getRegPrice();
				int qty = (priceDTO.getRegQty() == 0 ? 1 : priceDTO.getRegQty());
				double mPrice = new Double(priceDTO.getRegMPrice());
				MultiplePrice futurePrice = PRCommonUtil.getMultiplePrice(qty, price, mPrice);
				item.setFutureRecRetail(futurePrice);
				item.setRecPriceEffectiveDate(priceDTO.getRegEffectiveDate());
//				logger.debug("populateFuturePrice() - Future retail found: " + item.getItemCode());
//				logger.debug("populateFuturePrice() - Future retail: " + futurePrice.toString());
			}
		}
	}

	/**
	 * 
	 * @param connection
	 * @param compStrId
	 * @param weekStartDate
	 * @param maxDataLookupRange
	 * @param rank
	 * @param itemCodes
	 * @return latest comp price data given list of items
	 * @throws GeneralException
	 */
	public HashMap<Integer, CompetitiveDataDTO> getCompPriceDataForItems(Connection connection, int compStrId,
			String weekStartDate, int maxDataLookupRange, int rank, List<Integer> itemCodes) throws GeneralException {
		HashMap<Integer, CompetitiveDataDTO> priceData = new HashMap<>();
		List<Integer> itemCodeList = new ArrayList<>();
		int counter = 0;
		for (int itemCode : itemCodes) {
			counter++;
			itemCodeList.add(itemCode);
			if (counter % Constants.BATCH_UPDATE_COUNT == 0) {
				Object[] values = itemCodeList.toArray();
				retrieveCompPriceDataForItems(connection, compStrId, weekStartDate, maxDataLookupRange, rank, priceData,
						values);

				itemCodeList.clear();
				counter = 0;
			}
		}

		if (counter > 0) {
			Object[] values = itemCodeList.toArray();
			retrieveCompPriceDataForItems(connection, compStrId, weekStartDate, maxDataLookupRange, rank, priceData,
					values);

			itemCodeList.clear();
		}
		return priceData;
	}

	/**
	 * Retrieves competition data from database
	 * 
	 * @param connection
	 * @param inputDTO
	 * @param weekStartDate
	 * @param maxDataLookupRange
	 * @throws GeneralException
	 */
	private void retrieveCompPriceDataForItems(Connection connection, int compStrId, String weekStartDate,
			int maxDataLookupRange, int rank, HashMap<Integer, CompetitiveDataDTO> priceData, Object... values)
			throws GeneralException {
		long startTime = System.currentTimeMillis();
		PreparedStatement statement = null;
		ResultSet resultSet = null;
		try {
			String query = new String(GET_COMP_PRICE_DATA_FOR_ITEMS);

//			logger.debug("Comp Price Query " + query);
//			logger.debug("Query Parameters. 1--" + compStrId + ",2,3--" + weekStartDate + ",4--" + maxDataLookupRange);

			query = String.format(query, PristineDBUtil.preparePlaceHolders(values.length));

			statement = connection.prepareStatement(query);

			PristineDBUtil.setValues(statement, values);

			int counter = values.length;
			statement.setInt(++counter, compStrId);
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekStartDate);
			statement.setInt(++counter, maxDataLookupRange);
			statement.setLong(++counter, rank);

			statement.setFetchSize(10000);
			resultSet = statement.executeQuery();
			long endTime = System.currentTimeMillis();
//			logger.debug("Time taken to retrieve price data " + (endTime - startTime));
//			logger.debug("Price Query executed");

			while (resultSet.next()) {
				CompetitiveDataDTO compDataDTO = new CompetitiveDataDTO();
				compDataDTO.itemcode = resultSet.getInt("ITEM_CODE");
				if (compDataDTO.itemcode == 0)
					continue;
				compDataDTO.retailerItemCode = resultSet.getString("RETAILER_ITEM_CODE");
				compDataDTO.weekStartDate = resultSet.getString("START_DATE");
				compDataDTO.regPrice = resultSet.getFloat("REG_PRICE");
				compDataDTO.regMPack = resultSet.getInt("REG_M_PACK");
				compDataDTO.regMPrice = resultSet.getFloat("REG_M_PRICE");
				compDataDTO.fSalePrice = resultSet.getFloat("SALE_PRICE");
				compDataDTO.saleMPack = resultSet.getInt("SALE_M_PACK");
				compDataDTO.fSaleMPrice = resultSet.getFloat("SALE_M_PRICE");
				compDataDTO.effRegRetailStartDate = resultSet.getString("EFF_REG_START_DATE");
				compDataDTO.lirId = resultSet.getInt("RET_LIR_ID");
				compDataDTO.checkDate = resultSet.getString("CHECK_DATETIME");
				priceData.put(compDataDTO.itemcode, compDataDTO);
			}
		} catch (SQLException e) {
			logger.error("Error while executing GET_COMP_PRICE_DATA " + e);
			throw new GeneralException("Error while executing GET_COMP_PRICE_DATA " + e);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}
		long endTime = System.currentTimeMillis();
		logger.debug("Time taken to retrieve price data " + (endTime - startTime));
	}

	public void updateReRecommendationStatus(Connection conn, long runId, int percentCompleted, String message) {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_RERECOMMENDATION_STATUS);
			stmt.setString(1, message);
			stmt.setInt(2, percentCompleted);
			stmt.setString(3,
					percentCompleted == 100 ? PRConstants.RUN_STATUS_SUCCESS : PRConstants.RUN_STATUS_IN_PROGRESS);
			logger.info(message + "\t" + percentCompleted);
			stmt.setLong(4, runId);
			stmt.executeUpdate();
			conn.commit();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendations - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public void updateReRecommendationStatusQR(Connection conn, long runId, int percentCompleted, String message) {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_RERECOMMENDATION_STATUS_QR);
			stmt.setString(1, message);
			stmt.setInt(2, percentCompleted);
			stmt.setString(3,
					percentCompleted == 100 ? PRConstants.RUN_STATUS_SUCCESS : PRConstants.RUN_STATUS_IN_PROGRESS);
			logger.info(message + "\t" + percentCompleted);
			stmt.setLong(4, runId);
			stmt.executeUpdate();
			conn.commit();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendations - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public void updateRunStatus(Connection conn, long runId, String runStatus) {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_REC_RUN_STATUS);
			stmt.setString(1, runStatus);
			stmt.setLong(2, runId);
			stmt.executeUpdate();
			conn.commit();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendations - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public void updateRunStatusQR(Connection conn, long runId, String runStatus) {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_REC_RUN_STATUS_QR);
			stmt.setString(1, runStatus);
			stmt.setLong(2, runId);
			stmt.executeUpdate();
			conn.commit();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendations - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}

	public void updateOverridePredStatusInRunHeaderQR(Connection conn, long runId) throws GeneralException {
		PreparedStatement stmt = null;
		try {
			stmt = conn.prepareStatement(UPDATE_OVERRIDE_PRED_STATUS_IN_RUN_HEADER_QR);
			stmt.setInt(1, 0);
			stmt.setLong(2, runId);
			stmt.executeUpdate();
		} catch (SQLException exception) {
			logger.error("Error when updating recommendation run header - " + exception.toString());
			throw new GeneralException("Error when updating recommendation run header - " + exception.toString());
		} finally {
			PristineDBUtil.close(stmt);
		}
	}
	
	/**
	 * 
	 * @param secondaryZoneRecDTO
	 * @param priceDTO
	 */
	private void populateSecondaryZonePrice(SecondaryZoneRecDTO secondaryZoneRecDTO, RetailPriceDTO priceDTO) {
		double price = priceDTO.getRegQty() > 1 ? (priceDTO.getRegMPrice() / priceDTO.getRegQty())
				: priceDTO.getRegPrice();
		int regQty = (priceDTO.getRegQty() == 0 ? 1 : priceDTO.getRegQty());
		double regMPrice = new Double(priceDTO.getRegMPrice());
		MultiplePrice currentPrice = PRCommonUtil.getMultiplePrice(regQty, price, regMPrice);
		secondaryZoneRecDTO.setCurrentRegPrice(currentPrice);
	}
	public long getLatestRecommendationRunIdForAudit(Connection conn, int locationLevelId, int locationId, int productLevelId,
			int productId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		long recRunId = 0;
		try {
			stmt = conn.prepareStatement(GET_LATEST_RUN_ID_QTR);
			
			stmt.setInt(1, locationLevelId);
			stmt.setInt(2, locationId);
			stmt.setInt(3, productLevelId);
			stmt.setInt(4, productId);
			rs = stmt.executeQuery();
			if (rs.next()) {
				recRunId = rs.getLong("RUN_ID");
			}
		} catch (SQLException exception) {
			logger.error("Error in getLatestRecommendationRunIdForAudit() - " + exception.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return recRunId;
	}

	public HashMap<ItemKey, List<PriceCheckListDTO>> getPriceCheckListInfoForPriceTest(Connection conn,
			int locationLevelId, int locationId, int productLevelId, int productId) {
		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<ItemKey, List<PriceCheckListDTO>> priceCheckListMap = new HashMap<ItemKey, List<PriceCheckListDTO>>();
		int counter = 0;
		ItemKey itemKey;
		executionTimeLog = new ExecutionTimeLog(PRConstants.GET_PRICE_CHECK_LIST_INFO_PRICE_TEST);
		try {

			stmt = conn.prepareStatement(PRICE_CHECK_LIST_FOR_PRICE_TEST);
//				logger.debug("getPriceCheckListInfoForPriceTest() query-:"+ PRICE_CHECK_LIST_FOR_PRICE_TEST);
			// stmt.setInt(++counter, locationId);
			stmt.setInt(++counter, productLevelId);
			stmt.setInt(++counter, productId);

				logger.info ("getPriceCheckListInfoForPriceTest()- PRICE_CHECK_LIST_FOR_PRICE_TEST:" + PRICE_CHECK_LIST_FOR_PRICE_TEST + " ;Counters,1:" +
				+ locationId  + ",2:" + productLevelId  + ",3:" + productId   );

			rs = stmt.executeQuery();

			while (rs.next()) {
				int itemCode = rs.getInt("ITEM_CODE");
				// String lirInd = rs.getString("LIR_IND");
				int retLirId = rs.getInt("RET_LIR_ID");

				itemKey = PRCommonUtil.getItemKey(itemCode, false);
				if (retLirId > 0) {
					itemKey = PRCommonUtil.getItemKey(retLirId, true);
				} else {
					itemKey = PRCommonUtil.getItemKey(itemCode, false);
				}

				List<PriceCheckListDTO> tList = null;
				if (priceCheckListMap.get(itemKey) != null) {
					tList = priceCheckListMap.get(itemKey);
				} else {
					tList = new ArrayList<PriceCheckListDTO>();
				}
				PriceCheckListDTO pDTO = new PriceCheckListDTO();
				pDTO.setPriceCheckListId(rs.getInt("PRICE_CHECK_LIST_ID"));
				pDTO.setPriceCheckListTypeId(rs.getInt("PRICE_CHECK_LIST_TYPE_ID"));
				pDTO.setLocationLevelId(rs.getInt("LOCATION_LEVEL_ID"));
				pDTO.setLocationId(rs.getInt("LOCATION_ID"));
				pDTO.setMinRetail(rs.getDouble("MIN_PRICE"));
				pDTO.setMaxRetail(rs.getDouble("MAX_PRICE"));
				pDTO.setLockedRetail(rs.getDouble("LOCKED_RETAIL"));
				pDTO.setEndDate(rs.getString("END_DATE"));
				pDTO.setCheckListTypeName(rs.getString("CHECKLIST_NAME"));
				pDTO.setItemCode(itemCode);
				
				// 09-Jun-2017 : Code added to Precedence of Item List
				if (rs.getObject("PRECEDENCE") != null) {
					pDTO.setPrecedence(rs.getInt("PRECEDENCE"));
				} else {
					pDTO.setPrecedence(null);
				}

				tList.add(pDTO);
				priceCheckListMap.put(itemKey, tList);
			}
		} catch (SQLException e) {
			logger.error("Error while retrieving  PriceCheckListInfoForPriceTest" + e.getMessage());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		executionTimeLog.setEndTime();
		executionTimeLogs.add(executionTimeLog);
		return priceCheckListMap;
	}

	/**
	 * 
	 * @param conn
	 * @param itemDataMap
	 * @param latestRunIds
	 * @param productId
	 * @param productLevelId
	 * @return
	 * @throws GeneralException
	 */
	public HashMap<ItemKey, HashMap<Integer, Double>> setLatestRecPricesforZones(Connection conn,
			HashMap<ItemKey, PRItemDTO> itemDataMap, HashMap<Integer, Long> latestRunIds, int productId,
			int productLevelId) throws GeneralException {
		PreparedStatement statement = null;
		ResultSet rst = null;
		ItemKey itemKey = null;
		HashMap<ItemKey, HashMap<Integer, Double>> ReccMap = new HashMap<ItemKey, HashMap<Integer, Double>>();
		int zoneId = 0;
		try {

			for (Entry<Integer, Long> entry : latestRunIds.entrySet()) {
				StringBuffer query = new StringBuffer();
				zoneId = entry.getKey();

//				logger.debug("zoneId:" + zoneId );

				query.append(
						"SELECT RUN_ID,REC_REG_PRICE,PRODUCT_ID,PRODUCT_LEVEL_ID,OVERRIDE_REG_PRICE,REC_REG_MULTIPLE,OVERRIDE_REG_MULTIPLE,RET_LIR_ID FROM PR_QUARTER_REC_ITEM ");

				query.append("WHERE RUN_ID IN(" + entry.getValue() + ") AND CAL_TYPE =" + "'"
						+ Constants.CALENDAR_QUARTER + "'" + " ORDER BY RET_LIR_ID ");

//				logger.debug(" setLatestRecPricesforZones() query:- " + query.toString());

				statement = conn.prepareStatement(query.toString());

				rst = statement.executeQuery();

				while (rst.next()) {
					double recUnitPrice = 0;
//					logger.info("setLatestRecPricesforZones()- itemCode:" + rst.getInt("PRODUCT_ID") + " ; ret_id :"
//							+ rst.getInt("RET_LIR_ID") + "levelid: " + rst.getInt("PRODUCT_LEVEL_ID"));
					if ((rst.getInt("PRODUCT_LEVEL_ID") == Constants.ITEM_LEVEL_CHILD_PRODUCT_LEVEL_ID

							&& rst.getInt("RET_LIR_ID") == 0)
							|| rst.getInt("PRODUCT_LEVEL_ID") == Constants.PRODUCT_LEVEL_ID_LIG) {

						if (rst.getInt("PRODUCT_LEVEL_ID") == Constants.PRODUCT_LEVEL_ID_LIG) {
							itemKey = new ItemKey(rst.getInt("RET_LIR_ID"), PRConstants.LIG_ITEM_INDICATOR);

						} else if (rst.getInt("PRODUCT_LEVEL_ID") == Constants.ITEM_LEVEL_CHILD_PRODUCT_LEVEL_ID
								&& rst.getInt("RET_LIR_ID") == 0) {
							itemKey = new ItemKey(rst.getInt("PRODUCT_ID"), PRConstants.NON_LIG_ITEM_INDICATOR);

						}

						HashMap<Integer, Double> tempMap = new HashMap<Integer, Double>();

						if (ReccMap.containsKey(itemKey)) {
							tempMap = ReccMap.get(itemKey);
						}

						if (rst.getDouble("OVERRIDE_REG_PRICE") > 0) {
							if (rst.getDouble("OVERRIDE_REG_MULTIPLE") > 0) {
								recUnitPrice = rst.getDouble("OVERRIDE_REG_PRICE")
										/ rst.getDouble("OVERRIDE_REG_MULTIPLE");
							}
						} else {
							if (rst.getDouble("REC_REG_MULTIPLE") > 0) {
								recUnitPrice = rst.getDouble("REC_REG_PRICE") / rst.getDouble("REC_REG_MULTIPLE");
							}
						}

						tempMap.put(zoneId, recUnitPrice);
						ReccMap.put(itemKey, tempMap);
					}

				}

			}

		} catch (Exception e) {
			logger.error("setLatestRecPricesforZones()-Exception while setting latest reccPrices" + e);
			throw new GeneralException("Exception while setting latest reccPrice for runIDs", e);
		} finally {
			PristineDBUtil.close(rst);
			PristineDBUtil.close(statement);
		}
		return ReccMap;
	}

	/**
	 * 
	 * @param conn
	 * @param distinctZoneIDs
	 * @param productId
	 * @param productLevelId
	 * @return
	 * @throws GeneralException
	 */
	public HashMap<Integer, Long> getLatestRunIdsForZones(Connection conn, Set<Integer> distinctZoneIDs, int productId,
			int productLevelId) throws GeneralException {
		PreparedStatement statement = null;
		ResultSet rst = null;

		HashMap<Integer, Long> zoneAndRunId = new HashMap<Integer, Long>();
		try {

			for (Integer zoneID : distinctZoneIDs) {

				StringBuffer query = new StringBuffer();

				query.append("SELECT MAX(RUN_ID) AS LATEST_RUN_ID FROM PR_QUARTER_REC_HEADER WHERE LOCATION_LEVEL_ID = "
						+ Constants.ZONE_LEVEL_ID + "  AND PRODUCT_ID = " + productId + " AND PRODUCT_LEVEL_ID = "
						+ productLevelId + " AND LOCATION_ID=");
				query.append(zoneID + " AND RUN_STATUS='S' AND( RUN_TYPE='B' OR RUN_TYPE='D')");

//				logger.debug("setLatestRecPricesforZones()- get latest runids query:- " + query);
//				logger.debug("parameters 1"+ productId + ";2."+ productLevelId +";3."+ zoneID);
				statement = conn.prepareStatement(query.toString());
				rst = statement.executeQuery();

				while (rst.next()) {

					if (rst.getLong("LATEST_RUN_ID") > 0) {
//						logger.info(
//								"putting values in map for zone: " + zoneID + "runid :" + rst.getLong("LATEST_RUN_ID"));
						zoneAndRunId.put(zoneID, rst.getLong("LATEST_RUN_ID"));
					}
				}
			}

		} catch (Exception e) {

			logger.error("getLatestRunIdsForZones()-Exception while getting latest runIDs" + e);
			throw new GeneralException("Exception while getting latest runIDs", e);
		} finally {
			PristineDBUtil.close(rst);
			PristineDBUtil.close(statement);
		}
		return zoneAndRunId;
	}

	// Changes done by Bhargavi on 01/05/2021
	// update the MarkUp and MarkDown values for Rite Aid
	public HashMap<Integer, Integer> getInventoryDetails(String baseWeek, int productLevelId, int productId,
			int locationId) throws GeneralException {
		HashMap<Integer, Integer> itemInventory = new HashMap<Integer, Integer>();

		PreparedStatement stmt = null;
		ResultSet rs = null;

		try {

			stmt = DBManager.getConnection().prepareStatement(GET_INVENTORY_DETAILS);
			int counter = 0;
//			stmt.setString(++counter,baseWeek);
			stmt.setInt(++counter, productLevelId);
			stmt.setInt(++counter, productId);
			stmt.setInt(++counter, locationId);
			stmt.setInt(++counter, locationId);

//			logger.info("getquantityDetails() query-:" + stmt);

			rs = stmt.executeQuery();

			while (rs.next()) {
				int itemId = rs.getInt("ITEM_CODE");
				int itemQuantity = rs.getInt("QTY_IN_HAND");
				itemInventory.put(itemId, itemQuantity);
			}

		} catch (Exception ex) {
			throw new GeneralException(ex.toString());
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}

		return itemInventory;

	}
	// Changes-ended

	/** PROM-2223 changes started **/
	// Added by Karishma on 04/10/2021 for AZ release
	/**
	 * 
	 * @param productId
	 * @param conn
	 * @return
	 * @throws Exception
	 */
	public HashMap<Integer, Map<Double, List<Double>>> getLatestRegRetailslOfZones(int productId, Connection conn)
			throws Exception {

		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<Integer, Map<Double, List<Double>>> itemMap = new HashMap<>();
		try {

			String query = new String(GET_LATEST_REG_PRICES);
			int counter = 0;
			stmt = conn.prepareStatement(query);
			stmt.setInt(++counter, productId);
			rs = stmt.executeQuery();
			logger.debug("getLatestRegRetailslOfZones() query :"+ query);
			while (rs.next()) {
				Map<Double, List<Double>> tempPrice = new HashMap<Double, List<Double>>();
				List<Double> temparray=new ArrayList<Double>();

				if (itemMap.containsKey(rs.getInt("PRODUCT_ID"))) {
					tempPrice = itemMap.get(rs.getInt("PRODUCT_ID"));
					if (tempPrice.containsKey(rs.getDouble("REG_PRICE"))) {
						temparray = tempPrice.get(rs.getDouble("REG_PRICE"));
						temparray.add(rs.getDouble("MOV_52_WEEK"));
					} else
					temparray.add(rs.getDouble("MOV_52_WEEK"));
					tempPrice.put(rs.getDouble("REG_PRICE"), temparray);
				} else {
					temparray.add(rs.getDouble("MOV_52_WEEK"));
					tempPrice.put(rs.getDouble("REG_PRICE"), temparray);
				}
				
				itemMap.put(rs.getInt("PRODUCT_ID"), tempPrice);
			}
		} catch (Exception ex) {
			logger.error("Error in getLatestRegRetailslOfZones() -- " + ex.toString());
			throw new Exception();
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		return itemMap;
	}

	/** PROM-2223 changes end **/

	/**
	 * 
	 * @param conn
	 * @return
	 * @throws Exception
	 */
	public HashMap<Integer, PRItemDTO> getQueueRecommendations(Connection conn, int productId, int locationId)
			throws Exception {

		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<Integer, PRItemDTO> queuedReccsMap = new HashMap<>();
		try {

			String query = new String(GET_QUEUED_RECCS);
			int counter = 0;
			stmt = conn.prepareStatement(query);
			stmt.setInt(++counter, productId);
			stmt.setInt(++counter, locationId);
			rs = stmt.executeQuery();

			logger.debug("getQueueRecommendations- query: " + query);

			while (rs.next()) {
				MultiplePrice price = null;
				PRItemDTO prDto = new PRItemDTO();
				prDto.setProductId(rs.getInt("PRODUCT_ID"));
				prDto.setImpact(rs.getDouble("PRC_CHANGE_IMPACT"));
				if (rs.getDouble("OVERRIDE_REG_PRICE") > 0)
					price = new MultiplePrice(rs.getInt("OVERRIDE_REG_MULTIPLE"), rs.getDouble("OVERRIDE_REG_PRICE"));
				else
					price = new MultiplePrice(rs.getInt("REC_REG_MULTIPLE"), rs.getDouble("REC_REG_PRICE"));

				prDto.setRecommendedRegPrice(price);
				queuedReccsMap.put(prDto.getProductId(), prDto);

			}
		} catch (Exception ex) {
			logger.error("Error in getQueueRecommendations() -- " + ex.toString());
			throw new Exception(ex);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		logger.info("getQueueRecommendations- # of items in queuedReccsMap:" + queuedReccsMap.size());
		return queuedReccsMap;
	}

	/**
	 * ADDED BY KARISHMA ON 10/27/21 for AZ TO GET THE COUNT OF STORES AN ITEM IS
	 * AUTHORISED
	 * 
	 * @param conn
	 * @param locationId
	 * @param globalZone
	 * @param productId
	 * @return
	 * @throws Exception
	 */

	/** PROM-2214 changes started **/
	public HashMap<Integer, Integer> getItemStoreCount(Connection conn, int locationId, boolean globalZone,
			int productId) throws Exception {

		PreparedStatement stmt = null;
		ResultSet rs = null;
		HashMap<Integer, Integer> strItemMap = new HashMap<Integer, Integer>();

		try {
			String query = "";

			if (globalZone)
				query = new String(GET_STORE_ITEM_COUNT_FOR_GLOBAL_ZONE);
			else
				query = new String(GET_STORE_ITEM_COUNT);

			int counter = 0;
			stmt = conn.prepareStatement(query);
			stmt.setInt(++counter, productId);
			if (!globalZone) {
				stmt.setInt(++counter, locationId);
			}

			rs = stmt.executeQuery();

			//logger.info("getItemStoreCount- query: " + query);

			while (rs.next()) {

				strItemMap.put(rs.getInt("ITEM_CODE"), rs.getInt("STORE_COUNT"));
			}
		} catch (Exception ex) {
			logger.error("Error in getItemStoreCount() -- " + ex.toString());
			throw new Exception(ex);
		} finally {
			PristineDBUtil.close(rs);
			PristineDBUtil.close(stmt);
		}
		//logger.info("getItemStoreCount()- # items : " + strItemMap.size());
		return strItemMap;

	}
	/** PROM-2214 end  **/
	

	/**
	 * 
	 * @param conn
	 * @param recommendationInputDTO
	 * @param itemDataMap
	 * @return
	 * @throws GeneralException
	 */
	public void setPendingRetails(Connection conn, long runId, Object[] itemValues,
			HashMap<ItemKey, PRItemDTO> itemDataMap) throws GeneralException {
		PreparedStatement statement = null;
		ResultSet rst = null;
		PreparedStatement statementnew = null;
		ResultSet rs = null;

		try {
			StringBuffer sql = new StringBuffer();
			HashSet<Integer> retLirIdSet = new HashSet<>();
			sql.append("SELECT PRODUCT_ID , PRODUCT_LEVEL_ID, REC_REG_PRICE,  REC_REG_MULTIPLE, ");
			sql.append(
					"OVERRIDE_REG_MULTIPLE,OVERRIDE_REG_PRICE,PRC_CHANGE_IMPACT,TO_CHAR(REG_EFF_DATE, 'MM/DD/YYYY') AS REG_EFF_DATE, RUN_ID ");
			sql.append("FROM PR_QUARTER_REC_ITEM  WHERE RUN_ID = " + runId + " AND PRODUCT_ID IN(");

			for (int i = 0; i < itemValues.length; i++) {
				if (i != itemValues.length - 1)
					sql.append(itemValues[i] + ",");
				else
					sql.append(itemValues[i] + ")");
			}
			sql.append("AND REG_EFF_DATE IS NOT NULL AND IS_EXPORTED IS NULL");

			// logger.info("getPendingRetails qry : " + sql);

			statement = conn.prepareStatement(sql.toString());
			rst = statement.executeQuery();

			while (rst.next()) {

				ItemKey itemKey = null;

				if (rst.getInt("PRODUCT_LEVEL_ID") == Constants.ITEM_PRODUCT_LEVEL_ID)
					itemKey = new ItemKey(rst.getInt("PRODUCT_ID"), PRConstants.NON_LIG_ITEM_INDICATOR);
				else
					itemKey = new ItemKey(rst.getInt("PRODUCT_ID"), PRConstants.LIG_ITEM_INDICATOR);

				if (itemDataMap.containsKey(itemKey)) {
					PRItemDTO PRItemDTO = itemDataMap.get(itemKey);
					MultiplePrice approvedPrice = null;
					if (rst.getDouble("OVERRIDE_REG_PRICE") > 0)
						approvedPrice = new MultiplePrice(rst.getInt("OVERRIDE_REG_MULTIPLE"),
								rst.getDouble("OVERRIDE_REG_PRICE"));
					else
						approvedPrice = new MultiplePrice(rst.getInt("REC_REG_MULTIPLE"),
								rst.getDouble("REC_REG_PRICE"));

					PRItemDTO.setPendingRetail(approvedPrice);
					PRItemDTO.setApprovedImpact(rst.getDouble("PRC_CHANGE_IMPACT"));

					if (PRItemDTO.getRetLirId() > 0) {
						retLirIdSet.add(PRItemDTO.getRetLirId());
					}

				}
			}

			// get the approved impact for LIG representative row
			if (retLirIdSet.size() > 0) {
				StringBuffer qry = new StringBuffer();

				qry.append("SELECT PRODUCT_ID , PRODUCT_LEVEL_ID,PRC_CHANGE_IMPACT");
				qry.append(" FROM PR_QUARTER_REC_ITEM  WHERE RUN_ID = " + runId + " AND PRODUCT_ID IN(");
				int size = retLirIdSet.size();
				int counter = 0;

				for (int retLirId : retLirIdSet) {
					counter++;
					if (counter == size) {
						qry.append(retLirId + ")");
					} else
						qry.append(retLirId + ",");
				}

				qry.append("AND REG_EFF_DATE IS NOT NULL AND IS_EXPORTED IS NULL");

				// logger.info("getPendingRetails for LIg rep qry : " + qry);

				statementnew = conn.prepareStatement(qry.toString());
				rs = statementnew.executeQuery();
				while (rs.next()) {
					ItemKey itemKey = null;
					if (rs.getInt("PRODUCT_LEVEL_ID") == Constants.PRODUCT_LEVEL_ID_LIG)
						itemKey = new ItemKey(rs.getInt("PRODUCT_ID"), PRConstants.LIG_ITEM_INDICATOR);
					if (itemKey != null && itemDataMap.containsKey(itemKey)) {
						PRItemDTO PRItemDTO = itemDataMap.get(itemKey);
						PRItemDTO.setApprovedImpact(rs.getDouble("PRC_CHANGE_IMPACT"));
					}
				}

			}

		} catch (Exception e) {
			logger.error("setPendingRetails()-Exception while setting  pending retails :" + e);
			throw new GeneralException("setPendingRetails -Exception while setting  pending retails ", e);
		} finally {
			PristineDBUtil.close(rst);
			PristineDBUtil.close(statement);
			PristineDBUtil.close(rs);
			PristineDBUtil.close(statementnew);
		}

	}
	/**
	 * 
	 * @param conn
	 * @param recommendationInputDTO
	 * @return
	 * @throws GeneralException
	 */
	public HashMap<Long, List<Integer>> getItemsAndRunIdWithPendingRetails(Connection conn,
			RecommendationInputDTO recommendationInputDTO) throws GeneralException {
		PreparedStatement statement = null;
		ResultSet rst = null;
		int counter = 0;
		HashMap<Long, List<Integer>> runIdAndItemMap = new HashMap<>();

		try {
			statement = conn.prepareStatement(GET_ITEMS_AND_RUN_ID_FROM_EXPORT_QUEUE);

			logger.info("getItemsAndRunIdWithPendingRetails :- " +
			 GET_ITEMS_AND_RUN_ID_FROM_EXPORT_QUEUE);

			statement.setInt(++counter, recommendationInputDTO.getLocationLevelId());
			statement.setInt(++counter, recommendationInputDTO.getLocationId());
			statement.setInt(++counter, recommendationInputDTO.getProductLevelId());
			statement.setInt(++counter, recommendationInputDTO.getProductId());
			rst = statement.executeQuery();

			while (rst.next()) {

				List<Integer> temp = new ArrayList<>();

				if (runIdAndItemMap.containsKey(rst.getLong("RUN_ID"))) {
					temp = runIdAndItemMap.get(rst.getLong("RUN_ID"));
				}
				temp.add(rst.getInt("ITEM_CODE"));
				runIdAndItemMap.put(rst.getLong("RUN_ID"), temp);
			}

		} catch (Exception e) {
			logger.error(
					"getItemsAndRunIdWithPendingRetails()-Exception while getting the run Id and items with  pending retails :"
							+ e);
			throw new GeneralException(
					"getItemsAndRunIdWithPendingRetails -Exception while getting the run Id and items with  ", e);
		} finally {
			PristineDBUtil.close(rst);
			PristineDBUtil.close(statement);
		}

		return runIdAndItemMap;

	}
	
	/**
	 * 
	 * @param conn
	 * @param inputDTO
	 * @param startWeek
	 * @param endWeek
	 * @param itemDataMap
	 * @return
	 * @throws Exception 
	 */
	public void getPreviousYearsMovementDataForZone(Connection conn, PRStrategyDTO inputDTO, String startWeek,
			String endWeek, HashMap<ItemKey, PRItemDTO> inputMap) throws Exception {

		String previousYearStartDate=DateUtil.localDateToString(LocalDate.parse(startWeek, formatter).minusDays(365),Constants.APP_DATE_FORMAT);
		String previousYearEndDate=DateUtil.localDateToString(LocalDate.parse(endWeek, formatter).minusDays(365),Constants.APP_DATE_FORMAT);
		
		long noOfWeeks = getNoOfWeeksForDateRange(conn, previousYearStartDate, previousYearEndDate);
				
		logger.info("getPreviousYearsMovementDataForZone()- startweek: "
				+ LocalDate.parse(startWeek, formatter).minusDays(365) + "End Week:  "
				+ LocalDate.parse(endWeek, formatter).minusDays(365) + " noOfweeks: " + noOfWeeks);

		Set<Integer> itemList = new HashSet<Integer>();
		for (PRItemDTO prItemDTO : inputMap.values()) {
			if (!prItemDTO.isLir())
				itemList.add(prItemDTO.getItemCode());
		}

		List<Integer> itemCodeList = new ArrayList<Integer>();

		int limitcount = 0;

		for (Integer itemCode : itemList) {
			itemCodeList.add(itemCode);
			limitcount++;
			if (limitcount > 0 && (limitcount % this.commitCount == 0)) {
				Object[] values = itemCodeList.toArray();
				retrievelastYearMovementDataForZone(conn, startWeek, endWeek, inputMap, inputDTO, values,noOfWeeks);
				itemCodeList.clear();
			}
		}
		
		if (itemCodeList.size() > 0) {
			Object[] values = itemCodeList.toArray();
			retrievelastYearMovementDataForZone(conn, startWeek, endWeek, inputMap, inputDTO, values,noOfWeeks);
			itemCodeList.clear();
		}
	}


	private void retrievelastYearMovementDataForZone(Connection connection, String weekStartDate, String weekEndDate,
			HashMap<ItemKey, PRItemDTO> inputMap, PRStrategyDTO inputDTO, Object[] values, long noOfWeeksIMS)
			throws Exception {

		PreparedStatement statement = null;
		ResultSet resultSet = null;

		try {
			String query = new String(GET_LAST_YEARS_MOVEMENT_FROM_IMS);
			query = query.replaceAll("%PRICE_ZONE_ID%", String.valueOf(inputDTO.getLocationId()));

			String items = "";
			for (Object itemCode : values) {
				items = items + "," + (Integer) itemCode;
			}
			statement = connection
					.prepareStatement(String.format(query, PristineDBUtil.preparePlaceHolders(values.length)));

			int counter = values.length;
			PristineDBUtil.setValues(statement, 1, values);
			statement.setString(++counter, weekStartDate);
			statement.setString(++counter, weekEndDate);

			statement.setFetchSize(100000);
			resultSet = statement.executeQuery();

			while (resultSet.next()) {

				ItemKey itemKey = new ItemKey(resultSet.getInt("ITEM_CODE"), PRConstants.NON_LIG_ITEM_INDICATOR);
				if (inputMap.get(itemKey) != null) {
					PRItemDTO tDTO = inputMap.get(itemKey);
					double totalMovement = resultSet.getDouble("MOVEMENT");
					double totalRevenue = resultSet.getDouble("REVENUE");
					tDTO.setAvgMovement(totalMovement / noOfWeeksIMS);
					tDTO.setAvgRevenue(totalRevenue / noOfWeeksIMS);
					inputMap.put(itemKey, tDTO);
				}

			}
		} catch (Exception ex) {
			logger.error("Error in retrievelastYearMovementDataForZone() -- " + ex.toString());
			throw new Exception(ex);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}

	}
	
	// Get the No Of weeks between given date range
	private long getNoOfWeeksForDateRange(Connection connection, String startWeek, String endWeek) throws Exception {

		int noOfweeks = 0;
		String query = "SELECT COUNT(CALENDAR_ID) NO_OF_WEEKS FROM RETAIL_CALENDAR RC WHERE ROW_TYPE='W'"
				+ " AND RC.START_DATE >= TO_DATE('" + startWeek + "','MM/DD/YYYY') " + "AND RC.START_DATE <= TO_DATE('"
				+ endWeek + "','MM/DD/YYYY')";

		PreparedStatement statement = null;
		ResultSet resultSet = null;
		try {
			statement = connection.prepareStatement(query);
			resultSet = statement.executeQuery();

			while (resultSet.next()) {
				noOfweeks = resultSet.getInt("NO_OF_WEEKS");
			}
		} catch (Exception ex) {
			logger.error("Error in getNoOfWeeksForDateRange() -- " + ex.toString());
			throw new Exception(ex);
		} finally {
			PristineDBUtil.close(resultSet);
			PristineDBUtil.close(statement);
		}

		return noOfweeks;
	}
	
}
